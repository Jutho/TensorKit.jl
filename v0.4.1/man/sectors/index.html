<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sectors, representation spaces and fusion trees · TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li class="is-active"><a class="tocitem" href>Sectors, representation spaces and fusion trees</a><ul class="internal"><li><a class="tocitem" href="#ss_representationtheory-1"><span>Representation theory and unitary fusion categories</span></a></li><li><a class="tocitem" href="#ss_sectors-1"><span>Sectors</span></a></li><li><a class="tocitem" href="#ss_rep-1"><span>Representation spaces</span></a></li><li><a class="tocitem" href="#ss_fusiontrees-1"><span>Fusion trees</span></a></li><li><a class="tocitem" href="#Fermions-1"><span>Fermions</span></a></li><li><a class="tocitem" href="#Anyons-1"><span>Anyons</span></a></li></ul></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors an fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/sectors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_sectorsrepfusion-1"><a class="docs-heading-anchor" href="#s_sectorsrepfusion-1">Sectors, representation spaces and fusion trees</a><a class="docs-heading-anchor-permalink" href="#s_sectorsrepfusion-1" title="Permalink"></a></h1><p>Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.</p><p>The corresponding vector spaces will be canonically represented as <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>, where <span>$a$</span> labels the different irreps, <span>$n_a$</span> is the number of times irrep <span>$a$</span> appears and <span>$R_a$</span> is the vector space associated with irrep <span>$a$</span>. Irreps are also known as spin sectors (in the case of <span>$\mathsf{SU}_2$</span>) or charge sectors (in the case of <span>$\mathsf{U}_1$</span>), and we henceforth refer to <span>$a$</span> as a sector. As discussed in the section on <a href="../categories/#s_categories-1">categories</a>, and briefly summarized below, the approach we follow does in fact go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a unitary ribbon fusion category. Nonetheless, every step can be appreciated by using the representation theory of <span>$\mathsf{SU}_2$</span> or <span>$\mathsf{SU}_3$</span> as example. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space <span>$V$</span> is completely specified by the values of <span>$n_a$</span>.</p><p>The gain in efficiency (both in memory occupation and computation time) obtained from using (technically: equivariant) tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group&#39;s <a href="https://en.wikipedia.org/wiki/Clebsch–Gordan_coefficients">Clebsch–Gordan (CG) coefficients</a>. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or <a href="https://en.wikipedia.org/wiki/6-j_symbol">6j-symbols</a> (more accurately, the F-symbol is actually <a href="https://en.wikipedia.org/wiki/Racah_W-coefficient">Racah&#39;s W-coefficients</a> in the case of <span>$\mathsf{SU}_2$</span>).</p><p>Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space <span>$V$</span> composed of a direct sum of different sectors. In the third section, we explain the details of fusion trees, i.e. their construction and manipulation. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists. But first, we provide a quick theoretical overview of the required data of the representation theory of a group. We refer to the section on <a href="../categories/#s_categories-1">categories</a>, and in particular the subsection on <a href="../categories/#ss_topologicalfusion-1">topological data of a unitary fusion category</a>, for further details.</p><h2 id="ss_representationtheory-1"><a class="docs-heading-anchor" href="#ss_representationtheory-1">Representation theory and unitary fusion categories</a><a class="docs-heading-anchor-permalink" href="#ss_representationtheory-1" title="Permalink"></a></h2><p>Let the different irreps or sectors be labeled as <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, … First and foremost, we need to specify the <em>fusion rules</em> <span>$a ⊗ b = ⨁ N^{ab}_{c} c$</span> with <span>$N^{ab}_{c}$</span> some non-negative integers. There should always exists a unique trivial sector <span>$u$</span> (called the identity object <span>$I$</span> or <span>$1$</span> in the language of categories) such that <span>$a ⊗ u = a = u ⊗ a$</span>. Furthermore, there should exist a unique sector <span>$\bar{a}$</span> such that <span>$N^{a\bar{a}}_{u} = 1$</span>, whereas for all <span>$b \neq \bar{a}$</span>, <span>$N^{ab}_{u} = 0$</span>. For unitary irreps of groups, <span>$\bar{a}$</span> corresponds to the complex conjugate of the representation <span>$a$</span>, or a representation isomorphic to it. For example, for the representations of <span>$\mathsf{SU}_2$</span>, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. <span>$a = \bar{a}$</span>), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal but related by a similarity transform).</p><p>The meaning of the fusion rules is that the space of transformations <span>$R_a ⊗ R_b → R_c$</span> (or vice versa) has dimension <span>$N^{ab}_c$</span>. In particular, we assume the existence of a basis consisting of unitary tensor maps <span>$X^{ab}_{c,μ} : R_c → R_a ⊗ R_b$</span> with <span>$μ = 1, …, N^{ab}_c$</span> such that</p><p><span>$(X^{ab}_{c,μ})^† X^{ab}_{c,ν} = δ_{μ,ν} \mathrm{id}_{R_c}$</span></p><p>and</p><p><span>$\sum_{c} \sum_{μ = 1}^{N^{ab}_c} X^{ab}_{c,μ} (X^{ab}_{c,μ})^\dagger = \mathrm{id}_{R_a ⊗ R_b}$</span></p><p>The tensors <span>$X^{ab}_{c,μ}$</span> are the splitting tensors, their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e. acting on the multiplicity label <span>$μ = 1, …, N^{ab}_c$</span>. For <span>$\mathsf{SU}_2$</span>, where <span>$N^{ab}_c$</span> is zero or one and the multiplicity labels are absent, the entries of <span>$X^{ab}_{c,μ}$</span> are precisely given by the CG coefficients. The point is that we do not need to know the tensors <span>$X^{ab}_{c,μ}$</span> explicitly, but only the topological data of (the representation category of) the group, which describes the following transformation:</p><ul><li><p>F-move or recoupling: the transformation between <span>$(a ⊗ b) ⊗ c$</span> to <span>$a ⊗ (b ⊗ c)$</span>:</p><p><span>$(X^{ab}_{e,μ} ⊗ \mathrm{id}_c) ∘ X^{ec}_{d,ν} = ∑_{f,κ,λ} [F^{abc}_{d}]_{e,μν}^{f,κλ} (\mathrm{id}_a ⊗ X^{bc}_{f,κ}) ∘ X^{af}_{d,λ}$</span></p></li><li><p><a href="../categories/#ss_braiding-1">Braiding</a> or permuting as defined by   <span>$τ_{a,b}: R_a ⊗ R_b → R_b ⊗ R_a$</span>:   <span>$τ_{R_a,R_b} ∘ X^{ab}_{c,μ} = ∑_{ν} [R^{ab}_c]^ν_μ X^{ba}_{c,ν}$</span></p></li></ul><p>The dimensions of the spaces <span>$R_a$</span> on which representation <span>$a$</span> acts are denoted as <span>$d_a$</span> and referred to as quantum dimensions. In particular <span>$d_u = 1$</span> and <span>$d_a = d_{\bar{a}}$</span>. This information is also encoded in the F-symbol as <span>$d_a = | [F^{a \bar{a} a}_a]^u_u |^{-1}$</span>. Note that there are no multiplicity labels in that particular F-symbol as <span>$N^{a\bar{a}}_u = 1$</span>.</p><p>There is a graphical representation associated with the fusion tensors and their manipulations, which we summarize here:</p><p><img src="../img/tree-summary.svg" alt="summary"/></p><p>As always, we refer to the subsection on <a href="../categories/#ss_topologicalfusion-1">topological data of a unitary fusion category</a> for further details.</p><p>Finally, for the implementation, it will be useful to distinguish between an number of different possibilities regarding the fusion rules. If, for every <span>$a$</span> and <span>$b$</span>, there is a unique <span>$c$</span> such that <span>$a ⊗ b = c$</span> (i.e. <span>$N^{ab}_{c} = 1$</span> and <span>$N^{ab}_{c′} = 0$</span> for all other <span>$c′$</span>), the category is abelian. Indeed, the representations of a group have this property if and only if the group multiplication law is commutative. In that case, all spaces <span>$R_{a}$</span> associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all <span>$N^{ab}_c$</span> equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of <span>$\mathsf{SU}_2$</span>, and those where some <span>$N^{ab}_c$</span> are larger than one, e.g. the representations of <span>$\mathsf{SU}_3$</span>.</p><h2 id="ss_sectors-1"><a class="docs-heading-anchor" href="#ss_sectors-1">Sectors</a><a class="docs-heading-anchor-permalink" href="#ss_sectors-1" title="Permalink"></a></h2><p>We introduce a new abstract type to represent different possible sectors</p><pre><code class="language-julia">abstract type Sector end</code></pre><p>Any concrete subtype of <code>Sector</code> should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category, as reviewed in the subsections on <a href="../categories/#ss_fusion-1">fusion categories</a> and their <a href="../categories/#ss_topologicalfusion-1">topological data</a> within the introduction to <a href="../categories/#s_categories-1">category theory</a>. Throughout TensorKit.jl, the method <code>sectortype</code> can be used to query the subtype of <code>Sector</code> associated with a particular object, i.e. a vector space, fusion tree, tensor map, or a sector. It works on both instances and in the type domain, and its use will be illustrated further on.</p><p>The minimal data to completely specify a type of sector are</p><ul><li>the fusion rules, i.e. <span>$a ⊗ b = ⨁ N^{ab}_{c} c$</span>; this is implemented by a function   <a href="../../lib/sectors/#TensorKit.Nsymbol"><code>Nsymbol(a,b,c)</code></a></li><li>the list of fusion outputs from <span>$a ⊗ b$</span>; while this information is contained in   <span>$N^{ab}_c$</span>, it might be costly or impossible to iterate over all possible values of   <code>c</code> and test <code>Nsymbol(a,b,c)</code>; instead we implement for <code>a ⊗ b</code> to return an iterable   object (e.g. tuple, array or a custom Julia type that listens to <code>Base.iterate</code>) and   which generates all <code>c</code> for which <span>$N^{ab}_c ≠ 0$</span> (just once even if <span>$N^{ab}_c&gt;1$</span>)</li><li>the identity object <code>u</code>, such that <span>$a ⊗ u = a = u ⊗ a$</span>; this is implemented by the   function <code>one(a)</code> (and also in type domain) from Julia Base</li><li>the dual or conjugate representation <span>$\overline{a}$</span> for which   <span>$N^{a\bar{a}}_{u} = 1$</span>; this is implemented by <code>conj(a)</code> from Julia Base;   <code>dual(a)</code> also works as alias, but <code>conj(a)</code> is the method that should be defined</li><li>the F-symbol or recoupling coefficients <span>$[F^{abc}_{d}]^f_e$</span>, implemented as the   function <a href="../../lib/sectors/#TensorKit.Fsymbol"><code>Fsymbol(a,b,c,d,e,f)</code></a></li><li>the R-symbol <span>$R^{ab}_c$</span>, implemented as the function <a href="../../lib/sectors/#TensorKit.Rsymbol"><code>Rsymbol(a,b,c)</code></a></li></ul><p>For practical reasons, we also require some additional methods to be defined:</p><ul><li><code>isreal(::Type{&lt;:Sector})</code> returns whether the topological data of this type of sector   is real-valued or not (in which case it is complex-valued). Note that this does not   necessarily require that the representation itself, or the Clebsch-Gordan coefficients,   are real. There is a fallback implementation that checks whether the F-symbol and R-symbol evaluated with all sectors equal to the identity sector have real <code>eltype</code>.</li><li><code>hash(a, h)</code> creates a hash of sectors, because sectors and objects created from them   are used as keys in lookup tables (i.e. dictionaries)</li><li><code>isless(a,b)</code> associates a canonical order to sectors (of the same type), in order to   unambiguously represent representation spaces <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>.</li></ul><p>Further information, such as the quantum dimensions <span>$d_a$</span> and Frobenius-Schur indicator <span>$χ_a$</span> (only if <span>$a == \overline{a}$</span>) are encoded in the F-symbol. They are obtained as <a href="../../lib/sectors/#TensorKit.dim-Tuple{Sector}"><code>dim(a)</code></a> and <a href="../../lib/sectors/#TensorKit.frobeniusschur"><code>frobeniusschur(a)</code></a>. These functions have default definitions which extract the requested data from <code>Fsymbol(a,conj(a),a,a,one(a),one(a))</code>, but they can be overloaded in case the value can be computed more efficiently.</p><p>We also define a parametric type to represent an indexable iterator over the different values of a sector as</p><pre><code class="language-julia">struct SectorValues{G&lt;:Sector} end
Base.IteratorEltype(::Type{&lt;:SectorValues}) = HasEltype()
Base.eltype(::Type{SectorValues{G}}) where {G&lt;:Sector} = G
Base.values(::Type{G}) where {G&lt;:Sector} = SectorValues{G}()</code></pre><p>Note that an instance of the singleton type <code>SectorValues{G}</code> is obtained as <code>values(G)</code>. A new sector <code>G&lt;:Sector</code> should define</p><pre><code class="language-julia">Base.iterate(::SectorValues{G}[, state]) = ...
Base.IteratorSize(::Type{SectorValues{G}}) = # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::SectorValues{G}) = ...
Base.getindex(::SectorValues{G}, i::Int) = ...
findindex(::SectorValues{G}, c::G) = ...</code></pre><p>If the number of values in a sector <code>G</code> is finite (i.e. <code>IteratorSize(values(G)) == HasLength()</code>), the methods <code>getindex</code> and <code>findindex</code> provide a way to map the different sector values from and to the standard range 1, 2, …, <code>length(values(G))</code>. This is used to efficiently represent <code>RepresentationSpace</code> objects for this type of sector, as discussed in the next section on <a href="#ss_rep-1">Representation Spaces</a>. Note that <code>findindex</code> acts similar to <code>Base.indexin</code>, but with the order of the arguments reversed (so that is more similar to <code>getindex</code>), and returns an <code>Int</code> rather than an <code>Array{0,Union{Int,Nothing}}</code>.</p><p>It is useful to distinguish between three cases with respect to the fusion rules. For irreps of Abelian groups, we have that for every <span>$a$</span> and <span>$b$</span>, there exists a unique <span>$c$</span> such that <span>$a ⊗ b = c$</span>, i.e. there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. All other cases are referred to as non-abelian, i.e. the irreps of a non-abelian group or some more general fusion category. We still distinguish between the case where all entries of <span>$N^{ab}_c ≦ 1$</span>, i.e. they are zero or one. In that case, <span>$[F^{abc}_{d}]^f_e$</span> and <span>$R^{ab}_c$</span> are scalars. If some <span>$N^{ab}_c &gt; 1$</span>, it means that the same sector <span>$c$</span> can appear more than once in the fusion product of <span>$a$</span> and <span>$b$</span>, and we need to introduce some multiplicity label <span>$μ$</span> for the different copies. We implement a &quot;trait&quot; (similar to <code>IndexStyle</code> for <code>AbstractArray</code>s in Julia Base), i.e. a type hierarchy</p><pre><code class="language-julia">abstract type FusionStyle end
struct Abelian &lt;: FusionStyle
end
abstract type NonAbelian &lt;: FusionStyle end
struct SimpleNonAbelian &lt;: NonAbelian # non-abelian fusion but multiplicity free
end
struct DegenerateNonAbelian &lt;: NonAbelian # non-abelian fusion with multiplicities
end</code></pre><p>New sector types <code>G&lt;:Sector</code> should then indicate which fusion style they have by defining <code>FusionStyle(::Type{G})</code>.</p><p>In a similar manner, it is useful to distinguish between different styles of braiding. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case and, as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial <em>twist</em>. We thereto define a new type hierarchy</p><pre><code class="language-julia">abstract type BraidingStyle end # generic braiding
abstract type SymmetricBraiding &lt;: BraidingStyle end
struct Bosonic &lt;: SymmetricBraiding end
struct Fermionic &lt;: SymmetricBraiding end
struct Anyonic &lt;: BraidingStyle end</code></pre><p>New sector types <code>G&lt;:Sector</code> should then indicate which fusion style they have by defining <code>BraidingStyle(::Type{G})</code>. Note that <code>Bosonic()</code> braiding does not mean that all permutations are trivial and <span>$R^{ab}_c = 1$</span>, but that <span>$R^{ab}_c R^{ba}_c = 1$</span>. For example, for the irreps of <span>$\mathsf{SU}_2$</span>, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is <span>$-1$</span>, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a <code>Bosonic()</code> braiding style, all twists are simply <span>$+1$</span>. The case of fermions and anyons are discussed below.</p><p>Before discussing in more detail how a new sector type should be implemented, let us study the cases which have already been implemented. Currently, they all correspond to the irreps of groups.</p><h3 id="sss_groups-1"><a class="docs-heading-anchor" href="#sss_groups-1">Existing group representations</a><a class="docs-heading-anchor-permalink" href="#sss_groups-1" title="Permalink"></a></h3><p>The first sector type is called <code>Trivial</code>, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:</p><pre><code class="language-julia">struct Trivial &lt;: Sector
end
Base.one(a::Sector) = one(typeof(a))
Base.one(::Type{Trivial}) = Trivial()
Base.conj(::Trivial) = Trivial()
⊗(::Trivial, ::Trivial) = (Trivial(),)
Nsymbol(::Trivial, ::Trivial, ::Trivial) = true
Fsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1
Rsymbol(::Trivial, ::Trivial, ::Trivial) = 1
Base.isreal(::Type{Trivial}) = true
FusionStyle(::Type{Trivial}) = Abelian()
BraidingStyle(::Type{Trivial}) = Bosonic()</code></pre><p>The <code>Trivial</code> sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.</p><p>For all abelian groups, we gather a number of common definitions</p><pre><code class="language-julia">abstract type AbelianIrrep &lt;: Sector end

Base.@pure FusionStyle(::Type{&lt;:AbelianIrrep}) = Abelian()
Base.@pure BraidingStyle(::Type{&lt;:AbelianIrrep}) = Bosonic()

Nsymbol(a::G, b::G, c::G) where {G&lt;:AbelianIrrep} = c == first(a ⊗ b)
Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G) where {G&lt;:AbelianIrrep} =
    Int(Nsymbol(a,b,e)*Nsymbol(e,c,d)*Nsymbol(b,c,f)*Nsymbol(a,f,d))
frobeniusschur(a::AbelianIrrep) = 1
Bsymbol(a::G, b::G, c::G) where {G&lt;:AbelianIrrep} = Float64(Nsymbol(a, b, c))
Rsymbol(a::G, b::G, c::G) where {G&lt;:AbelianIrrep} = Float64(Nsymbol(a, b, c))
Base.isreal(::Type{&lt;:AbelianIrrep}) = true</code></pre><p>With these common definition, we implement the representation theory of the two most common Abelian groups, namely <span>$ℤ_N$</span></p><pre><code class="language-julia">struct ZNIrrep{N} &lt;: AbelianIrrep
    n::Int8
    function ZNIrrep{N}(n::Integer) where {N}
        new{N}(mod(n, N))
    end
end
Base.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)
Base.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)
⊗(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)

Base.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()
Base.length(::SectorValues{ZNIrrep{N}}) where N = N
Base.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =
    return i == N ? nothing : (ZNIrrep{N}(i), i+1)
Base.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =
    1 &lt;= i &lt;= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))
findindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1</code></pre><p>and <span>$\mathsf{U}_1$</span></p><pre><code class="language-julia">struct U1Irrep &lt;: AbelianIrrep
    charge::HalfInt
end
Base.one(::Type{U1Irrep}) = U1Irrep(0)
Base.conj(c::U1Irrep) = U1Irrep(-c.charge)
⊗(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)

Base.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{U1Irrep}, i = 0) =
    return i &lt;= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)
# the following are not used and thus not really necessary
function Base.getindex(::SectorValues{U1Irrep}, i::Int)
    i &lt; 1 &amp;&amp; throw(BoundsError(values(U1Irrep), i))
    return U1Irrep(iseven(i) ? half(i&gt;&gt;1) : -half(i&gt;&gt;1))
end
findindex(::SectorValues{U1Irrep}, c::U1Irrep) = (n = twice(c.charge); 2*abs(n)+(n&lt;=0))</code></pre><p>We also define some abbreviated Unicode aliases</p><pre><code class="language-julia">const ℤ₂ = ZNIrrep{2}
const ℤ₃ = ZNIrrep{3}
const ℤ₄ = ZNIrrep{4}
const U₁ = U1Irrep</code></pre><p>In the definition of <code>U1Irrep</code>, <code>HalfInt&lt;:Number</code> is a Julia type defined in <a href="https://github.com/sostock/HalfIntegers.jl">HalfIntegers.jl</a>, which is also used for <code>SU2Irrep</code> below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of <code>U₁</code> can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of <code>HalfInt</code>, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example</p><pre><code class="language-julia-repl">julia&gt; U₁(0.5)
U₁(1/2)

julia&gt; U₁(0.4)
ERROR: InexactError: Int64(0.8)

julia&gt; U₁(1) ⊗ U₁(1//2)
(U₁(3/2),)

julia&gt; u = first(U₁(1) ⊗ U₁(1//2))
U₁(3/2)

julia&gt; Nsymbol(u, conj(u), one(u))
true

julia&gt; z = ℤ₃(1)
ℤ₃(1)

julia&gt; z ⊗ z
(ℤ₃(2),)

julia&gt; conj(z)
ℤ₃(2)

julia&gt; one(z)
ℤ₃(0)</code></pre><p>For <code>ZNIrrep{N}</code>, we use an <code>Int8</code> for compact storage, assuming that this type will not be used with <code>N&gt;64</code> (we need <code>2*(N-1) &lt;= 127</code> in order for <code>a ⊗ b</code> to work correctly).</p><p>As a further remark, even in the abelian case where <code>a ⊗ b</code> is equivalent to a single new label <code>c</code>, we return it as an iterable container, in this case a one-element tuple <code>(c,)</code>.</p><p>As mentioned above, we also provide the following definitions</p><pre><code class="language-julia">Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)
Base.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)
Base.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)
Base.isless(c1::U1Irrep, c2::U1Irrep) where {N} =
    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) &lt; c1.charge == -c2.charge</code></pre><p>Since sectors or objects made out of tuples of sectors (see the section on <a href="#ss_fusiontrees-1">Fusion Trees</a> below) are often used as keys in look-up tables (i.e. subtypes of <code>AbstractDictionary</code> in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value. Note that hashes will only be used to compare sectors of the same type. The <code>isless</code> function provides a canonical order for sectors of a given type <code>G&lt;:Sector</code>, which is useful to uniquely and unambiguously specify a representation space <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>, as described in the section on <a href="#ss_rep-1">Representation spaces</a> below.</p><p>The first example of a non-abelian representation category is that of <span>$\mathsf{SU}_2$</span>, the implementation of which is summarized by</p><pre><code class="language-julia">struct SU2Irrep &lt;: Sector
    j::HalfInt
end
Base.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))
Base.conj(s::SU2Irrep) = s
⊗(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))
dim(s::SU2Irrep) = twice(s.j)+1
Base.@pure FusionStyle(::Type{SU2Irrep}) = SimpleNonAbelian()
Base.isreal(::Type{SU2Irrep}) = true
Nsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.δ(sa.j, sb.j, sc.j)
Fsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,
        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =
    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))
function Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)
    Nsymbol(sa, sb, sc) || return 0.
    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0
end
Base.hash(s::SU2Irrep, h::UInt) = hash(s.j, h)
Base.isless(s1::SU2Irrep, s2::SU2Irrep) = isless(s1.j, s2.j)
const SU₂ = SU2Irrep
const SO₃ = SU2Irrep
Base.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{SU2Irrep}, i = 0) = (SU2Irrep(half(i)), i+1)
# unused and not really necessary:
Base.getindex(::SectorValues{SU2Irrep}, i::Int) =
    1 &lt;= i ? SU2Irrep(half(i-1)) : throw(BoundsError(values(SU2Irrep), i))
findindex(::SectorValues{SU2Irrep}, s::SU2Irrep) = twice(s.j)+1</code></pre><p>and some methods for pretty printing and converting from real numbers to irrep labels. As one can notice, the topological data (i.e. <code>Nsymbol</code> and <code>Fsymbol</code>) are provided by the package <a href="https://github.com/Jutho/WignerSymbols.jl">WignerSymbols.jl</a>. The iterable <code>a ⊗ b</code> is a custom type, that the user does not need to care about. Some examples</p><pre><code class="language-julia-repl">julia&gt; s = SU₂(3//2)
SU₂(3/2)

julia&gt; conj(s)
SU₂(3/2)

julia&gt; dim(s)
4

julia&gt; collect(s ⊗ s)
4-element Array{SU₂,1}:
 0
 1
 2
 3

julia&gt; for s2 in s ⊗ s
           @show s2
           @show Nsymbol(s, s, s2)
           @show Rsymbol(s, s, s2)
       end
s2 = SU₂(0)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = SU₂(1)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0
s2 = SU₂(2)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = SU₂(3)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0</code></pre><p>A final non-abelian representation theory is that of the semidirect product <span>$\mathsf{U}₁ ⋉ ℤ_2$</span>, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of <span>$ℤ_2$</span> acts as charge conjugation <span>$C$</span>. It has the effect of interchaning <span>$\mathsf{U}_1$</span> irreps <span>$n$</span> and <span>$-n$</span>, and turns them together in a joint 2-dimensional index, except for the case <span>$n=0$</span>. Irreps are therefore labeled by integers <span>$n ≧ 0$</span>, however for <span>$n=0$</span> the <span>$ℤ₂$</span> symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with <span>$\mathsf{U})_1$</span> charge <span>$0$</span>. Given <span>$\mathsf{U}_1 ≂ \mathsf{SO}_2$</span>, this group is also simply known as <span>$\mathsf{O}_2$</span>, and the two representations with <span>$n = 0$</span> are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as <code>CU₁</code> or <code>CU1Irrep</code> in full.</p><pre><code class="language-julia">struct CU1Irrep &lt;: Irrep
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),
    # else s = 2 (two-dimensional representation)
    # Let constructor take the actual half integer value j
    function CU1Irrep(j::Real, s::Int = ifelse(j&gt;zero(j), 2, 0))
        if ((j &gt; zero(j) &amp;&amp; s == 2) || (j == zero(j) &amp;&amp; (s == 0 || s == 1)))
            new(j, s)
        else
            error(&quot;Not a valid CU₁ irrep&quot;)
        end
    end
end
Base.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)
Base.conj(c::CU1Irrep) = c
dim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)
Base.@pure FusionStyle(::Type{CU1Irrep}) = SimpleNonAbelian()
...
const CU₁ = CU1Irrep</code></pre><p>The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of <code>Fsymbol</code>.</p><p>So far, no sectors have been implemented with <code>FusionStyle(G) == DegenerateNonAbelian()</code>, though an example would be the representation theory of <span>$\mathsf{SU}_3$</span>. Such sectors are not yet fully supported; certain operations remain to be implemented. Furthermore, the topological data of the representation theory of such groups is not readily available and needs to be computed.</p><h3 id="sss_productsectors-1"><a class="docs-heading-anchor" href="#sss_productsectors-1">Combining different sectors</a><a class="docs-heading-anchor-permalink" href="#sss_productsectors-1" title="Permalink"></a></h3><p>It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator <code>×</code>, which can be entered as <code>\times</code>+TAB. Some examples</p><pre><code class="language-julia-repl">julia&gt; a = ℤ₃(1) × U₁(1)
WARNING: both LinearAlgebra and TensorKit export &quot;×&quot;; uses of it in module ex-sectors must be qualified
ERROR: UndefVarError: × not defined

julia&gt; typeof(a)
ERROR: UndefVarError: a not defined

julia&gt; conj(a)
ERROR: UndefVarError: a not defined

julia&gt; one(a)
ERROR: UndefVarError: a not defined

julia&gt; dim(a)
ERROR: UndefVarError: a not defined

julia&gt; collect(a ⊗ a)
ERROR: UndefVarError: a not defined

julia&gt; FusionStyle(a)
ERROR: UndefVarError: a not defined

julia&gt; b = ℤ₃(1) × SU₂(3//2)
ERROR: UndefVarError: × not defined

julia&gt; typeof(b)
ERROR: UndefVarError: b not defined

julia&gt; conj(b)
ERROR: UndefVarError: b not defined

julia&gt; one(b)
ERROR: UndefVarError: b not defined

julia&gt; dim(b)
ERROR: UndefVarError: b not defined

julia&gt; collect(b ⊗ b)
ERROR: UndefVarError: b not defined

julia&gt; FusionStyle(b)
ERROR: UndefVarError: b not defined

julia&gt; c = SU₂(1) × SU₂(3//2)
ERROR: UndefVarError: × not defined

julia&gt; typeof(c)
ERROR: UndefVarError: c not defined

julia&gt; conj(c)
ERROR: UndefVarError: c not defined

julia&gt; one(c)
ERROR: UndefVarError: c not defined

julia&gt; dim(c)
ERROR: UndefVarError: c not defined

julia&gt; collect(c ⊗ c)
ERROR: UndefVarError: c not defined

julia&gt; FusionStyle(c)
ERROR: UndefVarError: c not defined</code></pre><p>We refer to the source file of <a href="man/@ref"><code>ProductSector</code></a> for implementation details.</p><h3 id="sss_newsectors-1"><a class="docs-heading-anchor" href="#sss_newsectors-1">Defining a new type of sector</a><a class="docs-heading-anchor-permalink" href="#sss_newsectors-1" title="Permalink"></a></h3><p>By now, it should be clear how to implement a new <code>Sector</code> subtype. Ideally, a new <code>G&lt;:Sector</code> type is a <code>struct G ... end</code> (immutable) that has <code>isbitstype(G) == true</code> (see Julia&#39;s manual), and implements the following minimal set of methods</p><pre><code class="language-julia">Base.one(::Type{G}) = G(...)
Base.conj(a::G) = G(...)
Base.isreal(::Type{G}) = ... # true or false
TensorKit.FusionStyle(::Type{G}) = ... # Abelian(), SimpleNonAbelian(), DegenerateNonAbelian()
TensorKit.BraidingStyle(::Type{G}) = ... # Bosonic(), Fermionic(), Anyonic()
TensorKit.Nsymbol(a::G, b::G, c::G) = ...
    # Bool or Integer if FusionStyle(G) == DegenerateNonAbelian()
Base.:⊗(a::G, b::G) = ... # some iterable object that generates all possible fusion outputs
TensorKit.Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G)
TensorKit.Rsymbol(a::G, b::G, c::G)
Base.hash(a::G, h::UInt)
Base.isless(a::G, b::G)
Base.iterate(::TensorKit.SectorValues{G}[, state]) = ...
Base.IteratorSize(::Type{TensorKit.SectorValues{G}}) = ... # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::TensorKit.SectorValues{G}) = ...
Base.getindex(::TensorKit.SectorValues{G}, i::Int) = ...
TensorKit.findindex(::TensorKit.SectorValues{G}, c::G) = ...</code></pre><p>Additionally, suitable definitions can be given for</p><pre><code class="language-julia">TensorKit.dim(a::G) = ...
TensorKit.frobeniusschur(a::G) = ...
TensorKit.Bsymbol(a::G, b::G, c::G) = ...</code></pre><p>Out of these, we have not yet encountered the Frobenius-Schur indicator and the B-symbol. They were both defined in the section on <a href="../categories/#ss_topologicalfusion-1">topological data of fusion categories</a> and are fully determined by the F-symbol, just like the quantum dimensions. Hence, there is a default implementation for each of these three functions that just relies on <code>Fsymbol</code>, and alternative definitions need to be given only if a more efficient version is available.</p><p>If <code>FusionStyle(G) == DegenerateNonAbelian()</code>, then the multiple outputs <code>c</code> in the tensor product of <code>a</code> and <code>b</code> will be labeled as <code>i=1</code>, <code>2</code>, …, <code>Nsymbol(a,b,c)</code>. Optionally, a different label can be provided by defining</p><pre><code class="language-julia">TensorKit.vertex_ind2label(i::Int, a::G, b::G, c::G) = ...
# some label, e.g. a `Char` or `Symbol`</code></pre><p>The following function will then automatically determine the corresponding label type (which should not vary, i.e. <code>vertex_ind2label</code> should be type stable)</p><pre><code class="language-julia">Base.@pure vertex_labeltype(G::Type{&lt;:Sector}) =
    typeof(vertex_ind2label(1, one(G), one(G), one(G)))</code></pre><p>The following type, which already appeared in the implementation of <code>SU2Irrep</code> above, can be useful for providing the return type of <code>a ⊗ b</code></p><pre><code class="language-julia">struct SectorSet{G&lt;:Sector,F,S}
    f::F
    set::S
end
...
function Base.iterate(s::SectorSet{G}, args...) where {G&lt;:Sector}
    next = iterate(s.set, args...)
    next === nothing &amp;&amp; return nothing
    val, state = next
    return convert(G, s.f(val)), state
end</code></pre><p>That is, <code>SectorSet(f, set)</code> behaves as an iterator that applies <code>x-&gt;convert(G, f(x))</code> on the elements of <code>set</code>; if <code>f</code> is not provided it is just taken as the function <code>identity</code>.</p><h3 id="sss_generalsectors-1"><a class="docs-heading-anchor" href="#sss_generalsectors-1">Generalizations</a><a class="docs-heading-anchor-permalink" href="#sss_generalsectors-1" title="Permalink"></a></h3><p>As mentioned before, the framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) <a href="https://en.wikipedia.org/wiki/Fusion_category">fusion category</a>, which was reviewed at the end of the introduction to <a href="../categories/#s_categories-1">category theory</a>. For such categories, the objects are not necessarily vector spaces and the fusion and splitting tensors <span>$X^{ab}_{c,μ}$</span> do not necessarily exist as actual tensors. However, the morphism spaces <span>$c → a ⊗ b$</span> still behave as vector spaces, and the <span>$X^{ab}_{c,μ}$</span> act as generic basis for that space. As TensorKit.jl does not rely on the <span>$X^{ab}_{c,μ}$</span> themselves (even when they do exist) it can also deal with such general fusion categories. Note, though, that when <span>$X^{ab}_{c,μ}$</span> does exist, it is available as <code>fusiontensor(a,b,c[,μ])</code> (even though it is actually the splitting tensor) and can be useful for checking purposes, as illustrated below.</p><h2 id="ss_rep-1"><a class="docs-heading-anchor" href="#ss_rep-1">Representation spaces</a><a class="docs-heading-anchor-permalink" href="#ss_rep-1" title="Permalink"></a></h2><p>We have introduced <code>Sector</code> subtypes as a way to label the irreps or sectors in the decomposition <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>. To actually represent such spaces, we now also introduce a corresponding type <code>RepresentationSpace</code>, which is a subtype of <code>EuclideanSpace{ℂ}</code>, i.e.</p><pre><code class="language-julia">abstract type RepresentationSpace{G&lt;:Sector} &lt;: EuclideanSpace{ℂ} end</code></pre><p>Note that this is still an abstract type, nonetheless it will be the type name that the user calls to create specific instances.</p><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><p>The actual implementation comes in two flavors</p><pre><code class="language-julia">struct GenericRepresentationSpace{G&lt;:Sector} &lt;: RepresentationSpace{G}
    dims::SectorDict{G,Int}
    dual::Bool
end
struct FiniteRepresentationSpace{G&lt;:Sector,N} &lt;: RepresentationSpace{G}
    dims::NTuple{N,Int}
    dual::Bool
end</code></pre><p>The <code>GenericRepresentationSpace</code> implementation stores the different sectors <span>$a$</span> and their corresponding degeneracy <span>$n_a$</span> as key value pairs in an <code>Associative</code> array, i.e. a dictionary <code>dims::SectorDict</code>. <code>SectorDict</code> is a constant type alias for a specific dictionary implementation, either Julia&#39;s default <code>Dict</code> or the type <code>SortedVectorDict</code> implemented in TensorKit.jl. Note that only sectors <span>$a$</span> with non-zero <span>$n_a$</span> are stored. This implementation is used for sectors <code>G</code> which have <code>IteratorSize(values(G)) == IsInfinite()</code>.</p><p>If <code>IteratorSize(values(G)) == HasLength()</code>, the second implementation <code>FiniteRepresentationSpace</code> is used instead, which stores the values <span>$n_a$</span> for the different sectors in a tuple, the lenght of which is given by <code>N = length(values(G))</code>. The methods <code>getindex(values(G), i)</code> and <code>findindex(values(G), a)</code> are used to map between a sector <code>a::G</code> and a corresponding index <code>i ∈ 1:N</code>.</p><p>As mentioned, creating instances of these types goes via <code>RepresentationSpace</code>, using a list of pairs <code>a=&gt;n_a</code>, i.e. <code>V = RepresentationSpace(a=&gt;n_a, b=&gt;n_b, c=&gt;n_c)</code>. In this case, the sector type <code>G</code> is inferred from the sectors. However, it is often more convenient to specify the sector type explicitly, since then the sectors are automatically converted to the correct type, i.e. compare</p><pre><code class="language-julia-repl">julia&gt; RepresentationSpace{U1Irrep}(0=&gt;3, 1=&gt;2, -1=&gt;1) ==
           RepresentationSpace(U1Irrep(0)=&gt;3, U1Irrep(1)=&gt;2, U1Irrep(-1)=&gt;1)
true</code></pre><p>or using Unicode</p><pre><code class="language-julia-repl">julia&gt; RepresentationSpace{U₁}(0=&gt;3, 1=&gt;2, -1=&gt;1) ==
           RepresentationSpace(U₁(0)=&gt;3, U₁(-1)=&gt;1, U₁(1)=&gt;2)
true</code></pre><p>However, both are still to long for the most common cases. Therefore, we also have <code>ℂ[G&lt;:Sector]</code> as synonym for <code>RepresentationSpace{G}</code>, or simply <code>ℂ[a=&gt;n_a, b=&gt;n_b, c=&gt;n_c]</code> as alternative to <code>RepresentationSpace(a=&gt;n_a, b=&gt;n_b, c=&gt;n_c)</code>. Furthermore, for the common groups, we provide a number of type aliases, both in plain ASCII and in Unicode</p><pre><code class="language-julia">const ℤ₂Space = ZNSpace{2}
const ℤ₃Space = ZNSpace{3}
const ℤ₄Space = ZNSpace{4}
const U₁Space = GenericRepresentationSpace{U₁}
const CU₁Space = GenericRepresentationSpace{CU₁}
const SU₂Space = GenericRepresentationSpace{SU₂}

# non-Unicode alternatives
const Z2Space = ℤ₂Space
const Z3Space = ℤ₃Space
const Z4Space = ℤ₄Space
const U1Space = U₁Space
const CU1Space = CU₁Space
const SU2Space = SU₂Space</code></pre><p>such that we can simply write</p><pre><code class="language-julia-repl">julia&gt; RepresentationSpace{U₁}(0=&gt;3, 1=&gt;2, -1=&gt;1) ==
           RepresentationSpace(U₁(0)=&gt;3, U₁(-1)=&gt;1, U₁(1)=&gt;2) ==
           U₁Space(0=&gt;3, -1=&gt;1, 1=&gt;2) ==
           ℂ[U₁(0)=&gt;3, U₁(-1)=&gt;1, U₁(1)=&gt;2] ==
           ℂ[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1)
true</code></pre><h3 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h3><p>There are a number of methods to work with instances <code>V</code> of <code>RepresentationSpace</code>. The function <a href="../../lib/spaces/#TensorKit.sectortype"><code>sectortype</code></a> returns the type of the sector labels. It also works on other vector spaces, in which case it returns <a href="man/@ref"><code>Trivial</code></a>. The function <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors</code></a> returns an iterator over the different sectors <code>a</code> with non-zero <code>n_a</code>, for other <code>ElementarySpace</code> types it returns <code>(Trivial,)</code>. The degeneracy dimensions <code>n_a</code> can be extracted as <code>dim(V, a)</code>, it properly returns <code>0</code> if sector <code>a</code> is not present in the decomposition of <code>V</code>. With <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(V, a)</code></a> one can check if <code>V</code> contains a sector <code>a</code> with <code>dim(V,a)&gt;0</code>. Finally, <code>dim(V)</code> returns the total dimension of the space <code>V</code>, i.e. <span>$∑_a n_a d_a$</span> or thus <code>dim(V) = sum(dim(V,a) * dim(a) for a in sectors(V))</code>. Note that a representation space <code>V</code> has certain sectors <code>a</code> with dimensions <code>n_a</code>, then its dual <code>V&#39;</code> will report to have sectors <code>dual(a)</code>, and <code>dim(V&#39;, dual(a)) == n_a</code>. There is a subtelty regarding the difference between the dual of a representation space <span>$R_a^*$</span>, on which the conjugate representation acts, and the representation space of the irrep <code>dual(a)==conj(a)</code> that is isomorphic to the conjugate representation, i.e. <span>$R_{\bar{a}} ≂ R_a^*$</span> but they are not equal. We return to this in the section on <a href="#ss_fusiontrees-1">fusion trees</a>.</p><p>Other methods for <code>ElementarySpace</code>, such as <a href="../../lib/spaces/#TensorKit.dual"><code>dual</code></a>, <a href="../../lib/spaces/#TensorKit.fuse"><code>fuse</code></a> and <a href="../../lib/spaces/#TensorKit.flip"><code>flip</code></a> also work. In fact, <code>RepresentationSpace</code> is the reason <code>flip</code> exists, cause in this case it is different then <code>dual</code>. The existence of flip originates from the non-trivial isomorphism between <span>$R_{\overline{a}}$</span> and <span>$R_{a}^*$</span>, i.e. the representation space of the dual <span>$\overline{a}$</span> of sector <span>$a$</span> and the dual of the representation space of sector <span>$a$</span>. In order for <code>flip(V)</code> to be isomorphic to <code>V</code>, it is such that, if <code>V = RepresentationSpace(a=&gt;n_a,...)</code> then <code>flip(V) = dual(RepresentationSpace(dual(a)=&gt;n_a,....))</code>.</p><p>Furthermore, for two spaces <code>V1 = RepresentationSpace(a=&gt;n1_a, ...)</code> and <code>V2 = RepresentationSpace(a=&gt;n2_a, ...)</code>, we have <code>infinum(V1,V2) = RepresentationSpace(a=&gt;min(n1_a,n2_a), ....)</code> and similarly for <code>supremum</code>, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of <code>infinum(V1,V2)</code> or <code>supremum(V1,V2)</code> is neither equal to <code>V1</code> or <code>V2</code>.</p><p>For <code>W</code> a <code>ProductSpace{&lt;:RepresentationSpace{G},N}</code>, <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors(W)</code></a> returns an iterator that generates all possible combinations of sectors <code>as</code> represented as <code>NTuple{G,N}</code>. The function <a href="../../lib/spaces/#TensorKit.dims"><code>dims(W, as)</code></a> returns the corresponding tuple with degeneracy dimensions, while <a href="../../lib/sectors/#TensorKit.dim-Tuple{Sector}"><code>dim(W, as)</code></a> returns the product of these dimensions. <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(W, as)</code></a> is equivalent to <code>dim(W, as)&gt;0</code>. Finally, there is the function <a href="../../lib/spaces/#TensorKit.blocksectors"><code>blocksectors(W)</code></a> which returns a list (of type <code>Vector</code>) with all possible &quot;block sectors&quot; or total/coupled sectors that can result from fusing the individual uncoupled sectors in <code>W</code>. Correspondingly, <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim(W, a)</code></a> counts the total dimension of coupled sector <code>a</code> in <code>W</code>. The machinery for computing this is the topic of the next section on <a href="#ss_fusiontrees-1">Fusion trees</a>, but first, it&#39;s time for some examples.</p><h3 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h3><p>Let&#39;s start with an example involving <span>$\mathsf{U}_1$</span>:</p><pre><code class="language-julia-repl">julia&gt; V1 = RepresentationSpace{U₁}(0=&gt;3, 1=&gt;2, -1=&gt;1)
U₁Space(0=&gt;3, 1=&gt;2, -1=&gt;1)

julia&gt; V1 == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1) == U₁Space(-1=&gt;1, 1=&gt;2,0=&gt;3) # order doesn&#39;t matter
true

julia&gt; (sectors(V1)...,)
(U₁(0), U₁(1), U₁(-1))

julia&gt; dim(V1, U₁(1))
2

julia&gt; dim(V1&#39;, U₁(1)) == dim(V1, conj(U₁(1))) == dim(V1, U₁(-1))
true

julia&gt; hassector(V1, U₁(1))
true

julia&gt; hassector(V1, U₁(2))
false

julia&gt; dual(V1)
U₁Space(0=&gt;3, 1=&gt;2, -1=&gt;1)&#39;

julia&gt; flip(V1)
U₁Space(0=&gt;3, 1=&gt;1, -1=&gt;2)&#39;

julia&gt; dual(V1) ≅ V1
false

julia&gt; flip(V1) ≅ V1
true

julia&gt; V2 = U1Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)
U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)

julia&gt; infinum(V1,V2)
U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1)

julia&gt; supremum(V1,V2)
U₁Space(0=&gt;3, 1=&gt;2, -1=&gt;1, 2=&gt;1, -2=&gt;1)

julia&gt; ⊕(V1,V2)
U₁Space(0=&gt;5, 1=&gt;3, -1=&gt;2, 2=&gt;1, -2=&gt;1)

julia&gt; W = ⊗(V1,V2)
(U₁Space(0=&gt;3, 1=&gt;2, -1=&gt;1) ⊗ U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1))

julia&gt; collect(sectors(W))
3×5 Array{Tuple{Any,Any},2}:
 (U₁(0), U₁(0))   (U₁(0), U₁(1))   …  (U₁(0), U₁(2))   (U₁(0), U₁(-2))
 (U₁(1), U₁(0))   (U₁(1), U₁(1))      (U₁(1), U₁(2))   (U₁(1), U₁(-2))
 (U₁(-1), U₁(0))  (U₁(-1), U₁(1))     (U₁(-1), U₁(2))  (U₁(-1), U₁(-2))

julia&gt; dims(W, (U₁(0), U₁(0)))
(3, 2)

julia&gt; dim(W, (U₁(0), U₁(0)))
6

julia&gt; hassector(W, (U₁(0), U₁(0)))
true

julia&gt; hassector(W, (U₁(2), U₁(0)))
false

julia&gt; fuse(W)
U₁Space(0=&gt;9, 1=&gt;8, -1=&gt;7, 2=&gt;5, -2=&gt;4, 3=&gt;2, -3=&gt;1)

julia&gt; (blocksectors(W)...,)
(U₁(0), U₁(1), U₁(-1), U₁(2), U₁(-2), U₁(3), U₁(-3))

julia&gt; blockdim(W, U₁(0))
9</code></pre><p>and then with <span>$\mathsf{SU}_2$</span>:</p><pre><code class="language-julia-repl">julia&gt; V1 = RepresentationSpace{SU₂}(0=&gt;3, 1//2=&gt;2, 1=&gt;1)
SU₂Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1)

julia&gt; V1 == SU2Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1) == SU₂Space(0=&gt;3, 0.5=&gt;2, 1=&gt;1)
true

julia&gt; (sectors(V1)...,)
(SU₂(0), SU₂(1/2), SU₂(1))

julia&gt; dim(V1, SU₂(1))
1

julia&gt; dim(V1&#39;, SU₂(1)) == dim(V1, conj(SU₂(1))) == dim(V1, SU₂(1))
true

julia&gt; dim(V1)
10

julia&gt; hassector(V1, SU₂(1))
true

julia&gt; hassector(V1, SU₂(2))
false

julia&gt; dual(V1)
SU₂Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;

julia&gt; flip(V1)
SU₂Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;

julia&gt; V2 = SU2Space(0=&gt;2, 1//2=&gt;1, 1=&gt;1, 3//2=&gt;1, 2=&gt;1)
SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)

julia&gt; infinum(V1,V2)
SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1)

julia&gt; supremum(V1,V2)
SU₂Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)

julia&gt; ⊕(V1,V2)
SU₂Space(0=&gt;5, 1/2=&gt;3, 1=&gt;2, 3/2=&gt;1, 2=&gt;1)

julia&gt; W = ⊗(V1,V2)
(SU₂Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1) ⊗ SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1))

julia&gt; collect(sectors(W))
3×5 Array{Tuple{Any,Any},2}:
 (SU₂(0), SU₂(0))    (SU₂(0), SU₂(1/2))    …  (SU₂(0), SU₂(2))
 (SU₂(1/2), SU₂(0))  (SU₂(1/2), SU₂(1/2))     (SU₂(1/2), SU₂(2))
 (SU₂(1), SU₂(0))    (SU₂(1), SU₂(1/2))       (SU₂(1), SU₂(2))

julia&gt; dims(W, (SU₂(0), SU₂(0)))
(3, 2)

julia&gt; dim(W, (SU₂(0), SU₂(0)))
6

julia&gt; hassector(W, (SU₂(0), SU₂(0)))
true

julia&gt; hassector(W, (SU₂(2), SU₂(0)))
false

julia&gt; fuse(W)
SU₂Space(0=&gt;9, 1/2=&gt;11, 1=&gt;11, 3/2=&gt;9, 2=&gt;7, 5/2=&gt;3, 3=&gt;1)

julia&gt; (blocksectors(W)...,)
(SU₂(0), SU₂(1/2), SU₂(1), SU₂(3/2), SU₂(2), SU₂(5/2), SU₂(3))

julia&gt; blockdim(W, SU₂(0))
9</code></pre><h2 id="ss_fusiontrees-1"><a class="docs-heading-anchor" href="#ss_fusiontrees-1">Fusion trees</a><a class="docs-heading-anchor-permalink" href="#ss_fusiontrees-1" title="Permalink"></a></h2><p>The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (equivariant) tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors, i.e. they exhibit block sparsity. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section <a href="../../lib/spaces/#TensorKit.blocksectors"><code>blocksectors</code></a> and <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim</code></a> defined on the type <a href="../../lib/spaces/#TensorKit.ProductSpace"><code>ProductSpace</code></a>.</p><p>This basis transform consists of a basis of inclusion and projection maps, denoted as <span>$X^{a_1a_2…a_N}_{c,α}: R_c → R_{a_1} ⊗ R_{a_2} ⊗ … ⊗ R_{a_N}$</span> and their adjoints <span>$(X^{a_1a_2…a_N}_{c,α})^†$</span>, such that</p><p><span>$(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c$</span></p><p>and</p><p><span>$∑_{c,α} X^{a_1a_2…a_N}_{c,α} ∘ (X^{a_1a_2…a_N}_{c,α})^†  = \mathrm{id}_{a_1 ⊗ a_2 ⊗ … ⊗ a_N} = \mathrm{id}_{a_1} ⊗ \mathrm{id}_{a_2} ⊗ … ⊗ \mathrm{id}_{a_N}$</span></p><p>Fusion trees provide a particular way to construct such a basis. It is useful to know about the existence of fusion trees and how they are represented, as discussed in the first subsection. The next two subsections discuss possible manipulations that can be performed with fusion trees. These are used under the hood when manipulating the indices of tensors, but a typical user would not need to use these manipulations on fusion trees directly. Hence, these last two sections can safely be skipped.</p><h3 id="Canonical-representation-1"><a class="docs-heading-anchor" href="#Canonical-representation-1">Canonical representation</a><a class="docs-heading-anchor-permalink" href="#Canonical-representation-1" title="Permalink"></a></h3><p>To couple or fuse the different sectors together into a single block sector, we can sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector, using the splitting tensors <span>$X_{a,b}^{c,μ} : R_c → R_a ⊗ R_b$</span> and their adjoints. This amounts to the canonical choice of our tensor product, and for a given tensor mapping from <span>$(((W_1 ⊗ V_2) ⊗ V_3) ⊗ … )⊗ W_{N_2})$</span> to <span>$(((V_1 ⊗ V_2) ⊗ V_3) ⊗ … )⊗ V_{N_1})$</span>, the corresponding fusion and splitting trees take the form</p><p><img src="../img/tree-simple.svg" alt="double fusion tree"/></p><p>for the specific case <span>$N_1=4$</span> and <span>$N_2=3$</span>. We can separate this tree into the fusing part <span>$(b_1⊗b_2)⊗b_3 → c$</span> and the splitting part <span>$c→(((a_1⊗a_2)⊗a_3)⊗a_4)$</span>. Given that the fusion tree can be considered to be the adjoint of a corresponding splitting tree <span>$c→(b_1⊗b_2)⊗b_3$</span>, we now first consider splitting trees in isolation. A splitting tree which goes from one coupled sectors <span>$c$</span> to <span>$N$</span> uncoupled sectors <span>$a_1$</span>, <span>$a_2$</span>, …, <span>$a_N$</span> needs <span>$N-2$</span> additional internal sector labels <span>$e_1$</span>, …, <span>$e_{N-2}$</span>, and, if <code>FusionStyle(G) isa DegenerateNonAbelian</code>, <span>$N-1$</span> additional multiplicity labels <span>$μ_1$</span>, …, <span>$μ_{N-1}$</span>. We henceforth refer to them as vertex labels, as they are associated with the vertices of the splitting tree. In the case of <code>FusionStyle(G) isa Abelian</code>, the internal sectors <span>$e_1$</span>, …, <span>$e_{N-2}$</span> are completely fixed, for <code>FusionStyle(G) isa NonAbelian</code> they can also take different values. In our abstract notation of the splitting basis <span>$X^{a_1a_2…a_N}_{c,α}$</span> used above, <span>$α$</span> can be consided a collective label, i.e. <span>$α = (e_1, …, e_{N-2}; μ₁, … ,μ_{N-1})$</span>. Indeed, we can check the orthogonality condition <span>$(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c$</span>, which now forces all internal lines <span>$e_k$</span> and vertex labels <span>$μ_l$</span> to be the same.</p><p>There is one subtle remark that we have so far ignored. Within the specific subtypes of <code>Sector</code>, we do not explicitly distinguish between <span>$R_a^*$</span> (simply denoted as <span>$a`^*$</span> and graphically depicted as an upgoing arrow <span>$a$</span>) and <span>$R_{\bar{a}}$</span> (simply denoted as <span>$\bar{a}$</span> and depicted with a downgoing arrow), i.e. between the dual space of <span>$R_a$</span> on which the conjugated irrep acts, or the irrep <span>$\bar{a}$</span> to which the complex conjugate of irrep <span>$a$</span> is isomorphic. This distinction is however important, when certain uncoupled sectors in the fusion tree actually originate from a dual space. We use the isomorphisms <span>$Z_a:R_a^* → R_{\bar{a}}$</span> and its adjoint <span>$Z_a^†:R_{\bar{a}}→R_a^*$</span>, as introduced in the section on <a href="../categories/#ss_topologicalfusion-1">topological data of a fusion category</a>, to build fusion and splitting trees that take the distinction between irreps and their conjugates into account. Hence, in the previous example, if e.g. the first and third space in the codomain and the second space in the domain of the tensor were dual spaces, the actual pair of splitting and fusion tree would look as</p><p><img src="../img/tree-extended.svg" alt="extended double fusion tree"/></p><p>The presence of these isomorphisms will be important when we start to bend lines, to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. Note that we can still represent the fusion tree as the adjoint of a corresponding splitting tree, because we also use the adjoint of the <span>$Z$</span> isomorphisms in the splitting part, and the <span>$Z$</span> isomorphism in the fusion part. Furthermore, the presence of the <span>$Z$</span> isomorphisms does not affect the orthonormality.</p><p>We represent splitting trees and their adjoints using a specific immutable type called <code>FusionTree</code> (which actually represents a splitting tree, but fusion tree is a more common term), defined as</p><pre><code class="language-julia">struct FusionTree{G&lt;:Sector,N,M,L,T}
    uncoupled::NTuple{N,G}
    coupled::G
    isdual::NTuple{N,Bool}
    innerlines::NTuple{M,G} # fixed to M = N-2
    vertices::NTuple{L,T} # fixed to L = N-1
end</code></pre><p>Here, the fields are probably self-explanotary. The <code>isdual</code> field indicates whether an isomorphism is present (if the corresponding value is <code>true</code>) or not. Note that the field <code>uncoupled</code> contains the sectors coming out of the splitting trees, before the possible <span>$Z$</span> isomorphism, i.e. the splitting tree in the above example would have <code>sectors = (a₁, a₂, a₃, a₄)</code>. The <code>FusionTree</code> type has a number of basic properties and capabilities, such as checking for equality with <code>==</code> and support for <code>hash(f::FusionTree, h::UInt)</code>, as splitting and fusion trees are used as keys in look-up tables (i.e. <code>AbstractDictionary</code> instances) to look up certain parts of the data of a tensor. The type of <code>L</code> of the vertex labels can be <code>Nothing</code> when they are not needed (i.e. if <code>FusionStyle(G) ∈ (Abelian(), NonAbelian())</code>).</p><p><code>FusionTree</code> instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. The most natural way to create them is by using the <code>fusiontrees(uncoupled::NTuple{N,G}, coupled::G = one(G))</code> method, which returns an iterator over all possible fusion trees from a set of <code>N</code> uncoupled sectors to a given coupled sector, which by default is assumed to be the trivial sector of that group or fusion category (i.e. the identity object in categorical nomenclature). The return type of <code>fusiontrees</code> is a custom type <code>FusionTreeIterator</code> which conforms to the complete interface of an iterator, and has a custom <code>length</code> function that computes the number of possible fusion trees without iterating over all of them explicitly. This is best illustrated with some examples</p><pre><code class="language-julia-repl">julia&gt; s = SU₂(1/2)
SU₂(1/2)

julia&gt; collect(fusiontrees((s,s,s,s)))
2-element Array{FusionTree{SU₂,4,2,3,Nothing},1}:
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (0, 1/2))
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (1, 1/2))

julia&gt; collect(fusiontrees((s,s,s,s,s), s, (true, false, false, true, false)))
5-element Array{FusionTree{SU₂,5,3,4,Nothing},1}:
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 0))
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 1))
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 0))
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 1))
 FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 3/2, 1))

julia&gt; iter = fusiontrees(ntuple(n-&gt;s, 16))
TensorKit.FusionTreeIterator{SU₂,16}((SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2)), SU₂(0), (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false))

julia&gt; sum(n-&gt;1, iter)
1430

julia&gt; length(iter)
1430

julia&gt; @elapsed sum(n-&gt;1, iter)
0.034341022

julia&gt; @elapsed length(iter)
7.58e-5

julia&gt; s2 = s × s
ERROR: UndefVarError: × not defined

julia&gt; collect(fusiontrees((s2,s2,s2,s2)))
ERROR: UndefVarError: s2 not defined</code></pre><p>Note that <code>FusionTree</code> instances are shown (printed) in a way that is valid code to reproduce them, a property which also holds for both instances of <code>Sector</code> and instances of <code>VectorSpace</code>. All of those should be displayed in a way that can be copy pasted as valid code. Furthermore, we use contact to determine how to print e.g. a sector. In isolation, <code>s2</code> is printed as <code>(SU₂(1/2) × SU₂(1/2))</code>, however, within the fusion tree, it is simply printed as <code>(1/2, 1/2)</code>, because it will be converted back into a <code>ProductSector</code>, namely <code>SU₂ × SU₂</code> by the constructor of <code>FusionTree{SU₂ × SU₂}</code>.</p><h3 id="Manipulations-on-a-fusion-tree-1"><a class="docs-heading-anchor" href="#Manipulations-on-a-fusion-tree-1">Manipulations on a fusion tree</a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-fusion-tree-1" title="Permalink"></a></h3><p>We now discuss elementary manipulations that we want to perform on or between fusion trees (where we actually mean splitting trees), which will form the building block for more general manipulations on a pair of a fusion and splitting tree discussed in the next subsection, and then for casting a general index manipulation of a tensor map as a linear operation in the basis of canonically ordered splitting and fusion trees. In this section, we will ignore the <span>$Z$</span> isomorphisms, as they are just trivially reshuffled under the different operations that we describe. These manipulations are used as low-level methods by the <code>TensorMap</code> methods discussed on the next page. As such, they are not exported by TensorKit.jl, nor do they overload similarly named methods from Julia Base (see <code>split</code> and <code>merge</code> below).</p><p>The first operation we discuss is an elementary braid of two neighbouring sectors (indices), i.e. a so-called Artin braid or Artin generator of the braid group. Because these two sectors do not appear on the same fusion vertex, some recoupling is necessary. The following represents two different ways to compute the result of such a braid as a linear combination of new fusion trees in canonical order:</p><p><img src="../img/tree-artinbraid.svg" alt="artin braid"/></p><p>While the upper path is the most intuitive, it requires two recouplings or F-moves (one forward and one reverse). On the other hand, the lower path requires only one (reverse) F- move, and two R-moves. The latter are less expensive to compute, and so the lower path is computationally more efficient. However, the end result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any new subtype of <code>Sector</code>, and it is up to the user to verify that they are when implementing new custom <code>Sector</code> types. This result is implemented in the function <a href="../../lib/sectors/#TensorKit.artin_braid"><code>artin_braid(f::FusionTree, i; inv = false)</code></a> where <code>i</code> denotes the position of the first sector (i.e. labeled <code>b</code> in the above graph) which is then braided with the sector at position <code>i+1</code> in the fusion tree <code>f</code>. The keyword argument <code>inv</code> allows to select the inverse braiding operation, which amounts to replacing the R-matrix with its inverse (or thus, adjoint) in the above steps. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as value. In the case of <code>FusionStyle(G) == Abelian()</code>, their is only one resulting fusion tree, with corresponding coefficient a complex phase (which is one for the bosonic representation theory of an Abelian group), and the result is a special <code>SingletonDict&lt;:AbstractDict</code>, a <code>struct</code> type defined in TensorKit.jl to hold a single key value pair.</p><p>With the elementary <code>artin_braid</code>, we can then compute a more general braid. For this, we provide an interface</p><p><a href="man/@ref"><code>braid(f::FusionTree{G,N}, levels::NTuple{N,Int}, permutation::NTuple{N,Int})</code></a></p><p>where the braid is specified as a permutation, such that the new sector at position <code>i</code> was originally at position <code>permutation[i]</code>, and where every uncoupled sector is also assigned a level or depth. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor. This interface does not allow to specify the most general braid, and in particular will never wind one line around another, but can be used as a more general building block for arbitrary braids than the elementary Artin generators. A graphical example makes this probably more clear, i.e for <code>levels=(1,2,3,4,5)</code> and <code>permutation=(5,3,1,4,2)</code>, the corresponding braid is given by</p><p><img src="../img/tree-braidinterface.svg" alt="braid interface"/></p><p>that is, the first sector or space goes to position 3, and crosses over all other lines, because it has the lowest level (i.e. think of level as depth in the third dimension), and so forth. We sketch this operation both as a general braid on the left hand side, and as a particular composition of Artin braids on the right hand side.</p><p>When <code>BraidingStyle(G) == SymmetricBraiding()</code>, there is no distinction between applying the braiding or its inverse (i.e. lines crossing over or under each other in the graphical notation) and the whole operation simplifies down to a permutation. We then also support the interface</p><p><a href="man/@ref"><code>permute(f::FusionTree{G,N}, permutation::NTuple{N,Int})</code></a></p><p>Other manipulations which are sometimes needed are</p><ul><li><p><a href="man/@ref TensorKit.insertat">insertat(f1::FusionTree{G,N₁}, i::Int, f2::FusionTree{G,N₂})</a> :   inserts a fusion tree <code>f2</code> at the <code>i</code>th uncoupled sector of fusion tree <code>f1</code> (this   requires that the coupled sector <code>f2</code> matches with the <code>i</code>th uncoupled sector of <code>f1</code>,   and that <code>!f1.isdual[i]</code>, i.e. that there is no <span>$Z$</span>-isomorphism on the <code>i</code>th line of   <code>f1</code>), and recouple this into a linear combination of trees in canonical order, with   <code>N₁+N₂-1</code> uncoupled sectors, i.e. diagrammatically for <code>i=3</code></p><p><img src="../img/tree-insertat.svg" alt="insertat"/></p></li><li><p><a href="man/@ref TensorKit.split">split(f::FusionTree{G,N}, StaticLength(M))</a> :   splits a fusion tree <code>f</code> into two trees <code>f1</code> and <code>f2</code>, such that <code>f1</code> has the first <code>M</code>   uncoupled sectors of <code>f</code>, and <code>f2</code> the remaining <code>N-M</code>. This is the inverse of   <code>insertat</code> in the sence that <code>insertat(f2, 1, f1)</code> should return a dictionary with a   single key-value pair <code>f=&gt;1</code>. Here, <code>M</code> is specified via <code>StaticLength</code> which is a value   type (i.e. it encodes the value of <code>M</code> in compile time information) exported by   TensorKit.jl (actually defined in TupleTools.jl) which supports basic arithmitic.   Diagrammatically, for <code>M=4</code>, the function <code>split</code> returns</p><p><img src="../img/tree-split.svg" alt="split"/></p></li><li><p><a href="man/@ref TensorKit.merge">merge(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂}, c::G, μ=nothing)</a> :   merges two fusion trees <code>f1</code> and <code>f2</code> by fusing the coupled sectors of <code>f1</code> and <code>f2</code>   into a sector <code>c</code> (with vertex label <code>μ</code> if <code>FusionStyle(G) == DegenerateNonAbelian()</code>),   and reexpressing the result as a linear combination of fusion trees with <code>N₁+N₂</code>   uncoupled sectors in canonical order. This is a simple application of <code>insertat</code>.   Diagrammatically, this operation is represented as:</p><p><img src="../img/tree-merge.svg" alt="merge"/></p></li></ul><h3 id="Manipulations-on-a-splitting-fusion-tree-pair-1"><a class="docs-heading-anchor" href="#Manipulations-on-a-splitting-fusion-tree-pair-1">Manipulations on a splitting - fusion tree pair</a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-splitting-fusion-tree-pair-1" title="Permalink"></a></h3><p>In this subsection we discuss manipulations that act on a splitting and fusion tree pair, which we will always as two separate trees <code>f1, f2</code>, where <code>f1</code> is the splitting tree and <code>f2</code> represents the fusion tree, and they should have <code>f1.coupled == f2.coupled</code>.</p><p>The most important manipulation on such a pair is to move sectors from one to the other. Given the canonical order of these trees, we exclusively use the <em>left duality</em> (see the section on <a href="../categories/#s_categories-1">categories</a>), for which the evaluation and coevaluation maps establish isomorphisms between</p><p><span>$\mathrm{Hom}((((b_1 ⊗ b_2) ⊗ …) ⊗ b_{N_2}), (((a_1 ⊗ a_2) ⊗ …) ⊗ a_{N_1}))$</span></p><p><span>$≂ \mathrm{Hom}((((b_1 ⊗ b_2) ⊗ ...) ⊗ b_{N_2-1}), ((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*))$</span></p><p><span>$≂ \mathrm{Hom}(1, (((((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*) ⊗ …) ⊗ b_2^*) ⊗ b_1^*) )$</span></p><p>where the last morphism space is then labeled by the basis of only splitting trees. We can then use the manipulations from the previous section, and then again use the left duality to bring this back to a pair of splitting and fusion tree with <code>N₂′</code> incoming and <code>N₁′</code> incoming sectors (with <code>N₁′ + N₂′ == N₁ + N₂</code>).</p><p>We now discuss how to actually bend lines, and thus, move sectors from the incoming part (fusion tree) to the outgoing part (splitting tree). Hereby, we exploit the relations between the (co)evaluation (exact pairing) and the fusion tensors, discussed in <a href="../categories/#ss_topologicalfusion-1">topological data of a fusion category</a>. The main ingredient that we need is summarized in</p><p><img src="../img/tree-linebending.svg" alt="line bending"/></p><p>We will only need the B-symbol and not the A-symbol. Applying the left evaluation on the second sector of a splitting tensor thus yields a linear combination of fusion tensors (when <code>FusionStyle(G) == DegenerateNonAbelian()</code>, or just a scalar times the corresponding fusion tensor otherwise), with corresponding <span>$Z$</span> ismorphism. Taking the adjoint of this relation yields the required relation to transform a fusion tensor into a splitting tensor with an added <span>$Z^†$</span> isomorphism.</p><p>However, we have to be careful if we bend a line on which a <span>$Z$</span> isomorphism (or its adjoint) is already present. Indeed, it is exactly for this operation that we explicitly need to take the presence of these isomorphisms into account. Indeed, we obtain the relation</p><p><img src="../img/tree-linebending2.svg" alt="dual line bending"/></p><p>Hence, bending an <code>isdual</code> sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and of course leads to a normal sector (which is no longer <code>isdual</code> and does thus not come with a <span>$Z$</span>-isomorphism) on the fusion side. We again use the adjoint of this relation to bend an <code>isdual</code> sector from the fusion tree to the splitting tree.</p><p>The <code>FusionTree</code> interface to duality and line bending is given by</p><p><code>repartition(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂}, StaticLength(N))</code></p><p>which takes a splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, and applies line bending such that the resulting splitting and fusion trees have <code>N</code> outgoing sectors, corresponding to the first <code>N</code> sectors out of the list <span>$(a_1, a_2, …, a_{N_1}, b_{N_2}^*, …, b_{1}^*)$</span> and <code>N₁+N₂-N</code> incoming sectors, corresponding to the dual of the last <code>N₁+N₂-N</code> sectors from the previous list, in reverse. Note that <code>N</code> is again provided via the <code>StaticLength</code> value type. Graphically, for <code>N₁ = 4</code>, <code>N₂ = 3</code>, <code>N = 2</code> and some particular of <code>isdual</code> in both the fusion and splitting tree:</p><p><img src="../img/tree-repartition.svg" alt="repartition"/></p><p>The result is returned as a dictionary with keys <code>(f1′, f2′)</code> and the corresponding <code>coeff</code> as value. Note that the summation is only over the <span>$κ_j$</span> labels, such that, in the case of <code>FusionStyle(G) ∈ (Abelian(), SimpleNonAbelian())</code>, the linear combination simplifies to a single term with a scalar coefficient.</p><p>With this basic function, we can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear. The interface provided for this is given by</p><p><a href="man/@ref"><code>braid(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂}, levels1::NTuple{N₁,Int}, levels2::NTuple{N₂,Int}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></a></p><p>where we now have splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, <code>levels1</code> and <code>levels2</code> assign a level or depth to the corresponding uncoupled sectors in <code>f1</code> and <code>f2</code>, and we represent the new configuration as a pair <code>p1</code> and <code>p2</code>. Together, <code>(p1..., p2...)</code> represents a permutation of length <code>N₁+N₂ = N₁′+N₂′</code>, where <code>p1</code> indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and <code>p2</code> indicates which appear as incoming sectors in the new fusion tree. Hereto, we label the uncoupled sectors of <code>f1</code> from <code>1</code> to <code>N₁</code>, followed by the uncoupled sectors of <code>f2</code> from <code>N₁+1</code> to <code>N₁+N₂</code>. Note that simply repartitioning the splitting and fusion tree such that e.g. all sectors appear in the new splitting tree (i.e. are outgoing), amounts to chosing <code>p1 = (1,..., N₁, N₁+N₂, N₁+N₂-1, ... , N₁+1)</code> and <code>p2=()</code>, because the duality isomorphism reverses the order of the tensor product.</p><p>This routine is implemented by indeed first making all sectors outgoing using the <code>repartition</code> function discussed above, such that only splitting trees remain, then braiding those using the routine from the previous subsection such that the new outgoing sectors appear first, followed by the new incoming sectors (in reverse order), and then again invoking the <code>repartition</code> routine to bring everything in final form. The result is again returned as a dictionary where the keys are <code>(f1′,f2′)</code> and the values the corresponding coefficients.</p><p>As before, there is a simplified interface for the case where <code>BraidingStyle(G) isa SymmetricBraiding</code> and the levels are not needed. This is simply given by</p><p><a href="man/@ref"><code>permute(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></a></p><p>The <code>braid</code> and <code>permute</code> routines for double fusion trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memoized, i.e. they are stored in some package wide &#39;least-recently used&#39; cache (from <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCache.jl</a>) that can be accessed as <code>TensorKit.braidcache</code>. By default, this cache stores up to <code>10^5</code> different <code>braid</code> or <code>permute</code> resuls, where one result corresponds to one particular combination of <code>(f1, f2, p1, p2, levels1, levels2)</code>. This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to <code>resize!(TensorKit.permutecache)</code> and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type <code>RefValue{Bool}</code>, namely <code>usebraidcache_abelian</code> and <code>usebraidcache_nonabelian</code>. The default values are given by <code>TensorKit.usebraidcache_abelian[] = false</code> and <code>TensorKit.usebraidcache_nonabelian[] = true</code>, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with <code>FusionStyle(f) isa Abelian</code>, but is probably useful for fusion trees with <code>FusionStyle(f) isa NonAbelian</code>. One can change these values and test the effect on their application.</p><p>The existence of <code>braidcache</code> also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.</p><h3 id="Inspecting-fusion-trees-as-tensors-1"><a class="docs-heading-anchor" href="#Inspecting-fusion-trees-as-tensors-1">Inspecting fusion trees as tensors</a><a class="docs-heading-anchor-permalink" href="#Inspecting-fusion-trees-as-tensors-1" title="Permalink"></a></h3><p>For those cases where the fusion and splitting tensors have an explicit representation as a tensor, i.e. a morphism in the category <code>Vect</code> (this essentially coincides with the case of group representations), this explicit representation can be created, which can be useful for checking purposes. Hereto, it is necessary that the <em>splitting tensor</em> <span>$X^{ab}_{c,μ}$</span>, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine <code>fusiontensor(a,b,c [,μ = nothing])</code>, where the last argument is only necessary in the case of <code>FusionStyle(G) == DegenerateNonAbelian()</code>. We can then convert a <code>FusionTree{G,N}</code> into an <code>Array</code>, which will yield a rank <code>N+1</code> array where the first <code>N</code> dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector. Note that this is mostly useful for the case of <code>FusionStyle(G) isa NonAbelian</code> groups, as in the case of abelian groups, all irreps are one-dimensional.</p><p>Some examples:</p><pre><code class="language-julia-repl">julia&gt; iter = fusiontrees((SU₂(1/2),SU₂(1/2),SU₂(1/2),SU₂(1/2)), SU₂(1))
TensorKit.FusionTreeIterator{SU₂,4}((SU₂(1/2), SU₂(1/2), SU₂(1/2), SU₂(1/2)), SU₂(1), (false, false, false, false))

julia&gt; f = first(iter)
FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))

julia&gt; convert(Array, f)
2×2×2×2×3 Array{Float64,5}:
[:, :, 1, 1, 1] =
  0.0       0.707107
 -0.707107  0.0

[:, :, 2, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 1, 2, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 2, 2, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 3] =
  0.0       0.707107
 -0.707107  0.0

julia&gt; I ≈ convert(Array, FusionTree((SU₂(1/2),), SU₂(1/2), (false,), ()))
true

julia&gt; Z = adjoint(convert(Array, FusionTree((SU₂(1/2),), SU₂(1/2), (true,), ())))
2×2 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
 0.0  -1.0
 1.0   0.0

julia&gt; transpose(Z) ≈ frobeniusschur(SU₂(1/2)) * Z
true

julia&gt; I ≈ convert(Array, FusionTree((SU₂(1),), SU₂(1), (false,), ()))
true

julia&gt; Z = adjoint(convert(Array, FusionTree((SU₂(1),), SU₂(1), (true,), ())))
3×3 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
 0.0   0.0  1.0
 0.0  -1.0  0.0
 1.0   0.0  0.0

julia&gt; transpose(Z) ≈ frobeniusschur(SU₂(1)) * Z
true

julia&gt; #check orthogonality
       for f1 in iter
         for f2 in iter
           dotproduct  = dot(convert(Array, f1), convert(Array, f2))
           println(&quot;&lt; $f1, $f2&gt; = $dotproduct&quot;)
         end
       end
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 3.000000000000001
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 3.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{SU₂}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 3.0</code></pre><p>Note that we take the adjoint when computing <code>Z</code>, because <code>convert(Array, f)</code> assumes <code>f</code> to be splitting tree, which is built using <span>$Z^†$</span>. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the <span>$\mathrm{id}_c$</span> when checking the orthogonality by computing <code>dot</code> of the corresponding tensors.</p><h2 id="Fermions-1"><a class="docs-heading-anchor" href="#Fermions-1">Fermions</a><a class="docs-heading-anchor-permalink" href="#Fermions-1" title="Permalink"></a></h2><p>TODO</p><p>(Support for fermionic sectors and corresponding super vector spaces is on its way. This section will be completed when the implementation is finished.)</p><h2 id="Anyons-1"><a class="docs-heading-anchor" href="#Anyons-1">Anyons</a><a class="docs-heading-anchor-permalink" href="#Anyons-1" title="Permalink"></a></h2><p>There is currently one example of a <code>Sector</code> subtype that has anyonic braiding style, namely that of the Fibonacci fusion category. It has to (isomorphism classes of) simple objects, namely the identity <code>𝟙</code> and a non-trivial object known as <code>τ</code>, with fusion rules <code>τ ⊗ τ = 𝟙 ⊕ τ</code>. Let&#39;s summarize the topological data</p><pre><code class="language-julia-repl">julia&gt; 𝟙 = FibonacciAnyon(:I)
FibonacciAnyon(:I)

julia&gt; τ = FibonacciAnyon(:τ)
FibonacciAnyon(:τ)

julia&gt; collect(τ ⊗ τ)
2-element Array{FibonacciAnyon,1}:
 :I
 :τ

julia&gt; FusionStyle(τ)
SimpleNonAbelian()

julia&gt; BraidingStyle(τ)
Anyonic()

julia&gt; dim(𝟙)
1.0

julia&gt; dim(τ)
1.618033988749895

julia&gt; F𝟙 = Fsymbol(τ,τ,τ,𝟙,τ,τ)
1.0

julia&gt; Fτ = [Fsymbol(τ,τ,τ,τ,𝟙,𝟙) Fsymbol(τ,τ,τ,τ,𝟙,τ); Fsymbol(τ,τ,τ,τ,τ,𝟙) Fsymbol(τ,τ,τ,τ,τ,τ)]
2×2 Array{Float64,2}:
 0.618034   0.786151
 0.786151  -0.618034

julia&gt; Fτ&#39;*Fτ
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; polar(x) = rationalize.((abs(x), angle(x)/(2pi)))
polar (generic function with 1 method)

julia&gt; Rsymbol(τ,τ,𝟙) |&gt; polar
(1//1, 2//5)

julia&gt; Rsymbol(τ,τ,τ) |&gt; polar
(1//1, -3//10)

julia&gt; twist(τ) |&gt; polar
(1//1, -2//5)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spaces/">« Vector spaces</a><a class="docs-footer-nextpage" href="../tensors/">Tensors and the <code>TensorMap</code> type »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 10 May 2020 22:06">Sunday 10 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
