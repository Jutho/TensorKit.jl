<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sectors, representation spaces and fusion trees ¬∑ TensorKit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li class="is-active"><a class="tocitem" href>Sectors, representation spaces and fusion trees</a><ul class="internal"><li><a class="tocitem" href="#ss_representationtheory"><span>Representation theory and unitary fusion categories</span></a></li><li><a class="tocitem" href="#ss_sectors"><span>Sectors</span></a></li><li><a class="tocitem" href="#ss_rep"><span>Graded spaces</span></a></li><li><a class="tocitem" href="#ss_fusiontrees"><span>Fusion trees</span></a></li><li><a class="tocitem" href="#Fermions"><span>Fermions</span></a></li><li><a class="tocitem" href="#Anyons"><span>Anyons</span></a></li></ul></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors and fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/sectors.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_sectorsrepfusion"><a class="docs-heading-anchor" href="#s_sectorsrepfusion">Sectors, representation spaces and fusion trees</a><a id="s_sectorsrepfusion-1"></a><a class="docs-heading-anchor-permalink" href="#s_sectorsrepfusion" title="Permalink"></a></h1><p>Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.</p><p>The corresponding vector spaces will be canonically represented as <span>$V = ‚®Å_a ‚ÑÇ^{n_a} ‚äó R_{a}$</span>, where <span>$a$</span> labels the different irreps, <span>$n_a$</span> is the number of times irrep <span>$a$</span> appears and <span>$R_a$</span> is the vector space associated with irrep <span>$a$</span>. Irreps are also known as spin sectors (in the case of <span>$\mathsf{SU}_2$</span>) or charge sectors (in the case of <span>$\mathsf{U}_1$</span>), and we henceforth refer to <span>$a$</span> as a sector. As discussed in the section on <a href="../categories/#s_categories">categories</a>, and briefly summarized below, the approach we follow does in fact go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a unitary ribbon fusion category. Nonetheless, every step can be appreciated by using the representation theory of <span>$\mathsf{SU}_2$</span> or <span>$\mathsf{SU}_3$</span> as example. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space <span>$V$</span> is completely specified by the values of <span>$n_a$</span>.</p><p>The gain in efficiency (both in memory occupation and computation time) obtained from using (technically: equivariant) tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group&#39;s <a href="https://en.wikipedia.org/wiki/Clebsch‚ÄìGordan_coefficients">Clebsch‚ÄìGordan (CG) coefficients</a>. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or <a href="https://en.wikipedia.org/wiki/6-j_symbol">6j-symbols</a> (more accurately, the F-symbol is actually <a href="https://en.wikipedia.org/wiki/Racah_W-coefficient">Racah&#39;s W-coefficients</a> in the case of <span>$\mathsf{SU}_2$</span>).</p><p>Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space <span>$V$</span> composed of a direct sum of different sectors. In the third section, we explain the details of fusion trees, i.e. their construction and manipulation. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists. But first, we provide a quick theoretical overview of the required data of the representation theory of a group. We refer to the section on <a href="../categories/#s_categories">categories</a>, and in particular the subsection on <a href="../categories/#ss_topologicalfusion">topological data of a unitary fusion category</a>, for further details.</p><h2 id="ss_representationtheory"><a class="docs-heading-anchor" href="#ss_representationtheory">Representation theory and unitary fusion categories</a><a id="ss_representationtheory-1"></a><a class="docs-heading-anchor-permalink" href="#ss_representationtheory" title="Permalink"></a></h2><p>Let the different irreps or sectors be labeled as <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, ‚Ä¶ First and foremost, we need to specify the <em>fusion rules</em> <span>$a ‚äó b = ‚®Å N^{ab}_{c} c$</span> with <span>$N^{ab}_{c}$</span> some non-negative integers. There should always exists a unique trivial sector <span>$u$</span> (called the identity object <span>$I$</span> or <span>$1$</span> in the language of categories) such that <span>$a ‚äó u = a = u ‚äó a$</span>. Furthermore, there should exist a unique sector <span>$\bar{a}$</span> such that <span>$N^{a\bar{a}}_{u} = 1$</span>, whereas for all <span>$b \neq \bar{a}$</span>, <span>$N^{ab}_{u} = 0$</span>. For unitary irreps of groups, <span>$\bar{a}$</span> corresponds to the complex conjugate of the representation <span>$a$</span>, or a representation isomorphic to it. For example, for the representations of <span>$\mathsf{SU}_2$</span>, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. <span>$a = \bar{a}$</span>), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal but related by a similarity transform).</p><p>The meaning of the fusion rules is that the space of transformations <span>$R_a ‚äó R_b ‚Üí R_c$</span> (or vice versa) has dimension <span>$N^{ab}_c$</span>. In particular, we assume the existence of a basis consisting of unitary tensor maps <span>$X^{ab}_{c,Œº} : R_c ‚Üí R_a ‚äó R_b$</span> with <span>$Œº = 1, ‚Ä¶, N^{ab}_c$</span> such that</p><p><span>$(X^{ab}_{c,Œº})^‚Ä† X^{ab}_{c,ŒΩ} = Œ¥_{Œº,ŒΩ} \mathrm{id}_{R_c}$</span></p><p>and</p><p><span>$\sum_{c} \sum_{Œº = 1}^{N^{ab}_c} X^{ab}_{c,Œº} (X^{ab}_{c,Œº})^\dagger = \mathrm{id}_{R_a ‚äó R_b}$</span></p><p>The tensors <span>$X^{ab}_{c,Œº}$</span> are the splitting tensors, their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e. acting on the multiplicity label <span>$Œº = 1, ‚Ä¶, N^{ab}_c$</span>. For <span>$\mathsf{SU}_2$</span>, where <span>$N^{ab}_c$</span> is zero or one and the multiplicity labels are absent, the entries of <span>$X^{ab}_{c,Œº}$</span> are precisely given by the CG coefficients. The point is that we do not need to know the tensors <span>$X^{ab}_{c,Œº}$</span> explicitly, but only the topological data of (the representation category of) the group, which describes the following transformation:</p><ul><li><p>F-move or recoupling: the transformation between <span>$(a ‚äó b) ‚äó c$</span> to <span>$a ‚äó (b ‚äó c)$</span>:</p><p><span>$(X^{ab}_{e,Œº} ‚äó \mathrm{id}_c) ‚àò X^{ec}_{d,ŒΩ} = ‚àë_{f,Œ∫,Œª} [F^{abc}_{d}]_{e,ŒºŒΩ}^{f,Œ∫Œª} (\mathrm{id}_a ‚äó X^{bc}_{f,Œ∫}) ‚àò X^{af}_{d,Œª}$</span></p></li><li><p><a href="../categories/#ss_braiding">Braiding</a> or permuting as defined by   <span>$œÑ_{a,b}: R_a ‚äó R_b ‚Üí R_b ‚äó R_a$</span>:   <span>$œÑ_{R_a,R_b} ‚àò X^{ab}_{c,Œº} = ‚àë_{ŒΩ} [R^{ab}_c]^ŒΩ_Œº X^{ba}_{c,ŒΩ}$</span></p></li></ul><p>The dimensions of the spaces <span>$R_a$</span> on which representation <span>$a$</span> acts are denoted as <span>$d_a$</span> and referred to as quantum dimensions. In particular <span>$d_u = 1$</span> and <span>$d_a = d_{\bar{a}}$</span>. This information is also encoded in the F-symbol as <span>$d_a = | [F^{a \bar{a} a}_a]^u_u |^{-1}$</span>. Note that there are no multiplicity labels in that particular F-symbol as <span>$N^{a\bar{a}}_u = 1$</span>.</p><p>There is a graphical representation associated with the fusion tensors and their manipulations, which we summarize here:</p><p><img src="../img/tree-summary.svg" alt="summary"/></p><p>As always, we refer to the subsection on <a href="../categories/#ss_topologicalfusion">topological data of a unitary fusion category</a> for further details.</p><p>Finally, for the implementation, it will be useful to distinguish between an number of different possibilities regarding the fusion rules. If, for every <span>$a$</span> and <span>$b$</span>, there is a unique <span>$c$</span> such that <span>$a ‚äó b = c$</span> (i.e. <span>$N^{ab}_{c} = 1$</span> and <span>$N^{ab}_{c‚Ä≤} = 0$</span> for all other <span>$c‚Ä≤$</span>), the category is abelian. Indeed, the representations of a group have this property if and only if the group multiplication law is commutative. In that case, all spaces <span>$R_{a}$</span> associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all <span>$N^{ab}_c$</span> equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of <span>$\mathsf{SU}_2$</span>, and those where some <span>$N^{ab}_c$</span> are larger than one, e.g. the representations of <span>$\mathsf{SU}_3$</span>.</p><h2 id="ss_sectors"><a class="docs-heading-anchor" href="#ss_sectors">Sectors</a><a id="ss_sectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectors" title="Permalink"></a></h2><p>We introduce a new abstract type to represent different possible sectors</p><pre><code class="language-julia hljs">abstract type Sector end</code></pre><p>Any concrete subtype of <code>Sector</code> should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category, as reviewed in the subsections on <a href="../categories/#ss_fusion">fusion categories</a> and their <a href="../categories/#ss_topologicalfusion">topological data</a> within the introduction to <a href="../categories/#s_categories">category theory</a>. Throughout TensorKit.jl, the method <code>sectortype</code> can be used to query the subtype of <code>Sector</code> associated with a particular object, i.e. a vector space, fusion tree, tensor map, or a sector. It works on both instances and in the type domain, and its use will be illustrated further on.</p><p>The minimal data to completely specify a type of sector are</p><ul><li>the fusion rules, i.e. <span>$a ‚äó b = ‚®Å N^{ab}_{c} c$</span>; this is implemented by a function   <a href="../../lib/sectors/#TensorKit.Nsymbol"><code>Nsymbol(a,b,c)</code></a></li><li>the list of fusion outputs from <span>$a ‚äó b$</span>; while this information is contained in   <span>$N^{ab}_c$</span>, it might be costly or impossible to iterate over all possible values of   <code>c</code> and test <code>Nsymbol(a,b,c)</code>; instead we implement for <code>a ‚äó b</code> to return an iterable   object (e.g. tuple, array or a custom Julia type that listens to <code>Base.iterate</code>) and   which generates all <code>c</code> for which <span>$N^{ab}_c ‚â† 0$</span> (just once even if <span>$N^{ab}_c&gt;1$</span>)</li><li>the identity object <code>u</code>, such that <span>$a ‚äó u = a = u ‚äó a$</span>; this is implemented by the   function <code>one(a)</code> (and also in type domain) from Julia Base</li><li>the dual or conjugate representation <span>$\overline{a}$</span> for which   <span>$N^{a\bar{a}}_{u} = 1$</span>; this is implemented by <code>conj(a)</code> from Julia Base;   <code>dual(a)</code> also works as alias, but <code>conj(a)</code> is the method that should be defined</li><li>the F-symbol or recoupling coefficients <span>$[F^{abc}_{d}]^f_e$</span>, implemented as the   function <a href="../../lib/sectors/#TensorKit.Fsymbol"><code>Fsymbol(a,b,c,d,e,f)</code></a></li><li>the R-symbol <span>$R^{ab}_c$</span>, implemented as the function <a href="../../lib/sectors/#TensorKit.Rsymbol"><code>Rsymbol(a,b,c)</code></a></li></ul><p>For practical reasons, we also require some additional methods to be defined:</p><ul><li><code>isreal(::Type{&lt;:Sector})</code> returns whether the topological data of this type of sector   is real-valued or not (in which case it is complex-valued). Note that this does not   necessarily require that the representation itself, or the Clebsch-Gordan coefficients,   are real. There is a fallback implementation that checks whether the F-symbol and R-symbol evaluated with all sectors equal to the identity sector have real <code>eltype</code>.</li><li><code>hash(a, h)</code> creates a hash of sectors, because sectors and objects created from them   are used as keys in lookup tables (i.e. dictionaries)</li><li><code>isless(a,b)</code> associates a canonical order to sectors (of the same type), in order to   unambiguously represent representation spaces <span>$V = ‚®Å_a ‚ÑÇ^{n_a} ‚äó R_{a}$</span>.</li></ul><p>Further information, such as the quantum dimensions <span>$d_a$</span> and Frobenius-Schur indicator <span>$œá_a$</span> (only if <span>$a == \overline{a}$</span>) are encoded in the F-symbol. They are obtained as <a href="../../lib/sectors/#TensorKit.dim-Tuple{Sector}"><code>dim(a)</code></a> and <a href="../../lib/sectors/#TensorKit.frobeniusschur"><code>frobeniusschur(a)</code></a>. These functions have default definitions which extract the requested data from <code>Fsymbol(a,conj(a),a,a,one(a),one(a))</code>, but they can be overloaded in case the value can be computed more efficiently.</p><p>We also define a parametric type to represent an indexable iterator over the different values of a sector as</p><pre><code class="language-julia hljs">struct SectorValues{I&lt;:Sector} end
Base.IteratorEltype(::Type{&lt;:SectorValues}) = HasEltype()
Base.eltype(::Type{SectorValues{I}}) where {I&lt;:Sector} = I
Base.values(::Type{I}) where {I&lt;:Sector} = SectorValues{I}()</code></pre><p>Note that an instance of the singleton type <code>SectorValues{I}</code> is obtained as <code>values(I)</code>. A new sector <code>I&lt;:Sector</code> should define</p><pre><code class="language-julia hljs">Base.iterate(::SectorValues{I}[, state]) = ...
Base.IteratorSize(::Type{SectorValues{I}}) = # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::SectorValues{I}) = ...
Base.getindex(::SectorValues{I}, i::Int) = ...
findindex(::SectorValues{I}, c::I) = ...</code></pre><p>If the number of values in a sector <code>I</code> is finite (i.e. <code>IteratorSize(values(I)) == HasLength()</code>), the methods <code>getindex</code> and <code>findindex</code> provide a way to map the different sector values from and to the standard range 1, 2, ‚Ä¶, <code>length(values(I))</code>. This is used to efficiently represent <code>GradedSpace</code> objects for this type of sector, as discussed in the next section on <a href="#ss_rep">Graded spaces</a>. Note that <code>findindex</code> acts similar to <code>Base.indexin</code>, but with the order of the arguments reversed (so that is more similar to <code>getindex</code>), and returns an <code>Int</code> rather than an <code>Array{0,Union{Int,Nothing}}</code>.</p><p>It is useful to distinguish between three cases with respect to the fusion rules. For irreps of Abelian groups, we have that for every <span>$a$</span> and <span>$b$</span>, there exists a unique <span>$c$</span> such that <span>$a ‚äó b = c$</span>, i.e. there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. All other cases are referred to as non-abelian, i.e. the irreps of a non-abelian group or some more general fusion category. We still distinguish between the case where all entries of <span>$N^{ab}_c ‚â¶ 1$</span>, i.e. they are zero or one. In that case, <span>$[F^{abc}_{d}]^f_e$</span> and <span>$R^{ab}_c$</span> are scalars. If some <span>$N^{ab}_c &gt; 1$</span>, it means that the same sector <span>$c$</span> can appear more than once in the fusion product of <span>$a$</span> and <span>$b$</span>, and we need to introduce some multiplicity label <span>$Œº$</span> for the different copies. We implement a &quot;trait&quot; (similar to <code>IndexStyle</code> for <code>AbstractArray</code>s in Julia Base), i.e. a type hierarchy</p><pre><code class="language-julia hljs">abstract type FusionStyle end
struct UniqueFusion &lt;: FusionStyle # unique fusion output when fusion two sectors
end
abstract type MultipleFusion &lt;: FusionStyle end
struct SimpleFusion &lt;: MultipleFusion # multiple fusion but multiplicity free
end
struct GenericFusion &lt;: MultipleFusion # multiple fusion with multiplicities
end
const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}</code></pre><p>New sector types <code>I&lt;:Sector</code> should then indicate which fusion style they have by defining <code>FusionStyle(::Type{I})</code>.</p><p>In a similar manner, it is useful to distinguish between different styles of braiding. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case and, as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial <em>twist</em>. We thereto define a new type hierarchy</p><pre><code class="language-julia hljs">abstract type BraidingStyle end # generic braiding
abstract type SymmetricBraiding &lt;: BraidingStyle end
struct Bosonic &lt;: SymmetricBraiding end
struct Fermionic &lt;: SymmetricBraiding end
struct Anyonic &lt;: BraidingStyle end</code></pre><p>New sector types <code>I&lt;:Sector</code> should then indicate which fusion style they have by defining <code>BraidingStyle(::Type{I})</code>. Note that <code>Bosonic()</code> braiding does not mean that all permutations are trivial and <span>$R^{ab}_c = 1$</span>, but that <span>$R^{ab}_c R^{ba}_c = 1$</span>. For example, for the irreps of <span>$\mathsf{SU}_2$</span>, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is <span>$-1$</span>, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a <code>Bosonic()</code> braiding style, all twists are simply <span>$+1$</span>. The case of fermions and anyons are discussed below.</p><p>Before discussing in more detail how a new sector type should be implemented, let us study the cases which have already been implemented. Currently, they all correspond to the irreps of groups.</p><h3 id="sss_groups"><a class="docs-heading-anchor" href="#sss_groups">Existing group representations</a><a id="sss_groups-1"></a><a class="docs-heading-anchor-permalink" href="#sss_groups" title="Permalink"></a></h3><p>The first sector type is called <code>Trivial</code>, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:</p><pre><code class="language-julia hljs">struct Trivial &lt;: Sector
end
Base.one(a::Sector) = one(typeof(a))
Base.one(::Type{Trivial}) = Trivial()
Base.conj(::Trivial) = Trivial()
‚äó(::Trivial, ::Trivial) = (Trivial(),)
Nsymbol(::Trivial, ::Trivial, ::Trivial) = true
Fsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1
Rsymbol(::Trivial, ::Trivial, ::Trivial) = 1
Base.isreal(::Type{Trivial}) = true
FusionStyle(::Type{Trivial}) = UniqueFusion()
BraidingStyle(::Type{Trivial}) = Bosonic()</code></pre><p>The <code>Trivial</code> sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.</p><p>The most important class of sectors are irreducible representations of groups, for which we have an abstract supertype <code>Irrep{G}</code> that is parameterized on the type of group <code>G</code>. While the specific implementations of <code>Irrep{G}</code> depend on <code>G</code>, one can easily obtain the concrete type without knowing its name as <code>Irrep[G]</code>.</p><p>A number of groups have been defined, namely</p><pre><code class="language-julia hljs">abstract type Group end
abstract type AbelianGroup &lt;: Group end

abstract type ‚Ñ§{N} &lt;: AbelianGroup end
abstract type U‚ÇÅ &lt;: AbelianGroup end
abstract type SU{N} &lt;: Group end
abstract type CU‚ÇÅ &lt;: Group end

const ‚Ñ§‚ÇÇ = ‚Ñ§{2}
const ‚Ñ§‚ÇÉ = ‚Ñ§{3}
const ‚Ñ§‚ÇÑ = ‚Ñ§{4}
const SU‚ÇÇ = SU{2}</code></pre><p>Groups themselves are abstract types without any functionality (at least for now). We also provide a number of convenient Unicode aliases. These group names are probably self- explanatory, except for <code>CU‚ÇÅ</code> which is explained below.</p><p>For all group irreps, the braiding style is bosonic</p><pre><code class="language-julia hljs">abstract type AbstractIrrep{G&lt;:Group} &lt;: Sector end # irreps have integer quantum dimensions
BraidingStyle(::Type{&lt;:AbstractIrrep}) = Bosonic()</code></pre><p>while we gather some more common functionality for irreps of abelian groups (which exhaust all possibilities of fusion categories with abelian fusion)</p><pre><code class="language-julia hljs">const AbelianIrrep{G} = AbstractIrrep{G} where {G&lt;:AbelianGroup}
FusionStyle(::Type{&lt;:AbelianIrrep}) = UniqueFusion()
Base.isreal(::Type{&lt;:AbelianIrrep}) = true

Nsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = c == first(a ‚äó b)
Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I&lt;:AbelianIrrep} =
    Int(Nsymbol(a, b, e)*Nsymbol(e, c, d)*Nsymbol(b, c, f)*Nsymbol(a, f, d))
frobeniusschur(a::AbelianIrrep) = 1
Bsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = Int(Nsymbol(a, b, c))
Rsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = Int(Nsymbol(a, b, c))</code></pre><p>With these common definition, we implement the representation theory of the two most common Abelian groups, namely <span>$‚Ñ§_N$</span></p><pre><code class="language-julia hljs">struct ZNIrrep{N} &lt;: AbstractIrrep{‚Ñ§{N}}
    n::Int8
    function ZNIrrep{N}(n::Integer) where {N}
        @assert N &lt; 64
        new{N}(mod(n, N))
    end
end
Base.getindex(::IrrepTable, ::Type{‚Ñ§{N}}) where N = ZNIrrep{N}
Base.convert(Z::Type{&lt;:ZNIrrep}, n::Real) = Z(n)

Base.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)
Base.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)
‚äó(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)

Base.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()
Base.length(::SectorValues{ZNIrrep{N}}) where N = N
Base.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =
    return i == N ? nothing : (ZNIrrep{N}(i), i+1)
Base.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =
    1 &lt;= i &lt;= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))
findindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1</code></pre><p>and <span>$\mathsf{U}_1$</span></p><pre><code class="language-julia hljs">struct U1Irrep &lt;: AbstractIrrep{U‚ÇÅ}
    charge::HalfInt
end
Base.getindex(::IrrepTable, ::Type{U‚ÇÅ}) = U1Irrep
Base.convert(::Type{U1Irrep}, c::Real) = U1Irrep(c)

Base.one(::Type{U1Irrep}) = U1Irrep(0)
Base.conj(c::U1Irrep) = U1Irrep(-c.charge)
‚äó(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)

Base.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{U1Irrep}, i = 0) =
    return i &lt;= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)
# the following are not used and thus not really necessary
function Base.getindex(::SectorValues{U1Irrep}, i::Int)
    i &lt; 1 &amp;&amp; throw(BoundsError(values(U1Irrep), i))
    return U1Irrep(iseven(i) ? half(i&gt;&gt;1) : -half(i&gt;&gt;1))
end
findindex(::SectorValues{U1Irrep}, c::U1Irrep) = (n = twice(c.charge); 2*abs(n)+(n&lt;=0))</code></pre><p>The <code>getindex</code> definition just below the type definition provides the mechanism to get the concrete type as <code>Irrep[G]</code> for a given group <code>G</code>. Here, <code>IrrepTable</code> is the singleton type of which the constant <code>Irrep</code> is the only instance. The <code>Base.convert</code> definition allows to convert real numbers to the corresponding type of sector, and thus to omit the type information of the sector whenever this is clear from the context.</p><p>In the definition of <code>U1Irrep</code>, <code>HalfInt&lt;:Number</code> is a Julia type defined in <a href="https://github.com/sostock/HalfIntegers.jl">HalfIntegers.jl</a>, which is also used for <code>SU2Irrep</code> below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of <code>U‚ÇÅ</code> can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of <code>HalfInt</code>, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Irrep[U‚ÇÅ](0.5)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U‚ÇÅ](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(0.4)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: Int64(0.8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(1) ‚äó Irrep[U‚ÇÅ](1//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U‚ÇÅ](3/2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = first(U1Irrep(1) ‚äó Irrep[U‚ÇÅ](1//2))</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U‚ÇÅ](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Nsymbol(u, conj(u), one(u))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>For <code>ZNIrrep{N}</code>, we use an <code>Int8</code> for compact storage, assuming that this type will not be used with <code>N&gt;64</code> (we need <code>2*(N-1) &lt;= 127</code> in order for <code>a ‚äó b</code> to work correctly). We also define some aliases for the first (and most commonly used <code>‚Ñ§{N}</code> irreps)</p><pre><code class="language-julia hljs">const Z2Irrep = ZNIrrep{2}
const Z3Irrep = ZNIrrep{3}
const Z4Irrep = ZNIrrep{4}</code></pre><p>so that we can do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = Z3Irrep(1)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ](1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ZNIrrep{3}(1) ‚äó Irrep[‚Ñ§‚ÇÉ](1)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[‚Ñ§‚ÇÉ](2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ](2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ](0)</code></pre><p>As a further remark, even in the abelian case where <code>a ‚äó b</code> is equivalent to a single new label <code>c</code>, we return it as an iterable container, in this case a one-element tuple <code>(c,)</code>.</p><p>As mentioned above, we also provide the following definitions</p><pre><code class="language-julia hljs">Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)
Base.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)
Base.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)
Base.isless(c1::U1Irrep, c2::U1Irrep) where {N} =
    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) &lt; c1.charge == -c2.charge</code></pre><p>Since sectors or objects made out of tuples of sectors (see the section on <a href="#ss_fusiontrees">Fusion Trees</a> below) are often used as keys in look-up tables (i.e. subtypes of <code>AbstractDictionary</code> in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value. Note that hashes will only be used to compare sectors of the same type. The <code>isless</code> function provides a canonical order for sectors of a given type <code>G&lt;:Sector</code>, which is useful to uniquely and unambiguously specify a representation space <span>$V = ‚®Å_a ‚ÑÇ^{n_a} ‚äó R_{a}$</span>, as described in the section on <a href="#ss_rep">Graded spaces</a> below.</p><p>The first example of a non-abelian representation category is that of <span>$\mathsf{SU}_2$</span>, the implementation of which is summarized by</p><pre><code class="language-julia hljs">struct SU2Irrep &lt;: AbstractIrrep{SU{2}}
    j::HalfInt
end

Base.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))
Base.conj(s::SU2Irrep) = s
‚äó(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))
dim(s::SU2Irrep) = twice(s.j)+1
FusionStyle(::Type{SU2Irrep}) = SimpleFusion()
Base.isreal(::Type{SU2Irrep}) = true
Nsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.Œ¥(sa.j, sb.j, sc.j)
Fsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,
        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =
    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))
function Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)
    Nsymbol(sa, sb, sc) || return 0.
    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0
end

Base.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{SU2Irrep}, i = 0) = (SU2Irrep(half(i)), i+1)
# unused and not really necessary:
Base.getindex(::SectorValues{SU2Irrep}, i::Int) =
    1 &lt;= i ? SU2Irrep(half(i-1)) : throw(BoundsError(values(SU2Irrep), i))
findindex(::SectorValues{SU2Irrep}, s::SU2Irrep) = twice(s.j)+1</code></pre><p>and some methods for pretty printing and converting from real numbers to irrep labels. As one can notice, the topological data (i.e. <code>Nsymbol</code> and <code>Fsymbol</code>) are provided by the package <a href="https://github.com/Jutho/WignerSymbols.jl">WignerSymbols.jl</a>. The iterable <code>a ‚äó b</code> is a custom type, that the user does not need to care about. Some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(s)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(s)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(s ‚äó s)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{SU2Irrep}:
 0
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for s2 in s ‚äó s
           @show s2
           @show Nsymbol(s, s, s2)
           @show Rsymbol(s, s, s2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">s2 = Irrep[SU‚ÇÇ](0)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU‚ÇÇ](1)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0
s2 = Irrep[SU‚ÇÇ](2)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU‚ÇÇ](3)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0</code></pre><p>A final non-abelian representation theory is that of the semidirect product <span>$\mathsf{U}‚ÇÅ ‚ãâ ‚Ñ§_2$</span>, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of <span>$‚Ñ§_2$</span> acts as charge conjugation <span>$C$</span>. It has the effect of interchaning <span>$\mathsf{U}_1$</span> irreps <span>$n$</span> and <span>$-n$</span>, and turns them together in a joint 2-dimensional index, except for the case <span>$n=0$</span>. Irreps are therefore labeled by integers <span>$n ‚âß 0$</span>, however for <span>$n=0$</span> the <span>$‚Ñ§‚ÇÇ$</span> symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with <span>$\mathsf{U})_1$</span> charge <span>$0$</span>. Given <span>$\mathsf{U}_1 ‚âÇ \mathsf{SO}_2$</span>, this group is also simply known as <span>$\mathsf{O}_2$</span>, and the two representations with <span>$n = 0$</span> are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as <code>Irrep[CU‚ÇÅ]</code> or <code>CU1Irrep</code> in full.</p><pre><code class="language-julia hljs">struct CU1Irrep &lt;: AbstractIrrep{CU‚ÇÅ}
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),
    # else s = 2 (two-dimensional representation)
    # Let constructor take the actual half integer value j
    function CU1Irrep(j::Real, s::Int = ifelse(j&gt;zero(j), 2, 0))
        if ((j &gt; zero(j) &amp;&amp; s == 2) || (j == zero(j) &amp;&amp; (s == 0 || s == 1)))
            new(j, s)
        else
            error(&quot;Not a valid CU‚ÇÅ irrep&quot;)
        end
    end
end

Base.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)
Base.conj(c::CU1Irrep) = c
dim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)

FusionStyle(::Type{CU1Irrep}) = SimpleFusion()
...</code></pre><p>The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of <code>Fsymbol</code>.</p><p>So far, no sectors have been implemented with <code>FusionStyle(G) == GenericFusion()</code>, though an example would be the representation theory of <span>$\mathsf{SU}_N$</span>, i.e. represented by the group <code>SU{N}</code>, for <code>N&gt;2</code>. Such sectors are not yet fully supported; certain operations remain to be implemented. Furthermore, the topological data of the representation theory of such groups is not readily available and needs to be computed.</p><h3 id="sss_productsectors"><a class="docs-heading-anchor" href="#sss_productsectors">Combining different sectors</a><a id="sss_productsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_productsectors" title="Permalink"></a></h3><p>It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator <code>‚ä†</code>, which can be entered as <code>\boxtimes</code>+TAB. First some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ‚ä† Irrep[U‚ÇÅ](1)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó U‚ÇÅ](1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{Z3Irrep, U1Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(a)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó U‚ÇÅ](2, -1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(a)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó U‚ÇÅ](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(a)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(a ‚äó a)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{ProductSector{Tuple{Z3Irrep, U1Irrep}}}:
 (2, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(a)</code><code class="nohighlight hljs ansi" style="display:block;">UniqueFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = Irrep[‚Ñ§‚ÇÉ](1) ‚ä† Irrep[SU‚ÇÇ](3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó SU‚ÇÇ](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{Z3Irrep, SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(b)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó SU‚ÇÇ](2, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(b)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó SU‚ÇÇ](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(b)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(b ‚äó b)</code><code class="nohighlight hljs ansi" style="display:block;">1√ó4 Matrix{ProductSector{Tuple{Z3Irrep, SU2Irrep}}}:
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(b)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Irrep[SU‚ÇÇ](1) ‚ä† SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ √ó SU‚ÇÇ](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(c)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSector{Tuple{SU2Irrep, SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(c)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ √ó SU‚ÇÇ](1, 3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(c)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ √ó SU‚ÇÇ](0, 0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(c)</code><code class="nohighlight hljs ansi" style="display:block;">12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(c ‚äó c)</code><code class="nohighlight hljs ansi" style="display:block;">3√ó4 Matrix{ProductSector{Tuple{SU2Irrep, SU2Irrep}}}:
 (0, 0)  (0, 1)  (0, 2)  (0, 3)
 (1, 0)  (1, 1)  (1, 2)  (1, 3)
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(c)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code></pre><p>We refer to the source file of <a href="../../lib/sectors/#TensorKit.ProductSector"><code>ProductSector</code></a> for implementation details.</p><p>The symbol <code>‚ä†</code> refers to the <a href="https://ncatlab.org/nlab/show/Deligne+tensor+product+of+abelian+categories">Deligne tensor product</a> within the literature on category theory. Indeed, the category of representation of a product group <code>G‚ÇÅ √ó G‚ÇÇ</code> corresponds the Deligne tensor product of the categories of representations of the two groups separately. But this definition also extends to ùïú-linear categories which are not the representation category of a group. Note that <code>‚ä†</code> also works in the type domain, i.e. <code>Irrep[‚Ñ§‚ÇÉ] ‚ä† Irrep[CU‚ÇÅ]</code> can be used to create <code>ProductSector{Tuple{Irrep[‚Ñ§‚ÇÉ], Irrep[CU‚ÇÅ]}}</code>. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. Furthermore, for representations of groups, we also enabled the notation <code>Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ]</code>, with <code>√ó</code> obtained using <code>\times+TAB</code>. However, this is merely for convience; as <code>Irrep[‚Ñ§‚ÇÉ] ‚ä† Irrep[CU‚ÇÅ]</code> is not a subtype of the abstract type <code>AbstractIrrep{‚Ñ§‚ÇÉ √ó CU‚ÇÅ}</code>. That behavior cannot be obtained with the Julia&#39;s type system. Some more examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ‚ä† Irrep[CU‚ÇÅ](1.5)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ](1, (3/2, 2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[‚Ñ§‚ÇÉ] ‚ä† CU1Irrep</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ]</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep{‚Ñ§‚ÇÉ √ó CU‚ÇÅ}</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: TypeError: in Type{...} expression, expected UnionAll, got a value of type TensorKit.IrrepTable</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a == Irrep[‚Ñ§‚ÇÉ √ó CU‚ÇÅ](1, 1.5)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="sss_newsectors"><a class="docs-heading-anchor" href="#sss_newsectors">Defining a new type of sector</a><a id="sss_newsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_newsectors" title="Permalink"></a></h3><p>By now, it should be clear how to implement a new <code>Sector</code> subtype. Ideally, a new <code>I&lt;:Sector</code> type is a <code>struct I ... end</code> (immutable) that has <code>isbitstype(I) == true</code> (see Julia&#39;s manual), and implements the following minimal set of methods</p><pre><code class="language-julia hljs">Base.one(::Type{I}) = I(...)
Base.conj(a::I) = I(...)
Base.isreal(::Type{I}) = ... # true or false
TensorKit.FusionStyle(::Type{I}) = ... # UniqueFusion(), SimpleFusion(), GenericFusion()
TensorKit.BraidingStyle(::Type{I}) = ... # Bosonic(), Fermionic(), Anyonic()
TensorKit.Nsymbol(a::I, b::I, c::I) = ...
    # Bool or Integer if FusionStyle(I) == GenericFusion()
Base.:‚äó(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs
TensorKit.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)
TensorKit.Rsymbol(a::I, b::I, c::I)
Base.hash(a::I, h::UInt)
Base.isless(a::I, b::I)
Base.iterate(::TensorKit.SectorValues{I}[, state]) = ...
Base.IteratorSize(::Type{TensorKit.SectorValues{I}}) = ... # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::TensorKit.SectorValues{I}) = ...
Base.getindex(::TensorKit.SectorValues{I}, i::Int) = ...
TensorKit.findindex(::TensorKit.SectorValues{I}, c::I) = ...</code></pre><p>Additionally, suitable definitions can be given for</p><pre><code class="language-julia hljs">TensorKit.dim(a::I) = ...
TensorKit.frobeniusschur(a::I) = ...
TensorKit.Bsymbol(a::I, b::I, c::I) = ...</code></pre><p>Out of these, we have not yet encountered the Frobenius-Schur indicator and the B-symbol. They were both defined in the section on <a href="../categories/#ss_topologicalfusion">topological data of fusion categories</a> and are fully determined by the F-symbol, just like the quantum dimensions. Hence, there is a default implementation for each of these three functions that just relies on <code>Fsymbol</code>, and alternative definitions need to be given only if a more efficient version is available.</p><p>If <code>FusionStyle(I) == GenericFusion()</code>, then the multiple outputs <code>c</code> in the tensor product of <code>a</code> and <code>b</code> will be labeled as <code>i=1</code>, <code>2</code>, ‚Ä¶, <code>Nsymbol(a,b,c)</code>. Optionally, a different label can be provided by defining</p><pre><code class="language-julia hljs">TensorKit.vertex_ind2label(i::Int, a::I, b::I, c::I) = ...
# some label, e.g. a `Char` or `Symbol`</code></pre><p>The following function will then automatically determine the corresponding label type (which should not vary, i.e. <code>vertex_ind2label</code> should be type stable)</p><pre><code class="language-julia hljs">vertex_labeltype(I::Type{&lt;:Sector}) =
    typeof(vertex_ind2label(1, one(I), one(I), one(I)))</code></pre><p>The following type, which already appeared in the implementation of <code>SU2Irrep</code> above, can be useful for providing the return type of <code>a ‚äó b</code></p><pre><code class="language-julia hljs">struct SectorSet{I&lt;:Sector,F,S}
    f::F
    set::S
end
...
function Base.iterate(s::SectorSet{I}, args...) where {I&lt;:Sector}
    next = iterate(s.set, args...)
    next === nothing &amp;&amp; return nothing
    val, state = next
    return convert(I, s.f(val)), state
end</code></pre><p>That is, <code>SectorSet(f, set)</code> behaves as an iterator that applies <code>x-&gt;convert(I, f(x))</code> on the elements of <code>set</code>; if <code>f</code> is not provided it is just taken as the function <code>identity</code>.</p><h3 id="sss_generalsectors"><a class="docs-heading-anchor" href="#sss_generalsectors">Generalizations</a><a id="sss_generalsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_generalsectors" title="Permalink"></a></h3><p>As mentioned before, the framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) <a href="https://en.wikipedia.org/wiki/Fusion_category">fusion category</a>, which was reviewed at the end of the introduction to <a href="../categories/#s_categories">category theory</a>. For such categories, the objects are not necessarily vector spaces and the fusion and splitting tensors <span>$X^{ab}_{c,Œº}$</span> do not necessarily exist as actual tensors. However, the morphism spaces <span>$c ‚Üí a ‚äó b$</span> still behave as vector spaces, and the <span>$X^{ab}_{c,Œº}$</span> act as generic basis for that space. As TensorKit.jl does not rely on the <span>$X^{ab}_{c,Œº}$</span> themselves (even when they do exist) it can also deal with such general fusion categories. Note, though, that when <span>$X^{ab}_{c,Œº}$</span> does exist, it is available as <code>fusiontensor(a,b,c[,Œº])</code> (even though it is actually the splitting tensor) and can be useful for checking purposes, as illustrated below.</p><h2 id="ss_rep"><a class="docs-heading-anchor" href="#ss_rep">Graded spaces</a><a id="ss_rep-1"></a><a class="docs-heading-anchor-permalink" href="#ss_rep" title="Permalink"></a></h2><p>We have introduced <code>Sector</code> subtypes as a way to label the irreps or sectors in the decomposition <span>$V = ‚®Å_a ‚ÑÇ^{n_a} ‚äó R_{a}$</span>. To actually represent such spaces, we now also introduce a corresponding type <code>GradedSpace</code>, which is a subtype of <code>ElementarySpace{‚ÑÇ}</code>, i.e.</p><pre><code class="language-julia hljs">struct GradedSpace{I&lt;:Sector, D} &lt;: ElementarySpace{‚ÑÇ}
    dims::D
    dual::Bool
end</code></pre><p>Here, <code>D</code> is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions <span>$n_a$</span> of the different sectors. For conviency, <code>Vect[I]</code> will return the fully concrete type with <code>D</code> specified.</p><p>Note that, conventionally, a graded vector space is a space that has a natural direct sum decomposition over some set of labels, i.e. <span>$V = ‚®Å_{a ‚àà I} V_a$</span> where the label set <span>$I$</span> has the structure of a semigroup <span>$a ‚äó b = c ‚àà I$</span>. Here, we generalize this notation by using for <span>$I$</span> the fusion ring of a fusion category, <span>$a ‚äó b = ‚®Å_{c ‚àà I} ‚®Å_{Œº = 1}^{N_{a,b}^c} c$</span>. However, this is mostly to lower the barrier, as really the instances of <code>GradedSpace</code> represent just general objects in a fusion category (or strictly speaking, a pre-fusion category, as we allow for an infinite number of simple objects, e.g. the irreps of a continuous group).</p><h3 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h3><p>As mentioned, the way in which the degeneracy dimensions <span>$n_a$</span> are stored depends on the specific sector type <code>I</code>, more specifically on the <code>IteratorSize</code> of <code>values(I)</code>. If <code>IteratorSize(values(I)) isa Union{IsInfinite, SizeUnknown}</code>, the different sectors <span>$a$</span> and their corresponding degeneracy <span>$n_a$</span> are stored as key value pairs in an <code>Associative</code> array, i.e. a dictionary <code>dims::SectorDict</code>. As the total number of sectors in <code>values(I)</code> can be infinite, only sectors <span>$a$</span> for which <span>$n_a$</span> are stored. Here, <code>SectorDict</code> is a constant type alias for a specific dictionary implementation, which currently resorts to <code>SortedVectorDict</code> implemented in TensorKit.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (<code>Vector</code> instances), which are ordered based on the property <code>isless(a::I, b::I)</code>. This ensures that the space <span>$V = ‚®Å_a ‚ÑÇ^{n_a} ‚äó R_{a}$</span> has some unique canonical order in the direct sum decomposition, such that two different but equal instances created independently always match.</p><p>If <code>IteratorSize(values(I)) isa Union{HasLength, HasShape}</code>, the degeneracy dimensions <code>n_a</code> are stored for all sectors <code>a ‚àà values(I)</code> (also if <code>n_a == 0</code>) in a tuple, more specifically a <code>NTuple{N, Int}</code> with <code>N = length(values(I))</code>. The methods <code>getindex(values(I), i)</code> and <code>findindex(values(I), a)</code> are used to map between a sector <code>a ‚àà values(I)</code> and a corresponding index <code>i ‚àà 1:N</code>. As <code>N</code> is a compile time constant, these types can be created in a type stable manner.</p><h3 id="Constructing-instances"><a class="docs-heading-anchor" href="#Constructing-instances">Constructing instances</a><a id="Constructing-instances-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-instances" title="Permalink"></a></h3><p>As mentioned, the convenience mehtod <code>Vect[I]</code> will return the concrete type <code>GradedSpace{I,D}</code> with the matching value of <code>D</code>, so that should never be a user&#39;s concern. In fact, for consistency, <code>Vect[Trivial]</code> will just return <code>ComplexSpace</code>, which is not even a specific type of <code>GradedSpace</code>. There is also the Unicode alias <code>‚ÑÇ[I]</code>, and for the specific case of group irreps as sectors, one can use <code>Rep[G]</code> with <code>G</code> the group, as inspired by the categorical name <span>$\mathbf{Rep}_{\mathsf{G}}$</span>. Here, <code>Rep</code> is a <code>UnionAll</code> type that for <code>GradedSpace{I}</code> where <code>I</code> is either the <code>Irrep</code> of some group, or a <code>ProductSector</code> of <code>Irrep</code>s. Some illustrations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ[]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ[Trivial]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Trivial]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[U1Irrep]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ[Irrep[U‚ÇÅ]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[U‚ÇÅ]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep, TensorKit.SortedVectorDict{U1Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, TensorKit.SortedVectorDict{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, TensorKit.SortedVectorDict{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}}</code></pre><p>Note that we also have the specific alias <code>U‚ÇÅSpace</code>. In fact, for all the common groups we have a number of alias, both in ASCII and using Unicode:</p><pre><code class="language-julia hljs"># ASCII type aliases
const ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}
const Z2Space = ZNSpace{2}
const Z3Space = ZNSpace{3}
const Z4Space = ZNSpace{4}
const U1Space = Rep[U‚ÇÅ]
const CU1Space = Rep[CU‚ÇÅ]
const SU2Space = Rep[SU‚ÇÇ]

# Unicode alternatives
const ‚Ñ§‚ÇÇSpace = Z2Space
const ‚Ñ§‚ÇÉSpace = Z3Space
const ‚Ñ§‚ÇÑSpace = Z4Space
const U‚ÇÅSpace = U1Space
const CU‚ÇÅSpace = CU1Space
const SU‚ÇÇSpace = SU2Space</code></pre><p>To create specific instances of those types, one can e.g. just use <code>V = GradedSpace(a=&gt;n_a, b=&gt;n_b, c=&gt;n_c)</code> or <code>V = GradedSpace(iterator)</code> where <code>iterator</code> is any iterator (e.g. a dictionary or a generator) that yields <code>Pair{I,Int}</code> instances. With those constructions, <code>I</code> is inferred from the type of sectors. However, it is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type; compare</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[U‚ÇÅ]](0=&gt;3, 1=&gt;2, -1=&gt;1) ==
           ‚ÑÇ[U1Irrep(0)=&gt;3, U1Irrep(1)=&gt;2, U1Irrep(-1)=&gt;1] == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching getindex(::TensorKit.ComplexNumbers, ::Pair{U1Irrep, Int64}, ::Pair{U1Irrep, Int64}, ::Pair{U1Irrep, Int64})

Closest candidates are:
  getindex(::TensorKit.ComplexNumbers)
   @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/spaces/complexspace.jl:36
  getindex(::TensorKit.ComplexNumbers, !Matched::Type{&lt;:Sector})
   @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/spaces/gradedspace.jl:224</code></pre><p>The fact that <code>Rep[G]</code> also works with product groups makes it easy to specify e.g.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[‚Ñ§‚ÇÇ √ó SU‚ÇÇ]((0,0) =&gt; 3, (1,1/2) =&gt; 2, (0,1) =&gt; 1) == ‚ÑÇ[(Z2Irrep(0) ‚ä† SU2Irrep(0)) =&gt; 3, (Z2Irrep(1) ‚ä† SU2Irrep(1/2)) =&gt; 2, (Z2Irrep(0) ‚ä† SU2Irrep(1)) =&gt; 1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching getindex(::TensorKit.ComplexNumbers, ::Pair{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}, ::Pair{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64}, ::Pair{ProductSector{Tuple{Z2Irrep, SU2Irrep}}, Int64})

Closest candidates are:
  getindex(::TensorKit.ComplexNumbers)
   @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/spaces/complexspace.jl:36
  getindex(::TensorKit.ComplexNumbers, !Matched::Type{&lt;:Sector})
   @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/spaces/gradedspace.jl:224</code></pre><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><p>There are a number of methods to work with instances <code>V</code> of <code>GradedSpace</code>. The function <a href="../../lib/spaces/#TensorKit.sectortype"><code>sectortype</code></a> returns the type of the sector labels. It also works on other vector spaces, in which case it returns <a href="../../lib/sectors/#TensorKit.Trivial"><code>Trivial</code></a>. The function <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors</code></a> returns an iterator over the different sectors <code>a</code> with non-zero <code>n_a</code>, for other <code>ElementarySpace</code> types it returns <code>(Trivial,)</code>. The degeneracy dimensions <code>n_a</code> can be extracted as <code>dim(V, a)</code>, it properly returns <code>0</code> if sector <code>a</code> is not present in the decomposition of <code>V</code>. With <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(V, a)</code></a> one can check if <code>V</code> contains a sector <code>a</code> with <code>dim(V,a)&gt;0</code>. Finally, <code>dim(V)</code> returns the total dimension of the space <code>V</code>, i.e. <span>$‚àë_a n_a d_a$</span> or thus <code>dim(V) = sum(dim(V,a) * dim(a) for a in sectors(V))</code>. Note that a representation space <code>V</code> has certain sectors <code>a</code> with dimensions <code>n_a</code>, then its dual <code>V&#39;</code> will report to have sectors <code>dual(a)</code>, and <code>dim(V&#39;, dual(a)) == n_a</code>. There is a subtelty regarding the difference between the dual of a representation space <span>$R_a^*$</span>, on which the conjugate representation acts, and the representation space of the irrep <code>dual(a)==conj(a)</code> that is isomorphic to the conjugate representation, i.e. <span>$R_{\overline{a}} ‚âÇ R_a^*$</span> but they are not equal. We return to this in the section on <a href="#ss_fusiontrees">fusion trees</a>. This is true also in more general fusion categories beyond the representation categories of groups.</p><p>Other methods for <code>ElementarySpace</code>, such as <a href="../../lib/spaces/#TensorKit.dual"><code>dual</code></a>, <a href="../../lib/spaces/#TensorKit.fuse"><code>fuse</code></a> and <a href="../../lib/spaces/#TensorKit.flip"><code>flip</code></a> also work. In fact, <code>GradedSpace</code> is the reason <code>flip</code> exists, cause in this case it is different then <code>dual</code>. The existence of flip originates from the non-trivial isomorphism between <span>$R_{\overline{a}}$</span> and <span>$R_{a}^*$</span>, i.e. the representation space of the dual <span>$\overline{a}$</span> of sector <span>$a$</span> and the dual of the representation space of sector <span>$a$</span>. In order for <code>flip(V)</code> to be isomorphic to <code>V</code>, it is such that, if <code>V = GradedSpace(a=&gt;n_a,...)</code> then <code>flip(V) = dual(GradedSpace(dual(a)=&gt;n_a,....))</code>.</p><p>Furthermore, for two spaces <code>V1 = GradedSpace(a=&gt;n1_a, ...)</code> and <code>V2 = GradedSpace(a=&gt;n2_a, ...)</code>, we have <code>infimum(V1,V2) = GradedSpace(a=&gt;min(n1_a,n2_a), ....)</code> and similarly for <code>supremum</code>, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of <code>infimum(V1,V2)</code> or <code>supremum(V1,V2)</code> is neither equal to <code>V1</code> or <code>V2</code>.</p><p>For <code>W</code> a <code>ProductSpace{Vect[I], N}</code>, <a href="../../lib/spaces/#TensorKit.sectors"><code>sectors(W)</code></a> returns an iterator that generates all possible combinations of sectors <code>as</code> represented as <code>NTuple{I,N}</code>. The function <a href="../../lib/spaces/#TensorKit.dims"><code>dims(W, as)</code></a> returns the corresponding tuple with degeneracy dimensions, while <a href="../../lib/sectors/#TensorKit.dim-Tuple{Sector}"><code>dim(W, as)</code></a> returns the product of these dimensions. <a href="../../lib/spaces/#TensorKit.hassector"><code>hassector(W, as)</code></a> is equivalent to <code>dim(W, as)&gt;0</code>. Finally, there is the function <a href="../../lib/spaces/#TensorKit.blocksectors"><code>blocksectors(W)</code></a> which returns a list (of type <code>Vector</code>) with all possible &quot;block sectors&quot; or total/coupled sectors that can result from fusing the individual uncoupled sectors in <code>W</code>. Correspondingly, <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim(W, a)</code></a> counts the total degeneracy dimension of the coupled sector <code>a</code> in <code>W</code>. The machinery for computing this is the topic of the next section on <a href="#ss_fusiontrees">Fusion trees</a>, but first, it&#39;s time for some examples.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Let&#39;s start with an example involving <span>$\mathsf{U}_1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1) == U‚ÇÅSpace(-1=&gt;1, 1=&gt;2,0=&gt;3) # order doesn&#39;t matter</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](-1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, U1Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, Irrep[U‚ÇÅ](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U‚ÇÅ](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U‚ÇÅ](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;3, 1=&gt;1, -1=&gt;2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1) ‚âÖ V1</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1) ‚âÖ V1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = U1Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚äï(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;5, 1=&gt;3, -1=&gt;2, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚äó(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1) ‚äó Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3√ó5 Matrix{Tuple{Any, Any}}:
 (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0))   ‚Ä¶  (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](-2))
 (Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](0))      (Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](-2))
 (Irrep[U‚ÇÅ](-1), Irrep[U‚ÇÅ](0))     (Irrep[U‚ÇÅ](-1), Irrep[U‚ÇÅ](-2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U‚ÇÅ](2), Irrep[U‚ÇÅ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;9, 1=&gt;8, -1=&gt;7, 2=&gt;5, -2=&gt;4, 3=&gt;2, -3=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](-1), Irrep[U‚ÇÅ](2), Irrep[U‚ÇÅ](-2), Irrep[U‚ÇÅ](3), Irrep[U‚ÇÅ](-3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, Irrep[U‚ÇÅ](0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre><p>and then with <span>$\mathsf{SU}_2$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ[Irrep[SU‚ÇÇ]](0=&gt;3, 1//2=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;3, 1/2=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == SU2Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1) == SU‚ÇÇSpace(0=&gt;3, 0.5=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU‚ÇÇ](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU‚ÇÇ](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU‚ÇÇ](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU2Space(0=&gt;2, 1//2=&gt;1, 1=&gt;1, 3//2=&gt;1, 2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;3, 1/2=&gt;2, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚äï(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;5, 1/2=&gt;3, 1=&gt;2, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚äó(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;3, 1/2=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3√ó5 Matrix{Tuple{Any, Any}}:
 (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](0))    ‚Ä¶  (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](2))
 (Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](0))     (Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](2))
 (Irrep[SU‚ÇÇ](1), Irrep[SU‚ÇÇ](0))       (Irrep[SU‚ÇÇ](1), Irrep[SU‚ÇÇ](2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(0), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(2), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;9, 1/2=&gt;11, 1=&gt;11, 3/2=&gt;9, 2=&gt;7, 5/2=&gt;3, 3=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU‚ÇÇ](0), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1), Irrep[SU‚ÇÇ](3/2), Irrep[SU‚ÇÇ](2), Irrep[SU‚ÇÇ](5/2), Irrep[SU‚ÇÇ](3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, SU2Irrep(0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre><h2 id="ss_fusiontrees"><a class="docs-heading-anchor" href="#ss_fusiontrees">Fusion trees</a><a id="ss_fusiontrees-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fusiontrees" title="Permalink"></a></h2><p>The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (equivariant) tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors, i.e. they exhibit block sparsity. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section <a href="../../lib/spaces/#TensorKit.blocksectors"><code>blocksectors</code></a> and <a href="../../lib/spaces/#TensorKit.blockdim"><code>blockdim</code></a> defined on the type <a href="../../lib/spaces/#TensorKit.ProductSpace"><code>ProductSpace</code></a>.</p><p>This basis transform consists of a basis of inclusion and projection maps, denoted as <span>$X^{a_1a_2‚Ä¶a_N}_{c,Œ±}: R_c ‚Üí R_{a_1} ‚äó R_{a_2} ‚äó ‚Ä¶ ‚äó R_{a_N}$</span> and their adjoints <span>$(X^{a_1a_2‚Ä¶a_N}_{c,Œ±})^‚Ä†$</span>, such that</p><p><span>$(X^{a_1a_2‚Ä¶a_N}_{c,Œ±})^‚Ä† ‚àò X^{a_1a_2‚Ä¶a_N}_{c‚Ä≤,Œ±‚Ä≤} = Œ¥_{c,c‚Ä≤} Œ¥_{Œ±,Œ±‚Ä≤} \mathrm{id}_c$</span></p><p>and</p><p><span>$‚àë_{c,Œ±} X^{a_1a_2‚Ä¶a_N}_{c,Œ±} ‚àò (X^{a_1a_2‚Ä¶a_N}_{c,Œ±})^‚Ä†  = \mathrm{id}_{a_1 ‚äó a_2 ‚äó ‚Ä¶ ‚äó a_N} = \mathrm{id}_{a_1} ‚äó \mathrm{id}_{a_2} ‚äó ‚Ä¶ ‚äó \mathrm{id}_{a_N}$</span></p><p>Fusion trees provide a particular way to construct such a basis. It is useful to know about the existence of fusion trees and how they are represented, as discussed in the first subsection. The next two subsections discuss possible manipulations that can be performed with fusion trees. These are used under the hood when manipulating the indices of tensors, but a typical user would not need to use these manipulations on fusion trees directly. Hence, these last two sections can safely be skipped.</p><h3 id="Canonical-representation"><a class="docs-heading-anchor" href="#Canonical-representation">Canonical representation</a><a id="Canonical-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Canonical-representation" title="Permalink"></a></h3><p>To couple or fuse the different sectors together into a single block sector, we can sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector, using the splitting tensors <span>$X_{a,b}^{c,Œº} : R_c ‚Üí R_a ‚äó R_b$</span> and their adjoints. This amounts to the canonical choice of our tensor product, and for a given tensor mapping from <span>$(((W_1 ‚äó W_2) ‚äó W_3) ‚äó ‚Ä¶ )‚äó W_{N_2})$</span> to <span>$(((V_1 ‚äó V_2) ‚äó V_3) ‚äó ‚Ä¶ )‚äó V_{N_1})$</span>, the corresponding fusion and splitting trees take the form</p><p><img src="../img/tree-simple.svg" alt="double fusion tree"/></p><p>for the specific case <span>$N_1=4$</span> and <span>$N_2=3$</span>. We can separate this tree into the fusing part <span>$(b_1‚äób_2)‚äób_3 ‚Üí c$</span> and the splitting part <span>$c‚Üí(((a_1‚äóa_2)‚äóa_3)‚äóa_4)$</span>. Given that the fusion tree can be considered to be the adjoint of a corresponding splitting tree <span>$c‚Üí(b_1‚äób_2)‚äób_3$</span>, we now first consider splitting trees in isolation. A splitting tree which goes from one coupled sectors <span>$c$</span> to <span>$N$</span> uncoupled sectors <span>$a_1$</span>, <span>$a_2$</span>, ‚Ä¶, <span>$a_N$</span> needs <span>$N-2$</span> additional internal sector labels <span>$e_1$</span>, ‚Ä¶, <span>$e_{N-2}$</span>, and, if <code>FusionStyle(I) isa GenericFusion</code>, <span>$N-1$</span> additional multiplicity labels <span>$Œº_1$</span>, ‚Ä¶, <span>$Œº_{N-1}$</span>. We henceforth refer to them as vertex labels, as they are associated with the vertices of the splitting tree. In the case of <code>FusionStyle(I) isa UniqueFusion</code>, the internal sectors <span>$e_1$</span>, ‚Ä¶, <span>$e_{N-2}$</span> are completely fixed, for <code>FusionStyle(I) isa MultipleFusion</code> they can also take different values. In our abstract notation of the splitting basis <span>$X^{a_1a_2‚Ä¶a_N}_{c,Œ±}$</span> used above, <span>$Œ±$</span> can be consided a collective label, i.e. <span>$Œ± = (e_1, ‚Ä¶, e_{N-2}; Œº‚ÇÅ, ‚Ä¶ ,Œº_{N-1})$</span>. Indeed, we can check the orthogonality condition <span>$(X^{a_1a_2‚Ä¶a_N}_{c,Œ±})^‚Ä† ‚àò X^{a_1a_2‚Ä¶a_N}_{c‚Ä≤,Œ±‚Ä≤} = Œ¥_{c,c‚Ä≤} Œ¥_{Œ±,Œ±‚Ä≤} \mathrm{id}_c$</span>, which now forces all internal lines <span>$e_k$</span> and vertex labels <span>$Œº_l$</span> to be the same.</p><p>There is one subtle remark that we have so far ignored. Within the specific subtypes of <code>Sector</code>, we do not explicitly distinguish between <span>$R_a^*$</span> (simply denoted as <span>$a`^*$</span> and graphically depicted as an upgoing arrow <span>$a$</span>) and <span>$R_{\bar{a}}$</span> (simply denoted as <span>$\bar{a}$</span> and depicted with a downgoing arrow), i.e. between the dual space of <span>$R_a$</span> on which the conjugated irrep acts, or the irrep <span>$\bar{a}$</span> to which the complex conjugate of irrep <span>$a$</span> is isomorphic. This distinction is however important, when certain uncoupled sectors in the fusion tree actually originate from a dual space. We use the isomorphisms <span>$Z_a:R_a^* ‚Üí R_{\bar{a}}$</span> and its adjoint <span>$Z_a^‚Ä†:R_{\bar{a}}‚ÜíR_a^*$</span>, as introduced in the section on <a href="../categories/#ss_topologicalfusion">topological data of a fusion category</a>, to build fusion and splitting trees that take the distinction between irreps and their conjugates into account. Hence, in the previous example, if e.g. the first and third space in the codomain and the second space in the domain of the tensor were dual spaces, the actual pair of splitting and fusion tree would look as</p><p><img src="../img/tree-extended.svg" alt="extended double fusion tree"/></p><p>The presence of these isomorphisms will be important when we start to bend lines, to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. Note that we can still represent the fusion tree as the adjoint of a corresponding splitting tree, because we also use the adjoint of the <span>$Z$</span> isomorphisms in the splitting part, and the <span>$Z$</span> isomorphism in the fusion part. Furthermore, the presence of the <span>$Z$</span> isomorphisms does not affect the orthonormality.</p><p>We represent splitting trees and their adjoints using a specific immutable type called <code>FusionTree</code> (which actually represents a splitting tree, but fusion tree is a more common term), defined as</p><pre><code class="language-julia hljs">struct FusionTree{I&lt;:Sector,N,M,L,T}
    uncoupled::NTuple{N,I}
    coupled::I
    isdual::NTuple{N,Bool}
    innerlines::NTuple{M,I} # fixed to M = N-2
    vertices::NTuple{L,T} # fixed to L = N-1
end</code></pre><p>Here, the fields are probably self-explanotary. The <code>isdual</code> field indicates whether an isomorphism is present (if the corresponding value is <code>true</code>) or not. Note that the field <code>uncoupled</code> contains the sectors coming out of the splitting trees, before the possible <span>$Z$</span> isomorphism, i.e. the splitting tree in the above example would have <code>sectors = (a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, a‚ÇÑ)</code>. The <code>FusionTree</code> type has a number of basic properties and capabilities, such as checking for equality with <code>==</code> and support for <code>hash(f::FusionTree, h::UInt)</code>, as splitting and fusion trees are used as keys in look-up tables (i.e. <code>AbstractDictionary</code> instances) to look up certain parts of the data of a tensor. The type of <code>L</code> of the vertex labels can be <code>Nothing</code> when they are not needed (i.e. if <code>FusionStyle(I) isa MultiplicityFreeFusion</code>).</p><p><code>FusionTree</code> instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. The most natural way to create them is by using the <code>fusiontrees(uncoupled::NTuple{N,I}, coupled::I = one(I))</code> method, which returns an iterator over all possible fusion trees from a set of <code>N</code> uncoupled sectors to a given coupled sector, which by default is assumed to be the trivial sector of that group or fusion category (i.e. the identity object in categorical nomenclature). The return type of <code>fusiontrees</code> is a custom type <code>FusionTreeIterator</code> which conforms to the complete interface of an iterator, and has a custom <code>length</code> function that computes the number of possible fusion trees without iterating over all of them explicitly. This is best illustrated with some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU‚ÇÇ](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s,s,s,s)))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{FusionTree{SU2Irrep, 4, 2, 3, Nothing}}:
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (0, 1/2))
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (1, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s,s,s,s,s), s, (true, false, false, true, false)))</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{FusionTree{SU2Irrep, 5, 3, 4, Nothing}}:
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 0))
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 1))
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 0))
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 1))
 FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 3/2, 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees(ntuple(n-&gt;s, 16))</code><code class="nohighlight hljs ansi" style="display:block;">TensorKit.FusionTreeIterator{SU2Irrep, 16}((Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2)), Irrep[SU‚ÇÇ](0), (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(n-&gt;1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed sum(n-&gt;1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">0.030460919</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">7.1704e-5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = s ‚ä† s</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ √ó SU‚ÇÇ](1/2, 1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s2,s2,s2,s2)))</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{FusionTree{ProductSector{Tuple{SU2Irrep, SU2Irrep}}, 4, 2, 3, Nothing}}:
 FusionTree{Irrep[SU‚ÇÇ √ó SU‚ÇÇ]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU‚ÇÇ √ó SU‚ÇÇ]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU‚ÇÇ √ó SU‚ÇÇ]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 1), (1/2, 1/2)))
 FusionTree{Irrep[SU‚ÇÇ √ó SU‚ÇÇ]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 1), (1/2, 1/2)))</code></pre><p>Note that <code>FusionTree</code> instances are shown (printed) in a way that is valid code to reproduce them, a property which also holds for both instances of <code>Sector</code> and instances of <code>VectorSpace</code>. All of those should be displayed in a way that can be copy pasted as valid code. Furthermore, we use contact to determine how to print e.g. a sector. In isolation, <code>s2</code> is printed as <code>(Irrep[SU‚ÇÇ](1/2) ‚ä† Irrep[SU‚ÇÇ](1/2))</code>, however, within the fusion tree, it is simply printed as <code>(1/2, 1/2)</code>, because it will be converted back into a <code>ProductSector</code>, namely <code>Irrep[SU‚ÇÇ] ‚ä† Irrep[SU‚ÇÇ]</code> by the constructor of <code>FusionTree{Irrep[SU‚ÇÇ] ‚ä† Irrep[SU‚ÇÇ]}</code>.</p><h3 id="Manipulations-on-a-fusion-tree"><a class="docs-heading-anchor" href="#Manipulations-on-a-fusion-tree">Manipulations on a fusion tree</a><a id="Manipulations-on-a-fusion-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-fusion-tree" title="Permalink"></a></h3><p>We now discuss elementary manipulations that we want to perform on or between fusion trees (where we actually mean splitting trees), which will form the building block for more general manipulations on a pair of a fusion and splitting tree discussed in the next subsection, and then for casting a general index manipulation of a tensor map as a linear operation in the basis of canonically ordered splitting and fusion trees. In this section, we will ignore the <span>$Z$</span> isomorphisms, as they are just trivially reshuffled under the different operations that we describe. These manipulations are used as low-level methods by the <code>TensorMap</code> methods discussed on the next page. As such, they are not exported by TensorKit.jl, nor do they overload similarly named methods from Julia Base (see <code>split</code> and <code>merge</code> below).</p><p>The first operation we discuss is an elementary braid of two neighbouring sectors (indices), i.e. a so-called Artin braid or Artin generator of the braid group. Because these two sectors do not appear on the same fusion vertex, some recoupling is necessary. The following represents two different ways to compute the result of such a braid as a linear combination of new fusion trees in canonical order:</p><p><img src="../img/tree-artinbraid.svg" alt="artin braid"/></p><p>While the upper path is the most intuitive, it requires two recouplings or F-moves (one forward and one reverse). On the other hand, the lower path requires only one (reverse) F- move, and two R-moves. The latter are less expensive to compute, and so the lower path is computationally more efficient. However, the end result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any new subtype of <code>Sector</code>, and it is up to the user to verify that they are when implementing new custom <code>Sector</code> types. This result is implemented in the function <a href="../../lib/sectors/#TensorKit.artin_braid"><code>artin_braid(f::FusionTree, i; inv = false)</code></a> where <code>i</code> denotes the position of the first sector (i.e. labeled <code>b</code> in the above graph) which is then braided with the sector at position <code>i+1</code> in the fusion tree <code>f</code>. The keyword argument <code>inv</code> allows to select the inverse braiding operation, which amounts to replacing the R-matrix with its inverse (or thus, adjoint) in the above steps. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as value. In the case of <code>FusionStyle(I) isa UniqueFusion</code>, their is only one resulting fusion tree, with corresponding coefficient a complex phase (which is one for the bosonic representation theory of an Abelian group), and the result is a special <code>SingletonDict&lt;:AbstractDict</code>, a <code>struct</code> type defined in TensorKit.jl to hold a single key value pair.</p><p>With the elementary <code>artin_braid</code>, we can then compute a more general braid. For this, we provide an interface</p><p><a href="man/@ref"><code>braid(f::FusionTree{I,N}, levels::NTuple{N,Int}, permutation::NTuple{N,Int})</code></a></p><p>where the braid is specified as a permutation, such that the new sector at position <code>i</code> was originally at position <code>permutation[i]</code>, and where every uncoupled sector is also assigned a level or depth. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor. This interface does not allow to specify the most general braid, and in particular will never wind one line around another, but can be used as a more general building block for arbitrary braids than the elementary Artin generators. A graphical example makes this probably more clear, i.e for <code>levels=(1,2,3,4,5)</code> and <code>permutation=(5,3,1,4,2)</code>, the corresponding braid is given by</p><p><img src="../img/tree-braidinterface.svg" alt="braid interface"/></p><p>that is, the first sector or space goes to position 3, and crosses over all other lines, because it has the lowest level (i.e. think of level as depth in the third dimension), and so forth. We sketch this operation both as a general braid on the left hand side, and as a particular composition of Artin braids on the right hand side.</p><p>When <code>BraidingStyle(I) == SymmetricBraiding()</code>, there is no distinction between applying the braiding or its inverse (i.e. lines crossing over or under each other in the graphical notation) and the whole operation simplifies down to a permutation. We then also support the interface</p><p><a href="man/@ref"><code>permute(f::FusionTree{I,N}, permutation::NTuple{N,Int})</code></a></p><p>Other manipulations which are sometimes needed are</p><ul><li><p><a href="man/@ref TensorKit.insertat">insertat(f1::FusionTree{I,N‚ÇÅ}, i::Int, f2::FusionTree{I,N‚ÇÇ})</a> :   inserts a fusion tree <code>f2</code> at the <code>i</code>th uncoupled sector of fusion tree <code>f1</code> (this   requires that the coupled sector <code>f2</code> matches with the <code>i</code>th uncoupled sector of <code>f1</code>,   and that <code>!f1.isdual[i]</code>, i.e. that there is no <span>$Z$</span>-isomorphism on the <code>i</code>th line of   <code>f1</code>), and recouple this into a linear combination of trees in canonical order, with   <code>N‚ÇÅ+N‚ÇÇ-1</code> uncoupled sectors, i.e. diagrammatically for <code>i=3</code></p><p><img src="../img/tree-insertat.svg" alt="insertat"/></p></li><li><p><a href="man/@ref TensorKit.split">split(f::FusionTree{I,N}, M::Int)</a> :   splits a fusion tree <code>f</code> into two trees <code>f1</code> and <code>f2</code>, such that <code>f1</code> has the first <code>M</code>   uncoupled sectors of <code>f</code>, and <code>f2</code> the remaining <code>N-M</code>. This function is type stable if <code>M</code> is a compile time constant.</p><p><code>split(f, M)</code> is the inverse of <code>insertat</code> in the sence that <code>insertat(f2, 1, f1)</code>   should return a dictionary with a single key-value pair <code>f=&gt;1</code>. Diagrammatically, for   <code>M=4</code>, the function <code>split</code> returns</p><p><img src="../img/tree-split.svg" alt="split"/></p></li><li><p><a href="man/@ref TensorKit.merge">merge(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, c::I, Œº=nothing)</a> :   merges two fusion trees <code>f1</code> and <code>f2</code> by fusing the coupled sectors of <code>f1</code> and <code>f2</code>   into a sector <code>c</code> (with vertex label <code>Œº</code> if <code>FusionStyle(I) == GenericFusion()</code>),   and reexpressing the result as a linear combination of fusion trees with <code>N‚ÇÅ+N‚ÇÇ</code>   uncoupled sectors in canonical order. This is a simple application of <code>insertat</code>.   Diagrammatically, this operation is represented as:</p><p><img src="../img/tree-merge.svg" alt="merge"/></p></li></ul><h3 id="Manipulations-on-a-splitting-fusion-tree-pair"><a class="docs-heading-anchor" href="#Manipulations-on-a-splitting-fusion-tree-pair">Manipulations on a splitting - fusion tree pair</a><a id="Manipulations-on-a-splitting-fusion-tree-pair-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulations-on-a-splitting-fusion-tree-pair" title="Permalink"></a></h3><p>In this subsection we discuss manipulations that act on a splitting and fusion tree pair, which we will always as two separate trees <code>f1, f2</code>, where <code>f1</code> is the splitting tree and <code>f2</code> represents the fusion tree, and they should have <code>f1.coupled == f2.coupled</code>.</p><p>The most important manipulation on such a pair is to move sectors from one to the other. Given the canonical order of these trees, we exclusively use the <em>left duality</em> (see the section on <a href="../categories/#s_categories">categories</a>), for which the evaluation and coevaluation maps establish isomorphisms between</p><p><span>$\mathrm{Hom}((((b_1 ‚äó b_2) ‚äó ‚Ä¶) ‚äó b_{N_2}), (((a_1 ‚äó a_2) ‚äó ‚Ä¶) ‚äó a_{N_1}))$</span></p><p><span>$‚âÇ \mathrm{Hom}((((b_1 ‚äó b_2) ‚äó ...) ‚äó b_{N_2-1}), ((((a_1 ‚äó a_2) ‚äó ...) ‚äó a_{N_1}) ‚äó b_{N_2}^*))$</span></p><p><span>$‚âÇ \mathrm{Hom}(1, (((((((a_1 ‚äó a_2) ‚äó ...) ‚äó a_{N_1}) ‚äó b_{N_2}^*) ‚äó ‚Ä¶) ‚äó b_2^*) ‚äó b_1^*) )$</span></p><p>where the last morphism space is then labeled by the basis of only splitting trees. We can then use the manipulations from the previous section, and then again use the left duality to bring this back to a pair of splitting and fusion tree with <code>N‚ÇÇ‚Ä≤</code> incoming and <code>N‚ÇÅ‚Ä≤</code> incoming sectors (with <code>N‚ÇÅ‚Ä≤ + N‚ÇÇ‚Ä≤ == N‚ÇÅ + N‚ÇÇ</code>).</p><p>We now discuss how to actually bend lines, and thus, move sectors from the incoming part (fusion tree) to the outgoing part (splitting tree). Hereby, we exploit the relations between the (co)evaluation (exact pairing) and the fusion tensors, discussed in <a href="../categories/#ss_topologicalfusion">topological data of a fusion category</a>. The main ingredient that we need is summarized in</p><p><img src="../img/tree-linebending.svg" alt="line bending"/></p><p>We will only need the B-symbol and not the A-symbol. Applying the left evaluation on the second sector of a splitting tensor thus yields a linear combination of fusion tensors (when <code>FusionStyle(I) == GenericFusion()</code>, or just a scalar times the corresponding fusion tensor otherwise), with corresponding <span>$Z$</span> ismorphism. Taking the adjoint of this relation yields the required relation to transform a fusion tensor into a splitting tensor with an added <span>$Z^‚Ä†$</span> isomorphism.</p><p>However, we have to be careful if we bend a line on which a <span>$Z$</span> isomorphism (or its adjoint) is already present. Indeed, it is exactly for this operation that we explicitly need to take the presence of these isomorphisms into account. Indeed, we obtain the relation</p><p><img src="../img/tree-linebending2.svg" alt="dual line bending"/></p><p>Hence, bending an <code>isdual</code> sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and of course leads to a normal sector (which is no longer <code>isdual</code> and does thus not come with a <span>$Z$</span>-isomorphism) on the fusion side. We again use the adjoint of this relation to bend an <code>isdual</code> sector from the fusion tree to the splitting tree.</p><p>The <code>FusionTree</code> interface to duality and line bending is given by</p><p><code>repartition(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, N::Int)</code></p><p>which takes a splitting tree <code>f1</code> with <code>N‚ÇÅ</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N‚ÇÇ</code> incoming sectors, and applies line bending such that the resulting splitting and fusion trees have <code>N</code> outgoing sectors, corresponding to the first <code>N</code> sectors out of the list <span>$(a_1, a_2, ‚Ä¶, a_{N_1}, b_{N_2}^*, ‚Ä¶, b_{1}^*)$</span> and <code>N‚ÇÅ+N‚ÇÇ-N</code> incoming sectors, corresponding to the dual of the last <code>N‚ÇÅ+N‚ÇÇ-N</code> sectors from the previous list, in reverse. This return values are correctly inferred if <code>N</code> is a compile time constant.</p><p>Graphically, for <code>N‚ÇÅ = 4</code>, <code>N‚ÇÇ = 3</code>, <code>N = 2</code> and some particular choice of <code>isdual</code> in both the fusion and splitting tree:</p><p><img src="../img/tree-repartition.svg" alt="repartition"/></p><p>The result is returned as a dictionary with keys <code>(f1‚Ä≤, f2‚Ä≤)</code> and the corresponding <code>coeff</code> as value. Note that the summation is only over the <span>$Œ∫_j$</span> labels, such that, in the case of <code>FusionStyle(I) isa MultiplicityFreeFusion</code>, the linear combination simplifies to a single term with a scalar coefficient.</p><p>With this basic function, we can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear. The interface provided for this is given by</p><p><a href="man/@ref"><code>braid(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, levels1::NTuple{N‚ÇÅ,Int}, levels2::NTuple{N‚ÇÇ,Int}, p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int})</code></a></p><p>where we now have splitting tree <code>f1</code> with <code>N‚ÇÅ</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N‚ÇÇ</code> incoming sectors, <code>levels1</code> and <code>levels2</code> assign a level or depth to the corresponding uncoupled sectors in <code>f1</code> and <code>f2</code>, and we represent the new configuration as a pair <code>p1</code> and <code>p2</code>. Together, <code>(p1..., p2...)</code> represents a permutation of length <code>N‚ÇÅ+N‚ÇÇ = N‚ÇÅ‚Ä≤+N‚ÇÇ‚Ä≤</code>, where <code>p1</code> indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and <code>p2</code> indicates which appear as incoming sectors in the new fusion tree. Hereto, we label the uncoupled sectors of <code>f1</code> from <code>1</code> to <code>N‚ÇÅ</code>, followed by the uncoupled sectors of <code>f2</code> from <code>N‚ÇÅ+1</code> to <code>N‚ÇÅ+N‚ÇÇ</code>. Note that simply repartitioning the splitting and fusion tree such that e.g. all sectors appear in the new splitting tree (i.e. are outgoing), amounts to chosing <code>p1 = (1,..., N‚ÇÅ, N‚ÇÅ+N‚ÇÇ, N‚ÇÅ+N‚ÇÇ-1, ... , N‚ÇÅ+1)</code> and <code>p2=()</code>, because the duality isomorphism reverses the order of the tensor product.</p><p>This routine is implemented by indeed first making all sectors outgoing using the <code>repartition</code> function discussed above, such that only splitting trees remain, then braiding those using the routine from the previous subsection such that the new outgoing sectors appear first, followed by the new incoming sectors (in reverse order), and then again invoking the <code>repartition</code> routine to bring everything in final form. The result is again returned as a dictionary where the keys are <code>(f1‚Ä≤,f2‚Ä≤)</code> and the values the corresponding coefficients.</p><p>As before, there is a simplified interface for the case where <code>BraidingStyle(I) isa SymmetricBraiding</code> and the levels are not needed. This is simply given by</p><p><a href="man/@ref"><code>permute(f1::FusionTree{I,N‚ÇÅ}, f2::FusionTree{I,N‚ÇÇ}, p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int})</code></a></p><p>The <code>braid</code> and <code>permute</code> routines for double fusion trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memoized, i.e. they are stored in some package wide &#39;least-recently used&#39; cache (from <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCache.jl</a>) that can be accessed as <code>TensorKit.braidcache</code>. By default, this cache stores up to <code>10^5</code> different <code>braid</code> or <code>permute</code> resuls, where one result corresponds to one particular combination of <code>(f1, f2, p1, p2, levels1, levels2)</code>. This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to <code>resize!(TensorKit.permutecache)</code> and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type <code>RefValue{Bool}</code>, namely <code>usebraidcache_abelian</code> and <code>usebraidcache_nonabelian</code>. The default values are given by <code>TensorKit.usebraidcache_abelian[] = false</code> and <code>TensorKit.usebraidcache_nonabelian[] = true</code>, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with <code>FusionStyle(f) isa UniqueFusion</code>, but is probably useful for fusion trees with <code>FusionStyle(f) isa MultipleFusion</code>. One can change these values and test the effect on their application.</p><p>The existence of <code>braidcache</code> also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.</p><h3 id="Inspecting-fusion-trees-as-tensors"><a class="docs-heading-anchor" href="#Inspecting-fusion-trees-as-tensors">Inspecting fusion trees as tensors</a><a id="Inspecting-fusion-trees-as-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-fusion-trees-as-tensors" title="Permalink"></a></h3><p>For those cases where the fusion and splitting tensors have an explicit representation as a tensor, i.e. a morphism in the category <code>Vect</code> (this essentially coincides with the case of group representations), this explicit representation can be created, which can be useful for checking purposes. Hereto, it is necessary that the <em>splitting tensor</em> <span>$X^{ab}_{c,Œº}$</span>, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine <code>fusiontensor(a,b,c [,Œº = nothing])</code>, where the last argument is only necessary in the case of <code>FusionStyle(I) == GenericFusion()</code>. We can then convert a <code>FusionTree{I,N}</code> into an <code>Array</code>, which will yield a rank <code>N+1</code> array where the first <code>N</code> dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector. Note that this is mostly useful for the case of <code>FusionStyle(I) isa MultipleFusion</code> groups, as in the case of abelian groups, all irreps are one-dimensional.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU‚ÇÇ](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU‚ÇÇ](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees((s, s, s, s), SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">TensorKit.FusionTreeIterator{SU2Irrep, 4}((Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2), Irrep[SU‚ÇÇ](1/2)), Irrep[SU‚ÇÇ](1), (false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = first(iter)</code><code class="nohighlight hljs ansi" style="display:block;">FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, f)</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2√ó2√ó2√ó3 Array{Float64, 5}:
[:, :, 1, 1, 1] =
  0.0       0.707107
 -0.707107  0.0

[:, :, 2, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 1, 2, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 2, 2, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 3] =
  0.0       0.707107
 -0.707107  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; I ‚âà convert(Array, FusionTree((SU‚ÇÇ(1/2),), SU‚ÇÇ(1/2), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `I` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2 adjoint(::Matrix{Float64}) with eltype Float64:
 0.0  -1.0
 1.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ‚âà frobeniusschur(SU2Irrep(1/2)) * Z</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; I ‚âà convert(Array, FusionTree((Irrep[SU‚ÇÇ](1),), Irrep[SU‚ÇÇ](1), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `I` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((Irrep[SU‚ÇÇ](1),), Irrep[SU‚ÇÇ](1), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">3√ó3 adjoint(::Matrix{Float64}) with eltype Float64:
 0.0   0.0  1.0
 0.0  -1.0  0.0
 1.0   0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ‚âà frobeniusschur(Irrep[SU‚ÇÇ](1)) * Z
       
       #check orthogonality</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for f1 in iter
         for f2 in iter
           dotproduct  = dot(convert(Array, f1), convert(Array, f2))
           println(&quot;&lt; $f1, $f2&gt; = $dotproduct&quot;)
         end
       end</code><code class="nohighlight hljs ansi" style="display:block;">&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 3.000000000000001
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 3.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 3.0</code></pre><p>Note that we take the adjoint when computing <code>Z</code>, because <code>convert(Array, f)</code> assumes <code>f</code> to be splitting tree, which is built using <span>$Z^‚Ä†$</span>. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the <span>$\mathrm{id}_c$</span> when checking the orthogonality by computing <code>dot</code> of the corresponding tensors.</p><h2 id="Fermions"><a class="docs-heading-anchor" href="#Fermions">Fermions</a><a id="Fermions-1"></a><a class="docs-heading-anchor-permalink" href="#Fermions" title="Permalink"></a></h2><p>TODO: Update the documentation for this section.</p><p>Fermionic sectors are represented by the type <a href="../../lib/sectors/#TensorKit.FermionParity"><code>FermionParity</code></a>, which effectively behaves like a ‚Ñ§‚ÇÇ sector, but with two modifications. Firstly, the exchange of two sectors with odd fermion parity should yield a minus sign, which is taken care of by virtue of the R-symbol. This ensures that permuting tensors behave as expected. Secondly, diagrams with self-crossing lines (aka twists) give rise to a minus sign for odd fermion parity. This is in essence equivalent to having supertraces, which is what ensures that <code>@tensor</code> has a result that is invariant under permutation of its input tensors. This does however lead to unwanted minus signs for certain types of diagrams. To avoid this, the <code>@planar</code> macro does not include a supertrace, but requires a manual resolution of all crossings in the diagram.</p><h2 id="Anyons"><a class="docs-heading-anchor" href="#Anyons">Anyons</a><a id="Anyons-1"></a><a class="docs-heading-anchor-permalink" href="#Anyons" title="Permalink"></a></h2><p>There is currently one example of a <code>Sector</code> subtype that has anyonic braiding style, namely that of the Fibonacci fusion category. It has to (isomorphism classes of) simple objects, namely the identity <code>ùüô</code> and a non-trivial object known as <code>œÑ</code>, with fusion rules <code>œÑ ‚äó œÑ = ùüô ‚äï œÑ</code>. Let&#39;s summarize the topological data</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùüô = FibonacciAnyon(:I)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:I)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; œÑ = FibonacciAnyon(:œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:œÑ)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(œÑ ‚äó œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{FibonacciAnyon}:
 :I
 :œÑ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">Anyonic()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(ùüô)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">1.618033988749895</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fùüô = Fsymbol(œÑ,œÑ,œÑ,ùüô,œÑ,œÑ)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FœÑ = [Fsymbol(œÑ,œÑ,œÑ,œÑ,ùüô,ùüô) Fsymbol(œÑ,œÑ,œÑ,œÑ,ùüô,œÑ); Fsymbol(œÑ,œÑ,œÑ,œÑ,œÑ,ùüô) Fsymbol(œÑ,œÑ,œÑ,œÑ,œÑ,œÑ)]</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2 Matrix{Float64}:
 0.618034   0.786151
 0.786151  -0.618034</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FœÑ&#39;*FœÑ</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar(x) = rationalize.((abs(x), angle(x)/(2pi)))</code><code class="nohighlight hljs ansi" style="display:block;">polar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(œÑ,œÑ,ùüô) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, 2//5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(œÑ,œÑ,œÑ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -3//10)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(œÑ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -2//5)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spaces/">¬´ Vector spaces</a><a class="docs-footer-nextpage" href="../tensors/">Tensors and the <code>TensorMap</code> type ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 27 January 2024 09:23">Saturday 27 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
