<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symmetry sectors an fusion trees · TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/intro/">Introduction</a></li><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../../man/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../man/sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../../man/tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Symmetry sectors an fusion trees</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy-1"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#Methods-for-characterizing-Sector-subtypes-1"><span>Methods for characterizing <code>Sector</code> subtypes</span></a></li><li><a class="tocitem" href="#Methods-for-manipulating-fusion-trees-or-pairs-of-fusion-splitting-trees-1"><span>Methods for manipulating fusion trees or pairs of fusion-splitting trees</span></a></li></ul></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Symmetry sectors an fusion trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symmetry sectors an fusion trees</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/lib/sectors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Symmetry-sectors-an-fusion-trees-1"><a class="docs-heading-anchor" href="#Symmetry-sectors-an-fusion-trees-1">Symmetry sectors an fusion trees</a><a class="docs-heading-anchor-permalink" href="#Symmetry-sectors-an-fusion-trees-1" title="Permalink"></a></h1><h2 id="Type-hierarchy-1"><a class="docs-heading-anchor" href="#Type-hierarchy-1">Type hierarchy</a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Sector" href="#TensorKit.Sector"><code>TensorKit.Sector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Sector end</code></pre><p>Abstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group.</p><p>Every new <code>G&lt;:Sector</code> should implement the following methods:</p><ul><li><code>one(::Type{G})</code>: unit element of <code>G</code></li><li><code>conj(a::G)</code>: <span>$a̅$</span>, conjugate or dual label of <span>$a$</span></li><li><code>⊗(a::G, b::G)</code>: iterable with unique fusion outputs of <span>$a ⊗ b$</span>   (i.e. don&#39;t repeat in case of multiplicities)</li><li><code>Nsymbol(a::G, b::G, c::G)</code>: number of times <code>c</code> appears in <code>a ⊗ b</code>, i.e. the   multiplicity</li><li><code>FusionStyle(::Type{G})</code>: <code>Abelian()</code>, <code>SimpleNonAbelian()</code> or   <code>DegenerateNonAbelian()</code></li><li><code>BraidingStyle(::Type{G})</code>: <code>Bosonic()</code>, <code>Fermionic()</code>, <code>Anyonic()</code>, ...</li><li><code>Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G)</code>: F-symbol: scalar (in case of   <code>Abelian</code>/<code>SimpleNonAbelian</code>) or matrix (in case of <code>DegenerateNonAbelian</code>)</li><li><code>Rsymbol(a::G, b::G, c::G)</code>: R-symbol: scalar (in case of   <code>Abelian</code>/<code>SimpleNonAbelian</code>) or matrix (in case of <code>DegenerateNonAbelian</code>)</li></ul><p>and optionally</p><ul><li><code>dim(a::G)</code>: quantum dimension of sector <code>a</code></li><li><code>frobeniusschur(a::G)</code>: Frobenius-Schur indicator of <code>a</code></li><li><code>Bsymbol(a::G, b::G, c::G)</code>: B-symbol: scalar (in case of   <code>Abelian</code>/<code>SimpleNonAbelian</code>) or matrix (in case of <code>DegenerateNonAbelian</code>)</li><li><code>twist(a::G)</code> -&gt; twist of sector <code>a</code></li></ul><p>and optionally, if <code>FusionStyle(G) isa DegenerateNonAbelian</code></p><ul><li><code>vertex_ind2label(i::Int, a::G, b::G, c::G)</code> -&gt; a custom label for the <code>i</code>th copy of   <code>c</code> appearing in <code>a ⊗ b</code></li></ul><p>Furthermore, <code>iterate</code> and <code>Base.IteratorSize</code> should be made to work for the singleton type <a href="#TensorKit.SectorValues"><code>SectorValues{G}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.SectorValues" href="#TensorKit.SectorValues"><code>TensorKit.SectorValues</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SectorValues{G&lt;:Sector}</code></pre><p>Singleton type to represent an iterator over the possible values of type <code>G</code>, whose instance is obtained as <code>values(G)</code>. For a new <code>G::Sector</code>, the following should be defined</p><ul><li><code>Base.iterate(::SectorValues{G}[, state])</code>: iterate over the values</li><li><code>Base.IteratorSize(::Type{SectorValues{G}})</code>: <code>HasLenght()</code>, <code>SizeUnkown()</code>   or <code>IsInfinite()</code> depending on whether the number of values of type <code>G</code> is finite (and sufficiently small) or infinite; for a large number of values, <code>SizeUnknown()</code> is recommend because this will trigger the use of <code>GenericRepresentationSpace</code>.</li></ul><p>If <code>IteratorSize(G) == HasLength()</code>, also the following must be implemented:</p><ul><li><code>Base.length(::SectorValues{G})</code>: the number of different values</li><li><code>Base.getindex(::SectorValues{G}, i::Int)</code>: a mapping between an index <code>i</code> and an   instance of <code>G</code></li><li><code>findindex(::SectorValues{G}, c::G)</code>: reverse mapping between a value <code>c::G</code> and an   index <code>i::Integer ∈ 1:length(values(G))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.FusionStyle" href="#TensorKit.FusionStyle"><code>TensorKit.FusionStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FusionStyle(a::Sector) -&gt; ::FusionStyle
FusionStyle(G::Type{&lt;:Sector}) -&gt; ::FusionStyle</code></pre><p>Return the type of fusion behavior of sectors of type G, which can be either</p><ul><li><code>Abelian()</code>: single fusion output when fusing two sectors;</li><li><code>SimpleNonAbelian()</code>: multiple outputs, but every output occurs at most one,   also known as multiplicity free (e.g. irreps of <span>$SU(2)$</span>);</li><li><code>DegenerateNonAbelian()</code>: multiple outputs that can occur more than once (e.g. irreps   of <span>$SU(3)$</span>).</li></ul><p>There is an abstract supertype <code>NonAbelian</code> of which both <code>SimpleNonAbelian</code> and <code>DegenerateNonAbelian</code> are subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L128-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.BraidingStyle" href="#TensorKit.BraidingStyle"><code>TensorKit.BraidingStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BraidingStyle(::Sector) -&gt; ::BraidingStyle
BraidingStyle(G::Type{&lt;:Sector}) -&gt; ::BraidingStyle</code></pre><p>Return the type of braiding and twist behavior of sectors of type <code>G</code>, which can be either</p><ul><li><code>Bosonic()</code>: symmetric braiding with trivial twist (i.e. identity)</li><li><code>Fermionic()</code>: symmetric braiding with non-trivial twist (squares to identity)</li><li><code>Anyonic()</code>: general <span>$R_(a,b)^c$</span> phase or matrix (depending on <code>SimpleNonAbelian</code> or   <code>DegenerateNonAbelian</code> fusion) and arbitrary twists</li></ul><p>Note that <code>Bosonic</code> and <code>Fermionic</code> are subtypes of <code>SymmetricBraiding</code>, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: <code>Rsymbol(b,a,c)*Rsymbol(a,b,c) = I</code>) and permutations are uniquely defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L326-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Irrep" href="#TensorKit.Irrep"><code>TensorKit.Irrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Irrep &lt;: Sector end</code></pre><p>Abstract supertype for sectors which corresponds to irreps (irreducible representations) of groups. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.</p><p>All irreps have <a href="#TensorKit.BraidingStyle"><code>BraidingStyle</code></a> equal to <code>Bosonic()</code> and thus trivial twists. A fermionic sector can be created using <a href="lib/@ref"><code>Fermion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.AbelianIrrep" href="#TensorKit.AbelianIrrep"><code>TensorKit.AbelianIrrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbelianIrrep &lt;: Irrep end</code></pre><p>Abstract supertype for sectors which corresponds to irreps (irreducible representations) of abelian groups. They all have <code>FusionStyle</code> equal to <code>Abelian()</code> and thus trivial topological data, which is real valued.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.ZNIrrep" href="#TensorKit.ZNIrrep"><code>TensorKit.ZNIrrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ZNIrrep{N} &lt;: AbelianIrrep
ZNIrrep(n::Integer)</code></pre><p>Represents irreps of the group <span>$ℤ_N$</span> for some value of <code>N&lt;64</code>. Unicode synonyms are available for the cases <code>N=2,3,4</code> as <code>ℤ₂</code>, <code>ℤ₃</code>, <code>ℤ₄</code>. Also the name <code>Parity</code> can be used as synonym for <code>ℤ₂</code>. An arbitrary <code>Integer</code> <code>n</code> can be provided to the constructor, but only the value <code>mod(n, N)</code> is relevant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.U1Irrep" href="#TensorKit.U1Irrep"><code>TensorKit.U1Irrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct U1Irrep &lt;: AbelianIrrep
U1Irrep(j::Real)</code></pre><p>Represents irreps of the group <code>U₁ == SO₂</code>, both of which are valid unicode synonyms. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of <code>U₁</code> subgroups of <span>$SU₂$</span>. Hence, the charge is stored as a <code>HalfInt</code> from the package HalfIntegers.jl, but can be entered as arbitrary <code>Real</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.SU2Irrep" href="#TensorKit.SU2Irrep"><code>TensorKit.SU2Irrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SU2Irrep &lt;: Irrep
SU2Irrep(j::Real)</code></pre><p>Represents irreps of the group <code>SU₂</code>, which is also a valid unicode synonym. The irrep is labelled by a half integer <code>j</code> which can be entered as an abitrary <code>Real</code>, but is stored as a <code>HalfInt</code> from the HalfIntegers.jl package. Half-integer and integer irreps of <code>SU₂</code> are also projective and linear representation of <code>SO₃</code>, which is another valid unicode synonym.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.CU1Irrep" href="#TensorKit.CU1Irrep"><code>TensorKit.CU1Irrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CU1Irrep &lt;: Irrep
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
end</code></pre><p>Represents irreps of the group <span>$U₁ ⋉ C$</span> (<span>$U₁$</span> and charge conjugation or reflection), which is also known as just <code>O₂</code>. Unicode synomyms are thus <code>CU₁</code> or <code>O₂</code>. The irrep is labelled by a positive half integer <code>j</code> (the <span>$U₁$</span> charge) and an integer <code>s</code> indicating the behaviour under charge conjugation. They take values:</p><ul><li>if <code>j == 0</code>, <code>s = 0</code> (trivial charge conjugation) or   <code>s = 1</code> (non-trivial charge conjugation)</li><li>if <code>j &gt; 0</code>, <code>s = 2</code> (two-dimensional representation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/irreps.jl#L203-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.FibonacciAnyon" href="#TensorKit.FibonacciAnyon"><code>TensorKit.FibonacciAnyon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FibonacciAnyon &lt;: Sector
FibonacciAnyon(s::Union{Symbol,Integer})</code></pre><p>Represents the Fibonacci fusion category. It can take two values, corresponding to the trivial sector <code>FibonacciAnyon(:I) == FibonacciAnyon(0)</code> and the non-trivial sector <code>FibonacciAnyon(:τ) = FibonacciAnyon(1)</code> with fusion rules <span>$τ ⊗ τ = 1 ⊕ τ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/anyons.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.FusionTree" href="#TensorKit.FusionTree"><code>TensorKit.FusionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FusionTree{G,N,M,L,T}</code></pre><p>Represents a fusion tree of sectors of type <code>G&lt;:Sector</code>, fusing (or splitting) <code>N</code> uncoupled sectors to a coupled sector. This fusion tree has <code>M=max(0,N-2)</code> inner lines. Furthermore, for <code>FusionStyle(G) isa DegenerateNonAbelian</code>, the <code>L=max(0,N-1)</code> corresponding vertices carry a label of type <code>T</code>. If <code>FusionStyle(G) isa Union{Abelian,SimpleNonAbelian}</code>, <code>T = Nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/fusiontrees.jl#L3-L11">source</a></section></article><h2 id="Methods-for-characterizing-Sector-subtypes-1"><a class="docs-heading-anchor" href="#Methods-for-characterizing-Sector-subtypes-1">Methods for characterizing <code>Sector</code> subtypes</a><a class="docs-heading-anchor-permalink" href="#Methods-for-characterizing-Sector-subtypes-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{Sector}" href="#Base.one-Tuple{Sector}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(::Sector) -&gt; Sector
one(::Type{&lt;:Sector}) -&gt; Sector</code></pre><p>Return the unit element within this type of sector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.dual-Tuple{Sector}" href="#TensorKit.dual-Tuple{Sector}"><code>TensorKit.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dual(a::Sector) -&gt; Sector</code></pre><p>Return the conjugate label <code>conj(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Nsymbol" href="#TensorKit.Nsymbol"><code>TensorKit.Nsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Nsymbol(a::G, b::G, c::G) where {G&lt;:Sector} -&gt; Integer</code></pre><p>Return an <code>Integer</code> representing the number of times <code>c</code> appears in the fusion product <code>a ⊗ b</code>. Could be a <code>Bool</code> if <code>FusionStyle(G) == Abelian()</code> or <code>SimpleNonAbelian()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Fsymbol" href="#TensorKit.Fsymbol"><code>TensorKit.Fsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G) where {G&lt;:Sector}</code></pre><p>Return the F-symbol <span>$F^{abc}_d$</span> that associates the two different fusion orders of sectors <code>a</code>, <code>b</code> and <code>c</code> into an ouput sector <code>d</code>, using either an intermediate sector <span>$a ⊗ b → e$</span> or <span>$b ⊗ c → f$</span>:</p><pre><code class="language-none">a-&lt;-μ-&lt;-e-&lt;-ν-&lt;-d                                     a-&lt;-λ-&lt;-d
    ∨       ∨       -&gt; Fsymbol(a,b,c,d,e,f)[μ,ν,κ,λ]      ∨
    b       c                                         b-&lt;-κ
                                                          ∨
                                                          c</code></pre><p>If <code>FusionStyle(G)</code> is <code>Abelian</code> or <code>SimpleNonAbelian</code>, the F-symbol is a number. Otherwise it is a rank 4 array of size <code>(Nsymbol(a,b,e), Nsymbol(e,c,d), Nsymbol(b,c,f), Nsymbol(a,f,d))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L160-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Rsymbol" href="#TensorKit.Rsymbol"><code>TensorKit.Rsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Rsymbol(a::G, b::G, c::G) where {G&lt;:Sector}</code></pre><p>Returns the R-symbol <span>$R^{ab}_c$</span> that maps between <span>$a ⊗ b → c$</span> and <span>$b ⊗ a → c$</span> as in</p><pre><code class="language-none">a -&lt;-μ-&lt;- c                                 b -&lt;-ν-&lt;- c
     ∨          -&gt; Rsymbol(a,b,c)[μ,ν]           ∧
     b                                           a</code></pre><p>If <code>FusionStyle(G)</code> is <code>Abelian()</code> or <code>SimpleNonAbelian()</code>, the R-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a,b,c) == Nsymbol(b,a,c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.Bsymbol" href="#TensorKit.Bsymbol"><code>TensorKit.Bsymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Bsymbol(a::G, b::G, c::G) where {G&lt;:Sector}</code></pre><p>Return the value of <span>$B^{ab}_c$</span> which appears in transforming a splitting vertex into a fusion vertex using the transformation</p><pre><code class="language-none">a -&lt;-μ-&lt;- c                                                    a -&lt;-ν-&lt;- c
     ∨          -&gt; √(dim(c)/dim(a)) * Bsymbol(a,b,c)[μ,ν]           ∧
     b                                                            dual(b)</code></pre><p>If <code>FusionStyle(G)</code> is <code>Abelian()</code> or <code>SimpleNonAbelian()</code>, the B-symbol is a number. Otherwise it is a square matrix with row and column size <code>Nsymbol(a, b, c) == Nsymbol(c, dual(b), a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L275-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.dim-Tuple{Sector}" href="#TensorKit.dim-Tuple{Sector}"><code>TensorKit.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(a::Sector)</code></pre><p>Return the (quantum) dimension of the sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.frobeniusschur" href="#TensorKit.frobeniusschur"><code>TensorKit.frobeniusschur</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">frobeniusschur(a::Sector)</code></pre><p>Return the Frobenius-Schur indicator of a sector <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.twist" href="#TensorKit.twist"><code>TensorKit.twist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">twist(a::Sector)</code></pre><p>Return the twist of a sector <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreal-Tuple{Type{#s4} where #s4&lt;:Sector}" href="#Base.isreal-Tuple{Type{#s4} where #s4&lt;:Sector}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isreal(::Type{&lt;:Sector}) -&gt; Bool</code></pre><p>Return whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.vertex_labeltype" href="#TensorKit.vertex_labeltype"><code>TensorKit.vertex_labeltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertex_labeltype(G::Type{&lt;:Sector}) -&gt; Type</code></pre><p>Return the type of labels for the fusion vertices of sectors of type <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.vertex_ind2label" href="#TensorKit.vertex_ind2label"><code>TensorKit.vertex_ind2label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertex_ind2label(i::Int, a::G, b::G, c::G) where {G&lt;:Sector}</code></pre><p>Convert the index i of the fusion vertex (a,b)-&gt;c into a label. For <code>FusionStyle(G) == Abelian()</code> or <code>FusionStyle(G) == NonAbelian()</code>, where every fusion output occurs only once and <code>i == 1</code>, the default is to suppress vertex labels by setting them equal to <code>nothing</code>. For <code>FusionStyle(G) == DegenerateNonAbelian()</code>, the default is to just use <code>i</code>, unless a specialized method is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/sectors/sectors.jl#L197-L205">source</a></section></article><h2 id="Methods-for-manipulating-fusion-trees-or-pairs-of-fusion-splitting-trees-1"><a class="docs-heading-anchor" href="#Methods-for-manipulating-fusion-trees-or-pairs-of-fusion-splitting-trees-1">Methods for manipulating fusion trees or pairs of fusion-splitting trees</a><a class="docs-heading-anchor-permalink" href="#Methods-for-manipulating-fusion-trees-or-pairs-of-fusion-splitting-trees-1" title="Permalink"></a></h2><p>The main method for manipulating a fusion-splitting tree pair is</p><article class="docstring"><header><a class="docstring-binding" id="TensorKit.braid-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G&lt;:Sector" href="#TensorKit.braid-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G&lt;:Sector"><code>TensorKit.braid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">braid(f1::FusionTree{G}, f2::FusionTree{G},
        levels1::IndexTuple, levels2::IndexTuple,
        p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {G&lt;:Sector,N₁,N₂}
-&gt; &lt;:AbstractDict{Tuple{FusionTree{G,N₁}, FusionTree{G,N₂}},&lt;:Number}</code></pre><p>Input is a fusion-splitting tree pair that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the splitting tree <code>f1</code> and fusion tree <code>f2</code>, such that the incoming sectors <code>f2.uncoupled</code> are fused to <code>f1.coupled == f2.coupled</code> and then to the outgoing sectors <code>f1.uncoupled</code>. Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors <code>p1</code> become outgoing and sectors <code>p2</code> become incoming. The uncoupled indices in splitting tree <code>f1</code> and fusion tree <code>f2</code> have levels (or depths) <code>levels1</code> and <code>levels2</code> respectively, which determines how indices braid. In particular, if <code>i</code> and <code>j</code> cross, <span>$τ_{i,j}$</span> is applied if <code>levels[i] &lt; levels[j]</code> and <span>$τ_{j,i}^{-1}$</span> if <code>levels[i] &gt; levels[j]</code>. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L428-L445">source</a></section></article><p>which, for <code>FusionStyle(G) isa SymmetricBraiding</code>, simplifies to</p><article class="docstring"><header><a class="docstring-binding" id="TensorKit.permute-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G&lt;:Sector" href="#TensorKit.permute-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G&lt;:Sector"><code>TensorKit.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(f1::FusionTree{G}, f2::FusionTree{G},
        p1::NTuple{N₁,Int}, p2::NTuple{N₂,Int}) where {G,N₁,N₂}
-&gt; &lt;:AbstractDict{Tuple{FusionTree{G,N₁}, FusionTree{G,N₂}},&lt;:Number}</code></pre><p>Input is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (<code>t1</code>) and incoming sectors (<code>t2</code>) respectively (with identical coupled sector <code>t1.coupled == t2.coupled</code>). Computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors <code>p1</code> become outgoing and sectors <code>p2</code> become incoming.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L515-L526">source</a></section></article><p>These operations are implemented by composing the following more elementary manipulations</p><article class="docstring"><header><a class="docstring-binding" id="TensorKit.braid-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where G&lt;:Sector" href="#TensorKit.braid-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where G&lt;:Sector"><code>TensorKit.braid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">braid(f::FusionTree{&lt;:Sector,N}, levels::NTuple{N,Int}, p::NTuple{N,Int})
-&gt; &lt;:AbstractDict{typeof(t),&lt;:Number}</code></pre><p>Perform a braiding of the uncoupled indices of the fusion tree <code>f</code> and returns the result as a <code>&lt;:AbstractDict</code> of output trees and corresponding coefficients. The braiding is specified by specifying that index <code>i</code> goes to position <code>perm[i]</code> and assinging to every index a distinct level or depth <code>levels[i]</code>. This permutation is then decomposed into elementary swaps between neighbouring indices, where the swaps are applied as braids such that if <code>i</code> and <code>j</code> cross, <span>$τ_{i,j}$</span> is applied if <code>levels[i] &lt; levels[j]</code> and <span>$τ_{j,i}^{-1}$</span> if <code>levels[i] &gt; levels[j]</code>. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.permute-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}}}} where N where G&lt;:Sector" href="#TensorKit.permute-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}}}} where N where G&lt;:Sector"><code>TensorKit.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(f::FusionTree, p::NTuple{N,Int}) -&gt; &lt;:AbstractDict{typeof(t),&lt;:Number}</code></pre><p>Perform a permutation of the uncoupled indices of the fusion tree <code>f</code> and returns the result as a <code>&lt;:AbstractDict</code> of output trees and corresponding coefficients; this requires that <code>BraidingStyle(sectortype(f)) isa SymmetricBraiding</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.repartition" href="#TensorKit.repartition"><code>TensorKit.repartition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">repartition(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂},
            ::StaticLength{N}) where {G,N₁,N₂,N}
-&gt; &lt;:AbstractDict{Tuple{FusionTree{G,N}, FusionTree{G,N₁+N₂-N}},&lt;:Number}</code></pre><p>Input is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (<code>f1</code>) and incoming sectors (<code>f2</code>) respectively (with identical coupled sector <code>f1.coupled == f2.coupled</code>). Computes new trees and corresponding coefficients obtained from repartitioning the tree by bending incoming to outgoing sectors (or vice versa) in order to have <code>N</code> outgoing sectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L356-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.artin_braid" href="#TensorKit.artin_braid"><code>TensorKit.artin_braid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">artin_braid(f::FusionTree, i; inv::Bool = false) -&gt; &lt;:AbstractDict{typeof(t),&lt;:Number}</code></pre><p>Perform an elementary braid (Artin generator) of neighbouring uncoupled indices <code>i</code> and <code>i+1</code> on a fusion tree <code>f</code>, and returns the result as a dictionary of output trees and corresponding coefficients.</p><p>The keyword <code>inv</code> determines whether index <code>i</code> will braid above or below index <code>i+1</code>, i.e. applying <code>artin_braid(f′, i; inv = true)</code> to all the outputs <code>f′</code> of <code>artin_braid(f, i; inv = false)</code> and collecting the results should yield a single fusion tree with non-zero coefficient, namely <code>f</code> with coefficient <code>1</code>. This keyword has no effect if  <code>BraidingStyle(sectortype(f)) isa SymmetricBraiding</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L1-L13">source</a></section></article><p>Finally, there are some additional manipulations for internal use</p><article class="docstring"><header><a class="docstring-binding" id="TensorKit.insertat" href="#TensorKit.insertat"><code>TensorKit.insertat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertat(f::FusionTree{G,N₁}, i, f2::FusionTree{G,N₂})
-&gt; &lt;:AbstractDict{&lt;:FusionTree{G,N₁+N₂-1},&lt;:Number}</code></pre><p>Attach a fusion tree <code>f2</code> to the uncoupled leg <code>i</code> of the fusion tree <code>f1</code> and bring it into a linear combination of fusion trees in standard form. This requires that <code>f2.coupled == f1.uncoupled[i]</code> and <code>f1.isdual[i] == false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L212-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.split" href="#TensorKit.split"><code>TensorKit.split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">split(f::FusionTree{G,N}, ::StaticLength(M))
-&gt; (::FusionTree{G,M}, ::FusionTree{G,N-M+1})</code></pre><p>Split a fusion tree with the first M outgoing indices, and an incoming index corresponding to the internal fusion tree index between outgoing indices N and N+1 of the original tree <code>f</code>; and a second fusion tree whose first outgoing index is that same internal index. Its remaining outgoing indices are the N-M outgoing indices of the original tree <code>f</code>, and also the incoming index is the same. This is in the inverse of <code>insertat</code> in the sense that if <code>f1, f2 = split(t, StaticLength(M)) ⇒ f == insertat(f2, 1, f1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.merge" href="#TensorKit.merge"><code>TensorKit.merge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge(f1::FusionTree{G,N₁}, f2::FusionTree{G,N₂}, c::G, μ = nothing)
-&gt; &lt;:AbstractDict{&lt;:FusionTree{G,N₁+N₂},&lt;:Number}</code></pre><p>Merge two fusion trees together to a linear combination of fusion trees whose uncoupled sectors are those of <code>f1</code> followed by those of <code>f2</code>, and where the two coupled sectors of <code>f1</code> and <code>f2</code> are further fused to <code>c</code>. In case of <code>FusionStyle(G) == DegenerateNonAbelian()</code>, also a degeneracy label <code>μ</code> for the fusion of the coupled sectors of <code>f1</code> and <code>f2</code> to <code>c</code> needs to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorKit.jl/blob/edbc0ec89e197dac7a89d693828b5e7f7b7f4a8d/src/fusiontrees/manipulations.jl#L186-L195">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/tensors/">« Tensors and the <code>TensorMap</code> type</a><a class="docs-footer-nextpage" href="../spaces/">Vector spaces »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 12 May 2020 01:05">Tuesday 12 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
