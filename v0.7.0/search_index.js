var documenterSearchIndex = {"docs":
[{"location":"lib/tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"lib/tensors/","page":"Tensors","title":"Tensors","text":"CurrentModule = TensorKit","category":"page"},{"location":"lib/tensors/#Type-hierarchy","page":"Tensors","title":"Type hierarchy","text":"","category":"section"},{"location":"lib/tensors/","page":"Tensors","title":"Tensors","text":"AbstractTensorMap\nAbstractTensor\nTensorMap\nAdjointTensorMap","category":"page"},{"location":"lib/tensors/#TensorKit.AbstractTensorMap","page":"Tensors","title":"TensorKit.AbstractTensorMap","text":"abstract type AbstractTensorMap{S<:IndexSpace, N₁, N₂} end\n\nAbstract supertype of all tensor maps, i.e. linear maps between tensor products of vector spaces of type S<:IndexSpace. An AbstractTensorMap maps from an input space of type ProductSpace{S, N₂} to an output space of type ProductSpace{S, N₁}.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.AbstractTensor","page":"Tensors","title":"TensorKit.AbstractTensor","text":"AbstractTensor{S<:IndexSpace, N} = AbstractTensorMap{S, N, 0}\n\nAbstract supertype of all tensors, i.e. elements in the tensor product space of type ProductSpace{S, N}, built from elementary spaces of type S<:IndexSpace.\n\nAn AbstractTensor{S, N} is actually a special case AbstractTensorMap{S, N, 0}, i.e. a tensor map with only a non-trivial output space.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.TensorMap","page":"Tensors","title":"TensorKit.TensorMap","text":"struct TensorMap{S<:IndexSpace, N₁, N₂, ...} <: AbstractTensorMap{S, N₁, N₂}\n\nSpecific subtype of AbstractTensorMap for representing tensor maps (morphisms in a tensor category) whose data is stored in blocks of some subtype of DenseMatrix.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#TensorKit.AdjointTensorMap","page":"Tensors","title":"TensorKit.AdjointTensorMap","text":"struct AdjointTensorMap{S<:IndexSpace, N₁, N₂, ...} <: AbstractTensorMap{S, N₁, N₂}\n\nSpecific subtype of AbstractTensorMap that is a lazy wrapper for representing the adjoint of an instance of TensorMap.\n\n\n\n\n\n","category":"type"},{"location":"lib/tensors/#Specific-TensorMap-constructors","page":"Tensors","title":"Specific TensorMap constructors","text":"","category":"section"},{"location":"lib/tensors/","page":"Tensors","title":"Tensors","text":"id\nisomorphism\nunitary\nisometry","category":"page"},{"location":"lib/tensors/#TensorKit.id","page":"Tensors","title":"TensorKit.id","text":"id([A::Type{<:DenseMatrix} = Matrix{Float64},] space::VectorSpace) -> TensorMap\n\nConstruct the identity endomorphism on space space, i.e. return a t::TensorMap with domain(t) == codomain(t) == V, where storagetype(t) = A can be specified.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.isomorphism","page":"Tensors","title":"TensorKit.isomorphism","text":"isomorphism([A::Type{<:DenseMatrix} = Matrix{Float64},]\n                cod::VectorSpace, dom::VectorSpace)\n-> TensorMap\n\nReturn a t::TensorMap that implements a specific isomorphism between the codomain cod and the domain dom, and for which storagetype(t) can optionally be chosen to be of type A. If the two spaces do not allow for such an isomorphism, and are thus not isomorphic, and error will be thrown. When they are isomorphic, there is no canonical choice for a specific isomorphism, but the current choice is such that isomorphism(cod, dom) == inv(isomorphism(dom, cod)).\n\nSee also unitary when spacetype(cod) isa EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.unitary","page":"Tensors","title":"TensorKit.unitary","text":"unitary([A::Type{<:DenseMatrix} = Matrix{Float64},] cod::VectorSpace, dom::VectorSpace)\n-> TensorMap\n\nReturn a t::TensorMap that implements a specific unitary isomorphism between the codomain cod and the domain dom, for which spacetype(dom) (== spacetype(cod)) must be a subtype of EuclideanSpace. Furthermore, storagetype(t) can optionally be chosen to be of type A. If the two spaces do not allow for such an isomorphism, and are thus not isomorphic, and error will be thrown. When they are isomorphic, there is no canonical choice for a specific isomorphism, but the current choice is such that unitary(cod, dom) == inv(unitary(dom, cod)) = adjoint(unitary(dom, cod)).\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.isometry","page":"Tensors","title":"TensorKit.isometry","text":"isometry([A::Type{<:DenseMatrix} = Matrix{Float64},] cod::VectorSpace, dom::VectorSpace)\n-> TensorMap\n\nReturn a t::TensorMap that implements a specific isometry that embeds the domain dom into the codomain cod, and which requires that spacetype(dom) (== spacetype(cod)) is a subtype of EuclideanSpace. An isometry t is such that its adjoint t' is the left inverse of t, i.e. t'*t = id(dom), while t*t' is some idempotent endomorphism of cod, i.e. it squares to itself. When dom and cod do not allow for such an isometric inclusion, an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorMap-operations","page":"Tensors","title":"TensorMap operations","text":"","category":"section"},{"location":"lib/tensors/","page":"Tensors","title":"Tensors","text":"permute(t::TensorMap{S}, p1::IndexTuple, p2::IndexTuple) where {S}\npermute!\nbraid\nbraid!\ntwist\ntwist!\nadd!\ntrace!\ncontract!","category":"page"},{"location":"lib/tensors/#TensorKit.permute-Union{Tuple{S}, Tuple{TensorMap{S,N₁,N₂,I,A,F₁,F₂} where F₂ where F₁ where A<:(Union{TensorKit.SortedVectorDict{I,#s83} where #s83<:(DenseArray{T,2} where T), #s84} where #s84<:(DenseArray{T,2} where T)) where I<:Sector where N₂ where N₁,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N}} where N}} where S","page":"Tensors","title":"TensorKit.permute","text":"permute(tsrc::AbstractTensorMap{S}, p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int} = ())\n    -> tdst::TensorMap{S, N₁, N₂}\n\nPermute the indices of tsrc::AbstractTensorMap{S} such that a new tensor tdst::TensorMap{S, N₁, N₂} is obtained, with indices in p1 playing the role of the codomain or range of the map, and indices in p2 indicating the domain.\n\nTo permute into an existing tdst, see add!\n\n\n\n\n\n","category":"method"},{"location":"lib/tensors/#Base.permute!","page":"Tensors","title":"Base.permute!","text":"permute(tsrc::AbstractTensorMap{S}, p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int} = ())\n    -> tdst::TensorMap{S, N₁, N₂}\n\nPermute the indices of tsrc::AbstractTensorMap{S} such that a new tensor tdst::TensorMap{S, N₁, N₂} is obtained, with indices in p1 playing the role of the codomain or range of the map, and indices in p2 indicating the domain.\n\nTo permute into an existing tdst, see add!\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.braid","page":"Tensors","title":"TensorKit.braid","text":"braid(f::FusionTree{<:Sector, N}, levels::NTuple{N, Int}, p::NTuple{N, Int})\n-> <:AbstractDict{typeof(t), <:Number}\n\nPerform a braiding of the uncoupled indices of the fusion tree f and returns the result as a <:AbstractDict of output trees and corresponding coefficients. The braiding is specified by specifying that the new sector at position i was originally at position p[i] and assinging to every index a distinct level or depth levels[i]. This permutation is then decomposed into elementary swaps between neighbouring indices, where the swaps are applied as braids such that if i and j cross, τ_ij is applied if levels[i] < levels[j] and τ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\nbraid(f1::FusionTree{I}, f2::FusionTree{I},\n        levels1::IndexTuple, levels2::IndexTuple,\n        p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I<:Sector, N₁, N₂}\n-> <:AbstractDict{Tuple{FusionTree{I, N₁}, FusionTree{I, N₂}}, <:Number}\n\nInput is a fusion-splitting tree pair that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the splitting tree f1 and fusion tree f2, such that the incoming sectors f2.uncoupled are fused to f1.coupled == f2.coupled and then to the outgoing sectors f1.uncoupled. Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors p1 become outgoing and sectors p2 become incoming. The uncoupled indices in splitting tree f1 and fusion tree f2 have levels (or depths) levels1 and levels2 respectively, which determines how indices braid. In particular, if i and j cross, τ_ij is applied if levels[i] < levels[j] and τ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorMap-factorizations","page":"Tensors","title":"TensorMap factorizations","text":"","category":"section"},{"location":"lib/tensors/","page":"Tensors","title":"Tensors","text":"leftorth\nrightorth\nleftnull\nrightnull\ntsvd\neigh\neig\nTensorKit.eigen","category":"page"},{"location":"lib/tensors/#TensorKit.leftorth","page":"Tensors","title":"TensorKit.leftorth","text":"leftorth(t::AbstractTensorMap, leftind::Tuple, rightind::Tuple;\n            alg::OrthogonalFactorizationAlgorithm = QRpos()) -> Q, R\n\nCreate orthonormal basis Q for indices in leftind, and remainder R such that permute(t, leftind, rightind) = Q*R.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using leftorth!(t, alg = QRpos()).\n\nDifferent algorithms are available, namely QR(), QRpos(), SVD() and Polar(). QR() and QRpos() use a standard QR decomposition, producing an upper triangular matrix R. Polar() produces a Hermitian and positive semidefinite R. QRpos() corrects the standard QR decomposition such that the diagonal elements of R are positive. Only QRpos() and Polar() are uniqe (no residual freedom) so that they always return the same result for the same input tensor t.\n\nOrthogonality requires spacetype(t)<:InnerProductSpace, and leftorth(!) is currently only implemented for spacetype(t)<:EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.rightorth","page":"Tensors","title":"TensorKit.rightorth","text":"rightorth(t::AbstractTensorMap, leftind::Tuple, rightind::Tuple;\n            alg::OrthogonalFactorizationAlgorithm = LQpos()) -> L, Q\n\nCreate orthonormal basis Q for indices in rightind, and remainder L such that permute(t, leftind, rightind) = L*Q.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using rightorth!(t, alg = LQpos()).\n\nDifferent algorithms are available, namely LQ(), LQpos(), RQ(), RQpos(), SVD() and Polar(). LQ() and LQpos() produce a lower triangular matrix L and are computed using a QR decomposition of the transpose. RQ() and RQpos() produce an upper triangular remainder L and only works if the total left dimension is smaller than or equal to the total right dimension. LQpos() and RQpos() add an additional correction such that the diagonal elements of L are positive. Polar() produces a Hermitian and positive semidefinite L. Only LQpos(), RQpos() and Polar() are uniqe (no residual freedom) so that they always return the same result for the same input tensor t.\n\nOrthogonality requires spacetype(t)<:InnerProductSpace, and rightorth(!) is currently only implemented for spacetype(t)<:EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.leftnull","page":"Tensors","title":"TensorKit.leftnull","text":"leftnull(t::AbstractTensor, leftind::Tuple, rightind::Tuple;\n            alg::OrthogonalFactorizationAlgorithm = QRpos()) -> N\n\nCreate orthonormal basis for the orthogonal complement of the support of the indices in leftind, such that N' * permute(t, leftind, rightind) = 0.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using leftnull!(t, alg = QRpos()).\n\nDifferent algorithms are available, namely QR() (or equivalently, QRpos()), SVD() and SDD(). The first assumes that the matrix is full rank and requires iszero(atol) and iszero(rtol). With SVD() and SDD(), rightnull will use the corresponding singular value decomposition, and one can specify an absolute or relative tolerance for which singular values are to be considered zero, where max(atol, norm(t)*rtol) is used as upper bound.\n\nOrthogonality requires spacetype(t)<:InnerProductSpace, and leftnull(!) is currently only implemented for spacetype(t)<:EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.rightnull","page":"Tensors","title":"TensorKit.rightnull","text":"rightnull(t::AbstractTensor, leftind::Tuple, rightind::Tuple;\n            alg::OrthogonalFactorizationAlgorithm = LQ(),\n            atol::Real = 0.0,\n            rtol::Real = eps(real(float(one(eltype(t)))))*iszero(atol)) -> N\n\nCreate orthonormal basis for the orthogonal complement of the support of the indices in rightind, such that permute(t, leftind, rightind)*N' = 0.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using rightnull!(t, alg = LQpos()).\n\nDifferent algorithms are available, namely LQ() (or equivalently, LQpos), SVD() and SDD(). The first assumes that the matrix is full rank and requires iszero(atol) and iszero(rtol). With SVD() and SDD(), rightnull will use the corresponding singular value decomposition, and one can specify an absolute or relative tolerance for which singular values are to be considered zero, where max(atol, norm(t)*rtol) is used as upper bound.\n\nOrthogonality requires spacetype(t)<:InnerProductSpace, and rightnull(!) is currently only implemented for spacetype(t)<:EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.tsvd","page":"Tensors","title":"TensorKit.tsvd","text":"tsvd(t::AbstractTensorMap, leftind::Tuple, rightind::Tuple;\n    trunc::TruncationScheme = notrunc(), p::Real = 2, alg::Union{SVD, SDD} = SDD())\n    -> U, S, V, ϵ\n\nCompute the (possibly truncated)) singular value decomposition such that norm(permute(t, leftind, rightind) - U * S *V) ≈ ϵ, where ϵ thus represents the truncation error.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using tsvd!(t, trunc = notrunc(), p = 2).\n\nA truncation parameter trunc can be specified for the new internal dimension, in which case a truncated singular value decomposition will be computed. Choices are:\n\nnotrunc(): no truncation (default);\ntruncerr(η::Real): truncates such that the p-norm of the truncated singular values is   smaller than η times the p-norm of all singular values;\ntruncdim(χ::Int): truncates such that the equivalent total dimension of the internal   vector space is no larger than χ;\ntruncspace(V): truncates such that the dimension of the internal vector space is   smaller than that of V in any sector.\ntrunbelow(χ::Real): truncates such that every singular value is larger then χ ;\n\nThe method tsvd also returns the truncation error ϵ, computed as the p norm of the singular values that were truncated.\n\nTHe keyword alg can be equal to SVD() or SDD(), corresponding to the underlying LAPACK algorithm that computes the decomposition (_gesvd or _gesdd).\n\nOrthogonality requires spacetype(t)<:InnerProductSpace, and svd(!) is currently only implemented for spacetype(t)<:EuclideanSpace.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.eigh","page":"Tensors","title":"TensorKit.eigh","text":"eigh(t::AbstractTensorMap{<:EuclideanSpace}, leftind::Tuple, rightind::Tuple) -> D, V\n\nCompute eigenvalue factorization of tensor t as linear map from rightind to leftind. The function eigh assumes that the linear map is hermitian and D and V tensors with the same eltype as t. See eig and eigen for non-hermitian tensors. Hermiticity requires that the tensor acts on inner product spaces, and the current implementation requires spacetyp(t) <: EuclideanSpace.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using eigh!(t). Note that the permuted tensor on which eigh! is called should have equal domain and codomain, as otherwise the eigenvalue decomposition is meaningless and cannot satisfy\n\npermute(t, leftind, rightind) * V = V * D\n\nSee also eigen and eig.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#TensorKit.eig","page":"Tensors","title":"TensorKit.eig","text":"eig(t::AbstractTensor, leftind::Tuple, rightind::Tuple; kwargs...) -> D, V\n\nCompute eigenvalue factorization of tensor t as linear map from rightind to leftind. The function eig assumes that the linear map is not hermitian and returns type stable complex valued D and V tensors for both real and complex valued t. See eigh for hermitian linear maps\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using eig!(t). Note that the permuted tensor on which eig! is called should have equal domain and codomain, as otherwise the eigenvalue decomposition is meaningless and cannot satisfy\n\npermute(t, leftind, rightind) * V = V * D\n\nAccepts the same keyword arguments scale, permute and sortby as eigen of dense matrices. See the corresponding documentation for more information.\n\nSee also eigen and eigh.\n\n\n\n\n\n","category":"function"},{"location":"lib/tensors/#LinearAlgebra.eigen","page":"Tensors","title":"LinearAlgebra.eigen","text":"eigen(t::AbstractTensor, leftind::Tuple, rightind::Tuple; kwargs...) -> D, V\n\nCompute eigenvalue factorization of tensor t as linear map from rightind to leftind.\n\nIf leftind and rightind are not specified, the current partition of left and right indices of t is used. In that case, less memory is allocated if one allows the data in t to be destroyed/overwritten, by using eigen!(t). Note that the permuted tensor on which eigen! is called should have equal domain and codomain, as otherwise the eigenvalue decomposition is meaningless and cannot satisfy\n\npermute(t, leftind, rightind) * V = V * D\n\nAccepts the same keyword arguments scale, permute and sortby as eigen of dense matrices. See the corresponding documentation for more information.\n\nSee also eig and eigh\n\n\n\n\n\n","category":"function"},{"location":"man/tensors/#s_tensors","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"using TensorKit\nusing LinearAlgebra","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"This last page explains how to create and manipulate tensors in TensorKit.jl. As this is probably the most important part of the manual, we will also focus more strongly on the usage and interface, and less so on the underlying implementation. The only aspect of the implementation that we will address is the storage of the tensor data, as this is important to know how to create and initialize a tensor, but will in fact also shed light on how some of the methods work.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"As mentioned, all tensors in TensorKit.jl are interpreted as linear maps (morphisms) from a domain (a ProductSpace{S,N₂}) to a codomain (another ProductSpace{S,N₁}), with the same S<:ElementarySpace that labels the type of spaces associated with the individual tensor indices. The overall type for all such tensor maps is AbstractTensorMap{S, N₁, N₂}. Note that we place information about the codomain before that of the domain. Indeed, we have already encountered the constructor for the concrete parametric type TensorMap in the form TensorMap(..., codomain, domain). This convention is opposite to the mathematical notation, e.g. mathrmHom(WV) or fWV, but originates from the fact that a normal matrix is also denoted as having size m × n or is constructed in Julia as Array(..., (m, n)), where the first integer m refers to the codomain being m- dimensional, and the seond integer n to the domain being n-dimensional. This also explains why we have consistently used the symbol W for spaces in the domain and V for spaces in the codomain. A tensor map t(W₁    W_N₂)  (V₁    V_N₁) will be created in Julia as TensorMap(..., V1 ⊗ ... ⊗ VN₁, W1 ⊗ ... ⊗ WN2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Furthermore, the abstract type AbstractTensor{S,N} is just a synonym for AbstractTensorMap{S,N,0}, i.e. for tensor maps with an empty domain, which is equivalent to the unit of the monoidal category, or thus, the field of scalars 𝕜.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Currently, AbstractTensorMap has two subtypes. TensorMap provides the actual implementation, where the data of the tensor is stored in a DenseArray (more specifically a DenseMatrix as will be explained below). AdjointTensorMap is a simple wrapper type to denote the adjoint of an existing TensorMap object. In the future, additional types could be defined, to deal with sparse data, static data, diagonal data, etc...","category":"page"},{"location":"man/tensors/#ss_tensor_storage","page":"Tensors and the TensorMap type","title":"Storage of tensor data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Before discussion how to construct and initalize a TensorMap{S}, let us discuss what is meant by 'tensor data' and how it can efficiently and compactly be stored. Let us first discuss the case sectortype(S) == Trivial sector, i.e. the case of no symmetries. In that case the data of a tensor t = TensorMap(..., V1 ⊗ ... ⊗ VN₁, W1 ⊗ ... ⊗ WN2) can just be represented as a multidimensional array of size","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(dim(V1), dim(V2), …, dim(VN₁), dim(W1), …, dim(WN₂))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"which can also be reshaped into matrix of size","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(dim(V1)*dim(V2)*…*dim(VN₁), dim(W1)*dim(W2)*…*dim(WN₂))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and is really the matrix representation of the linear map that the tensor represents. In particular, given a second tensor t2 whose domain matches with the codomain of t, function composition amounts to multiplication of their corresponding data matrices. Similarly, tensor factorizations such as the singular value decomposition, which we discuss below, can act directly on this matrix representation.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"note: Note\nOne might wonder if it would not have been more natural to represent the tensor data as (dim(V1), dim(V2), …, dim(VN₁), dim(WN₂), …, dim(W1)) given how employing the duality naturally reverses the tensor product, as encountered with the interface of repartition for fusion trees. However, such a representation, when plainly reshaped to a matrix, would not have the above properties and would thus not constitute the matrix representation of the tensor in a compatible basis.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Now consider the case where sectortype(S) == I for some I which has FusionStyle(I) == Abelian(), i.e. the representations of an Abelian group, e.g. I == Irrep[ℤ₂] or I == Irrep[U₁]. In this case, the tensor data is associated with sectors (a1, a2, …, aN₁) ∈ sectors(V1 ⊗ V2 ⊗ … ⊗ VN₁) and (b1, …, bN₂) ∈ sectors(W1 ⊗ … ⊗ WN₂) such that they fuse to a same common charge, i.e. (c = first(⊗(a1, …, aN₁))) == first(⊗(b1, …, bN₂)). The data associated with this takes the form of a multidimensional array with size (dim(V1, a1), …, dim(VN₁, aN₁), dim(W1, b1), …, dim(WN₂, bN₂)), or equivalently, a matrix of with row size dim(V1, a1)*…*dim(VN₁, aN₁) == dim(codomain, (a1, …, aN₁)) and column size dim(W1, b1)*…*dim(WN₂, aN₂) == dim(domain, (b1, …, bN₂)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"However, there are multiple combinations of (a1, …, aN₁) giving rise to the same c, and so there is data associated with all of these, as well as all possible combinations of (b1, …, bN₂). Stacking all matrices for different (a1,…) and a fixed value of (b1,…) underneath each other, and for fixed value of (a1,…) and different values of (b1,…) next to each other, gives rise to a larger block matrix of all data associated with the central sector c. The size of this matrix is exactly (blockdim(codomain, c), blockdim(domain, c)) and these matrices are exactly the diagonal blocks whose existence is guaranteed by Schur's lemma, and which are labeled by the coupled sector c. Indeed, if we would represent the tensor map t as a matrix without explicitly using the symmetries, we could reorder the rows and columns to group data corresponding to sectors that fuse to the same c, and the resulting block diagonal representation would emerge. This basis transform is thus a permutation, which is a unitary operation, that will cancel or go through trivially for linear algebra operations such as composing tensor maps (matrix multiplication) or tensor factorizations such as a singular value decomposition. For such linear algebra operations, we can thus directly act on these large matrices, which correspond to the diagonal blocks that emerge after a basis transform, provided that the partition of the tensor indices in domain and codomain of the tensor are in line with our needs. For example, composing two tensor maps amounts to multiplying the matrices corresponding to the same c (provided that its subblocks labeled by the different combinations of sectors are ordered in the same way, which we guarantee by associating a canonical order with sectors). Henceforth, we refer to the blocks of a tensor map as those diagonal blocks, the existence of which is provided by Schur's lemma and which are labeled by the coupled sectors c. We directly store these blocks as DenseMatrix and gather them as values in a dictionary, together with the corresponding coupled sector c as key. For a given tensor t, we can access a specific block as block(t, c), whereas blocks(t) yields an iterator over pairs c=>block(t,c).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The subblocks corresponding to a particular combination of sectors then correspond to a particular view for some range of the rows and some range of the colums, i.e. view(block(t, c), m₁:m₂, n₁:n₂) where the ranges m₁:m₂ associated with (a1, …, aN₁) and n₁:n₂ associated with (b₁, …, bN₂) are stored within the fields of the instance t of type TensorMap. This view can then lazily be reshaped to a multidimensional array, for which we rely on the package Strided.jl. Indeed, the data in this view is not contiguous, because the stride between the different columns is larger than the length of the columns. Nonetheless, this does not pose a problem and even as multidimensional array there is still a definite stride associated with each dimension.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When FusionStyle(I) isa NonAbelian, things become slightly more complicated. Not only do (a1, …, aN₁) give rise to different coupled sectors c, there can be multiply ways in which they fuse to c. These different possibilities are enumerated by the iterator fusiontrees((a1, …, aN₁), c) and fusiontrees((b1, …, bN₂), c), and with each of those, there is tensor data that takes the form of a multidimensional array, or, after reshaping, a matrix of size (dim(codomain, (a1, …, aN₁)), dim(domain, (b1, …, bN₂)))). Again, we can stack all such matrices with the same value of f₁ ∈ fusiontrees((a1, …, aN₁), c) horizontally (as they all have the same number of rows), and with the same value of f₂ ∈ fusiontrees((b1, …, bN₂), c) vertically (as they have the same number of columns). What emerges is a large matrix of size (blockdim(codomain, c), blockdim(domain, c)) containing all the tensor data associated with the coupled sector c, where blockdim(P, c) = sum(dim(P, s)*length(fusiontrees(s, c)) for s in sectors(P)) for some instance P of ProductSpace. The tensor implementation does not distinguish between abelian or non-abelian sectors and still stores these matrices as a DenseMatrix, accessible via block(t, c).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"At first sight, it might now be less clear what the relevance of this block is in relation to the full matrix representation of the tensor map, where the symmetry is not exploited. The essential interpretation is still the same. Schur's lemma now tells that there is a unitary basis transform which makes this matrix representation block diagonal, more specifically, of the form _c B_c  𝟙_c, where B_c denotes block(t,c) and 𝟙_c is an identity matrix of size (dim(c), dim(c)). The reason for this extra identity is that the group representation is recoupled to act as _c 𝟙  u_c(g) for all g  mathsfI, with u_c(g) the matrix representation of group element g according to the irrep c. In the abelian case, dim(c) == 1, i.e. all irreducible representations are one-dimensional and Schur's lemma only dictates that all off-diagonal blocks are zero. However, in this case the basis transform to the block diagonal representation is not simply a permutation matrix, but a more general unitary matrix composed of the different fusion trees. Indeed, let us denote the fusion trees f₁ ∈ fusiontrees((a1, …, aN₁), c) as X^a_1  a_N₁_cα where α = (e_1  e_N_1-2 μ₁  μ_N_1-1) is a collective label for the internal sectors e and the vertex degeneracy labels μ of a generic fusion tree, as discussed in the corresponding section. The tensor is then represented as","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor storage)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In this diagram, we have indicated how the tensor map can be rewritten in terms of a block diagonal matrix with a unitary matrix on its left and another unitary matrix (if domain and codomain are different) on its right. So the left and right matrices should actually have been drawn as squares. They represent the unitary basis transform. In this picture, red and white regions are zero. The center matrix is most easy to interpret. It is the block diagonal matrix _c B_c  𝟙_c with diagonal blocks labeled by the coupled charge c, in this case it takes two values. Every single small square in between the dotted or dashed lines has size d_c  d_c and corresponds to a single element of B_c, tensored with the identity mathrmid_c. Instead of B_c, a more accurate labelling is t^c_(a_1  a_N₁)α (b_1  b_N₂)β where α labels different fusion trees from (a_1  a_N₁) to c. The dashed horizontal lines indicate regions corresponding to different fusion (actually splitting) trees, either because of different sectors (a_1  a_N₁) or different labels α within the same sector. Similarly, the dashed vertical lines define the border between regions of different fusion trees from the domain to c, either because of different sectors (b_1  b_N₂) or a different label β.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To understand this better, we need to understand the basis transform, e.g. on the left (codomain) side. In more detail, it is given by","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor unitary)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Indeed, remembering that V_i = _a_i R_a_i  ℂ^n_a_i with R_a_i the representation space on which irrep a_i acts (with dimension mathrmdim(a_i)), we find V_1    V_N_1 = _a_1  a_N₁ (R_a_1    R_a_N_1)  ℂ^n_a_1   n_a_N_1. In the diagram above, the wiggly lines correspond to the direct sum over the different sectors (a_1  a_N₁), there depicted taking three possible values (a), (a) and (a). The tensor product (R_a_1    R_a_N_1)  ℂ^n_a_1   n_a_N_1 is depicted as (R_a_1    R_a_N_1)^ n_a_1   n_a_N_1, i.e. as a direct sum of the spaces R_(a) = (R_a_1    R_a_N_1) according to the dotted horizontal lines, which repeat n_(a) = n_a_1   n_a_N_1 times. In this particular example, n_(a)=2, n_(a)=3 and n_(a)=5. The thick vertical line represents the separation between the two different coupled sectors, denoted as c and c. Dashed vertical lines represent different ways of reaching the coupled sector, corresponding to different α. In this example, the first sector (a) has one fusion tree to c, labeled by cα, and two fusion trees to c, labeled by cα and cα. The second sector has only a fusion tree to c, labeled by cα. The third sector only has a fusion tree to c, labeld by c α. Finally then, because the fusion trees do not act on the spaces ℂ^n_a_1   n_a_N_1, the dotted lines which represent the different n_(a) = n_a_1   n_a_N_1 dimensions are also drawn vertically. In particular, for a given sector (a) and a specific fusion tree X^(a)_cα R_(a)R_c, the action is X^(a)_cα  𝟙_n_(a), which corresponds to the diagonal green blocks in this drawing where the same matrix X^(a)_cα (the fusion tree) is repeated along the diagonal. Note that the fusion tree is not a vector or single column, but a matrix with number of rows equal to mathrmdim(R_(aldots)) = d_a_1 d_a_2  d_a_N_1 and number of columns equal to d_c. A similar interpretation can be given to the basis transform on the right, by taking its adjoint. In this particular example, it has two different combinations of sectors (b) and (b), where both have a single fusion tree to c as well as to c, and n_(b)=2, n_(b)=3.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that we never explicitly store or act with the basis transforms on the left and the right. For composing tensor maps (i.e. multiplying them), these basis transforms just cancel, whereas for tensor factorizations they just go through trivially. They transform non-trivially when reshuffling the tensor indices, both within or in between the domain and codomain. For this, however, we can completely rely on the manipulations of fusion trees to implicitly compute the effect of the basis transform and construct the new blocks B_c that result with respect to the new basis.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, as before, we only store the diagonal blocks B_c of size (blockdim(codomain(t), c), blockdim(domain(t), c)) as a DenseMatrix, accessible via block(t, c). Within this matrix, there are regions of the form view(block(t, c), m₁:m₂, n₁:n₂) that correspond to the data t^c_(a_1  a_N₁)α (b_1  b_N₂)β associated with a pair of fusion trees X^(a_1  a_N₁)_cα and X^(b_1  b_N₂)_cβ, henceforth again denoted as f₁ and f₂, with f₁.coupled == f₂.coupled == c. The ranges where this subblock is living are managed within the tensor implementation, and these subblocks can be accessed via t[f₁,f₂], and is returned as a StridedArray of size n_a_1  n_a_2    n_a_N_1  n_b_1   n_b_N₂, or in code, (dim(V1, a1), dim(V2, a2), …, dim(VN₁, aN₁), dim(W1, b1), …, dim(WN₂, bN₂)). While the implementation does not distinguish between FusionStyle isa Abelian or FusionStyle isa NonAbelian, in the former case the fusion tree is completely characterized by the uncoupled sectors, and so the subblocks can also be accessed as t[(a1, …, aN₁), (b1, …, bN₂)]. When there is no symmetry at all, i.e. sectortype(t) == Trivial, t[] returns the raw tensor data as a StridedArray of size (dim(V1), …, dim(VN₁), dim(W1), …, dim(WN₂)), whereas block(t, Trivial()) returns the same data as a DenseMatrix of size (dim(V1) * … * dim(VN₁), dim(W1) * … * dim(WN₂)).","category":"page"},{"location":"man/tensors/#ss_tensor_construction","page":"Tensors and the TensorMap type","title":"Constructing tensor maps and accessing tensor data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Having learned how a tensor is represented and stored, we can now discuss how to create tensors and tensor maps. From hereon, we focus purely on the interface rather than the implementation.","category":"page"},{"location":"man/tensors/#Random-and-uninitialized-tensor-maps","page":"Tensors and the TensorMap type","title":"Random and uninitialized tensor maps","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The most convenient set of constructors are those that construct  tensors or tensor maps with random or uninitialized data. They take the form","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TensorMap(f, codomain, domain)\nTensorMap(f, eltype::Type{<:Number}, codomain, domain)\nTensorMap(undef, codomain, domain)\nTensorMap(undef, eltype::Type{<:Number}, codomain, domain)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Here, in the first form, f can be any function or object that is called with an argument of type Dims{2} = Tuple{Int,Int} and is such that f((m,n)) creates a DenseMatrix instance with size(f(m,n)) == (m,n). In the second form, f is called as f(eltype,(m,n)). Possibilities for f are randn and rand from Julia Base. TensorKit.jl provides randnormal and randuniform as an synonym for randn and rand, as well as the new function  randisometry, alternatively called randhaar, that creates a random isometric m × n matrix w satisfying w'*w ≈ I distributed according to the Haar measure (this requires m>= n). The third and fourth calling syntax use the UndefInitializer from Julia Base and generates a TensorMap with unitialized data, which could thus contain NaNs.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In all of these constructors, the last two arguments can be replaced by domain→codomain or codomain←domain, where the arrows are obtained as \\rightarrow+TAB and \\leftarrow+TAB and create a HomSpace as explained in the section on Spaces of morphisms. Some examples are perhaps in order","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"t1 = TensorMap(randnormal, ℂ^2 ⊗ ℂ^3, ℂ^2)\nt2 = TensorMap(randisometry, Float32, ℂ^2 ⊗ ℂ^3 ← ℂ^2)\nt3 = TensorMap(undef, ℂ^2 → ℂ^2 ⊗ ℂ^3)\ndomain(t1) == domain(t2) == domain(t3)\ncodomain(t1) == codomain(t2) == codomain(t3)\ndisp(x) = show(IOContext(Core.stdout, :compact=>false), \"text/plain\", trunc.(x; digits = 3));\nt1[] |> disp\nblock(t1, Trivial()) |> disp\nreshape(t1[], dim(codomain(t1)), dim(domain(t1))) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, all constructors can also be replaced by Tensor(..., codomain), in which case the domain is assumed to be the empty ProductSpace{S,0}(), which can easily be obtained as one(codomain). Indeed, the empty product space is the unit object of the monoidal category, equivalent to the field of scalars 𝕜, and thus the multiplicative identity (especially since * also acts as tensor product on vector spaces).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The matrices created by f are the matrices B_c discussed above, i.e. those returned by block(t, c). Only numerical matrices of type DenseMatrix are accepted, which in practice just means Julia's intrinsic Matrix{T} for some T<:Number. In the future, we will add support for CuMatrix from CuArrays.jl to harness GPU computing power, and maybe SharedArray from the Julia's SharedArrays standard library.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Support for static or sparse data is currently unavailable, and if it would be implemented, it would lead to new subtypes of AbstractTensorMap which are distinct from TensorMap. Future implementations of e.g. SparseTensorMap or StaticTensorMap could be useful. Furthermore, there could be specific implementations for tensors whose blocks are Diagonal.","category":"page"},{"location":"man/tensors/#Tensor-maps-from-existing-data","page":"Tensors and the TensorMap type","title":"Tensor maps from existing data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To create a TensorMap with existing data, one can use the aforementioned form but with the function f replaced with the actual data, i.e. TensorMap(data, codomain, domain) or any of its equivalents.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Here, data can be of two types. It can be a dictionary (any Associative subtype) which has blocksectors c of type sectortype(codomain) as keys, and the corresponding matrix blocks as value, i.e. data[c] is some DenseMatrix of size (blockdim(codomain, c), blockdim(domain, c)). This is the form of how the data is stored within the TensorMap objects.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For those space types for which a TensorMap can be converted to a plain multidimensional array, the data can also be a general DenseArray, either of rank N₁+N₂ and with matching size (dims(codomain)..., dims(domain)...), or just as a DenseMatrix with size (dim(codomain), dim(domain)). This is true in particular if the sector type is Trivial, e.g. for CartesianSpace or ComplexSpace. Then the data array is just reshaped into matrix form and referred to as such in the resulting TensorMap instance. When spacetype is GradedSpace, the TensorMap constructor will try to reconstruct the tensor data such that the resulting tensor t satisfies data == convert(Array, t). This might not be possible, if the data does not respect the symmetry structure. Let's sketch this with a simple example","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"data = zeros(2,2,2,2)\n# encode the operator (σ_x * σ_x + σ_y * σ_y + σ_z * σ_z)/2\n# that is, the swap gate, which maps the last two indices on the first two in reversed order\n# also known as Heisenberg interaction between two spin 1/2 particles\ndata[1,1,1,1] = data[2,2,2,2] = data[1,2,2,1] = data[2,1,1,2] = 1\nV1 = ℂ^2 # generic qubit hilbert space\nt1 = TensorMap(data, V1 ⊗ V1, V1 ⊗ V1)\nV2 = SU2Space(1/2=>1) # hilbert space of an actual spin-1/2 particle, respecting symmetry\nt2 = TensorMap(data, V2 ⊗ V2, V2 ⊗ V2)\nV3 = U1Space(1/2=>1,-1/2=>1) # restricted space that only uses the `σ_z` rotation symmetry\nt3 = TensorMap(data, V3 ⊗ V3, V3 ⊗ V3)\nfor (c,b) in blocks(t3)\n    println(\"Data for block $c :\")\n    b |> disp\n    println()\nend","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, we recognize that the Heisenberg interaction has eigenvalue -1 in the coupled spin zero sector (SUIrrep(0)), and eigenvalue +1 in the coupled spin 1 sector (SU2Irrep(1)). Using Irrep[U₁] instead, we observe that both coupled charge U1Irrep(+1) and U1Irrep(-1) have eigenvalue +1. The coupled charge U1Irrep(0) sector is two-dimensional, and has an eigenvalue +1 and an eigenvalue -1.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To construct the proper data in more complicated cases, one has to know where to find each sector in the range 1:dim(V) of every index i with associated space V, as well as the internal structure of the representation space when the corresponding sector c has dim(c)>1, i.e. in the case of FusionStyle(c) isa NonAbelian. Currently, the only non- abelian sectors are Irrep[SU₂] and Irrep[CU₁], for which the internal structure is the natural one.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are some tools available to facilate finding the proper range of sector c in space V, namely axes(V, c). This also works on a ProductSpace, with a tuple of sectors. An example","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V = SU2Space(0=>3, 1=>2, 2=>1)\nP = V ⊗ V ⊗ V\naxes(P, (SU2Irrep(1), SU2Irrep(0), SU2Irrep(2)))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the length of the range is the degeneracy dimension of that sector, times the dimension of the internal representation space, i.e. the quantum dimension of that sector.","category":"page"},{"location":"man/tensors/#Constructing-similar-tensors","page":"Tensors and the TensorMap type","title":"Constructing similar tensors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A third way to construct a TensorMap instance is to use Base.similar, i.e.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"similar(t [, T::Type{<:Number}, codomain, domain])","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where T is a possibly different eltype for the tensor data, and codomain and domain optionally define a new codomain and domain for the resulting tensor. By default, these values just take the value from the input tensor t. The result will be a new TensorMap instance, with undef data, but whose data is stored in the same subtype of DenseMatrix (e.g. Matrix or CuMatrix or ...) as t. In particular, this uses the methods storagetype(t) and TensorKit.similarstoragetype(t, T).","category":"page"},{"location":"man/tensors/#Special-purpose-constructors","page":"Tensors and the TensorMap type","title":"Special purpose constructors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, there are methods zero, one, id, isomorphism, unitary and isometry to create specific new tensors. Tensor maps behave as vectors and can be added (if they have the same domain and codomain); zero(t) is the additive identity, i.e. a TensorMap instance where all entries are zero. For a t::TensorMap with domain(t) == codomain(t), i.e. an endomorphism, one(t) creates the identity tensor, i.e. the identity under composition. As discussed in the section on linear algebra operations, we denote composition of tensor maps with the mutliplication operator *, such that one(t) is the multiplicative identity. Similarly, it can be created as id(V) with V the relevant vector space, e.g. one(t) == id(domain(t)). The identity tensor is currently represented with dense data, and one can use id(A::Type{<:DenseMatrix}, V) to specify the type of DenseMatrix (and its eltype), e.g. A = Matrix{Float64}. Finally, it often occurs that we want to construct a specific isomorphism between two spaces that are isomorphic but not equal, and for which there is no canonical choice. Hereto, one can use the method u = isomorphism([A::Type{<:DenseMatrix}, ] codomain, domain), which will explicitly check that the domain and codomain are isomorphic, and return an error otherwise. Again, an optional first argument can be given to specify the specific type of DenseMatrix that is currently used to store the rather trivial data of this tensor. If spacetype(u) <: EuclideanSpace, the same result can be obtained with the method u = unitary([A::Type{<:DenseMatrix}, ] codomain, domain). Note that reversing the domain and codomain yields the inverse morphism, which in the case of EuclideanSpace coincides with the adjoint morphism, i.e. isomorphism(A, domain, codomain) == adjoint(u) == inv(u), where inv and adjoint will be further discussed below. Finally, if two spaces V1 and V2 are such that V2 can be embedded in V1, i.e. there exists an inclusion with a left inverse, and furthermore they represent tensor products of some EuclideanSpace, the function w = isometry([A::Type{<:DenseMatrix}, ], V1, V2) creates one specific isometric embedding, such that adjoint(w)*w == id(V2) and w*adjoint(w) is some hermitian idempotent (a.k.a. orthogonal projector) acting on V1. An error will be thrown if such a map cannot be constructed for the given domain and codomain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's conclude this section with some examples with GradedSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = ℤ₂Space(0=>3,1=>2)\nV2 = ℤ₂Space(0=>2,1=>1)\n# First a `TensorMap{ℤ₂Space, 1, 1}`\nm = TensorMap(randn, V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[ℤ₂](0)) |> disp\nblock(m, Irrep[ℤ₂](1)) |> disp\n# Now a `TensorMap{ℤ₂Space, 2, 2}`\nt = TensorMap(randn, V1 ⊗ V1, V2 ⊗ V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu'*u ≈ I ≈ v'*v\n(u'*matrix*v) |> disp\n# compare with:\nblock(t, Z2Irrep(0)) |> disp\nblock(t, Z2Irrep(1)) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Here, we illustrated some additional concepts. Firstly, note that we convert a TensorMap to an Array. This only works when sectortype(t) supports fusiontensor, and in particular when BraidingStyle(sectortype(t)) == Bosonic(), e.g. the case of trivial tensors (the category mathbfVect) and group representations (the category mathbfRep_mathsfG, which can be interpreted as a subcategory of mathbfVect). Here, we are in this case with mathsfG = ℤ₂. For a TensorMap{S,1,1}, the blocks directly correspond to the diagonal blocks in the block diagonal structure of its representation as an Array, there is no basis transform in between. This is no longer the case for TensorMap{S,N₁,N₂} with different values of N₁ and N₂. Here, we use the operation fuse(V), which creates an ElementarySpace which is isomorphic to a given space V (of type ProductSpace or ElementarySpace). The specific map between those two spaces constructed using the specific method unitary implements precisely the basis change from the product basis to the coupled basis. In this case, for a group G with FusionStyle(Irrep[G]) isa Abelian, it is a permutation matrix. Specifically choosing V equal to the codomain and domain of t, we can construct the explicit basis transforms that bring t into block diagonal form.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's repeat the same exercise for I = Irrep[SU₂], which has FusionStyle(I) isa NonAbelian.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = SU₂Space(0=>2,1=>1)\nV2 = SU₂Space(0=>1,1=>1)\n# First a `TensorMap{SU₂Space, 1, 1}`\nm = TensorMap(randn, V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[SU₂](0)) |> disp\nblock(m, Irrep[SU₂](1)) |> disp\n# Now a `TensorMap{SU₂Space, 2, 2}`\nt = TensorMap(randn, V1 ⊗ V1, V2 ⊗ V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu'*u ≈ I ≈ v'*v\n(u'*matrix*v) |> disp\n# compare with:\nblock(t, SU2Irrep(0)) |> disp\nblock(t, SU2Irrep(1)) |> disp\nblock(t, SU2Irrep(2)) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the basis transforms u and v are no longer permutation matrices, but are still unitary. Furthermore, note that they render the tensor block diagonal, but that now every element of the diagonal blocks labeled by c comes itself in a tensor product with an identity matrix of size dim(c), i.e. dim(SU2Irrep(1)) = 3 and dim(SU2Irrep(2)) = 5.","category":"page"},{"location":"man/tensors/#ss_tensor_properties","page":"Tensors and the TensorMap type","title":"Tensor properties","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Given a t::AbstractTensorMap{S,N₁,N₂}, there are various methods to query its properties. The most important are clearly codomain(t) and domain(t). For t::AbstractTensor{S,N}, i.e. t::AbstractTensorMap{S,N,0}, we can use space(t) as synonym for codomain(t). However, for a general AbstractTensorMap this has no meaning. However, we can query space(t, i), the space associated with the ith index. For i ∈ 1:N₁, this corresponds to codomain(t, i) = codomain(t)[i]. For j = i-N₁ ∈ (1:N₂), this corresponds to dual(domain(t, j)) = dual(domain(t)[j]).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The total number of indices, i.e. N₁+N₂, is given by numind(t), with N₁ == numout(t) and N₂ == numin(t), the number of outgoing and incoming indices. There are also the unexported methods TensorKit.codomainind(t) and TensorKit.domainind(t) which return the tuples (1, 2, …, N₁) and (N₁+1, …, N₁+N₂), and are useful for internal purposes. The type parameter S<:ElementarySpace can be obtained as spacetype(t); the corresponding sector can directly obtained as sectortype(t) and is Trivial when S != GradedSpace. The underlying field scalars of S can also directly be obtained as field(t). This is different from eltype(t), which returns the type of Number in the tensor data, i.e. the type parameter T in the (subtype of) DenseMatrix{T} in which the matrix blocks are stored. Note that during construction, a (one-time) warning is printed if !(T ⊂ field(S)). The specific DenseMatrix{T} subtype in which the tensor data is stored is obtained as storagetype(t). Each of the methods numind, numout, numin, TensorKit.codomainind, TensorKit.domainind, spacetype, sectortype, field, eltype and storagetype work in the type domain as well, i.e. they are encoded in typeof(t).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, there are methods to probe the data, which we already encountered. blocksectors(t) returns an iterator over the different coupled sectors that can be obtained from fusing the uncoupled sectors available in the domain, but they must also be obtained from fusing the uncoupled sectors available in the codomain (i.e. it is the intersection of both blocksectors(codomain(t)) and blocksectors(domain(t))). For a specific sector c ∈ blocksectors(t), block(t, c) returns the corresponding data. Both are obtained together with blocks(t), which returns an iterator over the pairs c=>block(t, c). Furthermore, there is fusiontrees(t) which returns an iterator over splitting-fusion tree pairs (f₁,f₂), for which the corresponding data is given by t[f₁,f₂] (i.e. using Base.getindex).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's again illustrate these methods with an example, continuing with the tensor t from the previous example","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"typeof(t)\ncodomain(t)\ndomain(t)\nspace(t,1)\nspace(t,2)\nspace(t,3)\nspace(t,4)\nnumind(t)\nnumout(t)\nnumin(t)\nspacetype(t)\nsectortype(t)\nfield(t)\neltype(t)\nstoragetype(t)\nblocksectors(t)\nblocks(t)\nblock(t, first(blocksectors(t)))\nfusiontrees(t)\nf1, f2 = first(fusiontrees(t))\nt[f1,f2]","category":"page"},{"location":"man/tensors/#ss_tensor_readwrite","page":"Tensors and the TensorMap type","title":"Reading and writing tensors: Dict conversion","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are no custom or dedicated methods for reading, writing or storing TensorMaps, however, there is the possibility to convert a t::AbstractTensorMap into a Dict, simply as convert(Dict, t). The backward conversion convert(TensorMap, dict) will return a tensor that is equal to t, i.e. t == convert(TensorMap, convert(Dict, t)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"This conversion relies on that the string represenation of objects such as VectorSpace, FusionTree or Sector should be such that it represents valid code to recreate the object. Hence, we store information about the domain and codomain of the tensor, and the sector associated with each data block, as a String obtained with repr. This provides the flexibility to still change the internal structure of such objects, without this breaking the ability to load older data files. The resulting dictionary can then be stored using any of the provided Julia packages such as JLD.jl, JLD2.jl, BSON.jl, JSON.jl, ...","category":"page"},{"location":"man/tensors/#ss_tensor_linalg","page":"Tensors and the TensorMap type","title":"Vector space and linear algebra operations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"AbstractTensorMap instances t represent linear maps, i.e. homomorphisms in a 𝕜-linear category, just like matrices. To a large extent, they follow the interface of Matrix in Julia's LinearAlgebra standard library. Many methods from LinearAlgebra are (re)exported by TensorKit.jl, and can then us be used without using LinearAlgebra explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks (typically using the same method) and never needs to perform any basis transforms.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In particular, AbstractTensorMap instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in t = t1*t2, which is also used for matrix multiplication. TensorKit.jl also supports (and exports) the mutating method mul!(t, t1, t2). We can then also try to invert a tensor map using inv(t), though this can only exist if the domain and codomain are isomorphic, which can e.g. be checked as fuse(codomain(t)) == fuse(domain(t)). If the inverse is composed with another tensor t2, we can use the syntax t1\\t2 or t2/t1. However, this syntax also accepts instances t1 whose domain and codomain are not isomorphic, and then amounts to pinv(t1), the Moore-Penrose pseudoinverse. This, however, is only really justified as minimizing the least squares problem if spacetype(t) <: EuclideanSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"AbstractTensorMap instances behave themselves as vectors (i.e. they are 𝕜-linear) and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other. There is also a zero(t), the additive identity, which produces a zero tensor with the same domain and codomain as t. In addition, TensorMap supports basic Julia methods such as fill! and copyto!, as well as copy(t) to create a copy with independent data. Aside from basic + and * operations, TensorKit.jl reexports a number of efficient in-place methods from LinearAlgebra, such as axpy! (for y ← α * x + y), axpby! (for y ← α * x + β * y), lmul! and rmul! (for y ← α*y and y ← y*α, which is typically the same) and mul!, which can also be used for out-of-place scalar multiplication y ← α*x.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For t::AbstractTensorMap{S} where S<:EuclideanSpace, henceforth referred to as a (Abstract)EuclideanTensorMap, we can compute norm(t), and for two such instances, the inner product dot(t1, t2), provided t1 and t2 have the same domain and codomain. Furthermore, there is normalize(t) and normalize!(t) to return a scaled version of t with unit norm. These operations should also exist for S<:InnerProductSpace, but requires an interface for defining a custom inner product in these spaces. Currently, there is no concrete subtype of InnerProductSpace that is not a subtype of EuclideanSpace. In particular, CartesianSpace, ComplexSpace and GradedSpace are all subtypes of EuclideanSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"With instances t::AbstractEuclideanTensorMap there is associated an adjoint operation, given by adjoint(t) or simply t', such that domain(t') == codomain(t) and codomain(t') == domain(t). Note that for an instance t::TensorMap{S,N₁,N₂}, t' is simply stored in a wrapper called AdjointTensorMap{S,N₂,N₁}, which is another subtype of AbstractTensorMap. This should be mostly unvisible to the user, as all methods should work for this type as well. It can be hard to reason about the index order of t', i.e. index i of t appears in t' at index position j = TensorKit.adjointtensorindex(t, i), where the latter method is typically not necessary and hence unexported. There is also a plural TensorKit.adjointtensorindices to convert multiple indices at once. Note that, because the adjoint interchanges domain and codomain, we have space(t', j) == space(t, i)'.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"AbstractTensorMap instances can furthermore be tested for exact (t1 == t2) or approximate (t1 ≈ t2) equality, though the latter requires norm can be computed.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When tensor map instances are endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as one(t) or one!(t), where the latter overwrites the contents of t. The multiplicative identity on a space V can also be obtained using id(A, V) as discussed above, such that for a general homomorphism t′, we have t′ == id(codomain(t′))*t′ == t′*id(domain(t′)). Returning to the case of endomorphisms t, we can compute the trace via tr(t) and exponentiate them using exp(t), or if the contents of t can be destroyed in the process, exp!(t). Furthermore, there are a number of tensor factorizations for both endomorphisms and general homomorphism that we discuss below.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, there are a number of operations that also belong in this paragraph because of their analogy to common matrix operations. The tensor product of two TensorMap instances t1 and t2 is obtained as t1 ⊗ t2 and results in a new TensorMap with codomain(t1⊗t2) = codomain(t1) ⊗ codomain(t2) and domain(t1⊗t2) = domain(t1) ⊗ domain(t2). If we have two TensorMap{S,N,1} instances t1 and t2 with the same codomain, we can combine them in a way that is analoguous to hcat, i.e. we stack them such that the new tensor catdomain(t1, t2) has also the same codomain, but has a domain which is domain(t1) ⊕ domain(t2). Similarly, if t1 and t2 are of type TensorMap{S,1,N} and have the same domain, the operation catcodomain(t1, t2) results in a new tensor with the same domain and a codomain given by codomain(t1) ⊕ codomain(t2), which is the analogy of vcat. Note that direct sum only makes sense between ElementarySpace objects, i.e. there is no way to give a tensor product meaning to a direct sum of tensor product spaces.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Time for some more examples:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"t == t + zero(t) == t*id(domain(t)) == id(codomain(t))*t\nt2 = TensorMap(randn, ComplexF64, codomain(t), domain(t));\ndot(t2, t)\ntr(t2'*t)\ndot(t2, t) ≈ dot(t', t2')\ndot(t2, t2)\nnorm(t2)^2\nt3 = copyto!(similar(t, ComplexF64), t);\nt3 == t\nrmul!(t3, 0.8);\nt3 ≈ 0.8*t\naxpby!(0.5, t2, 1.3im, t3);\nt3 ≈ 0.5 * t2  +  0.8 * 1.3im * t\nt4 = TensorMap(randn, fuse(codomain(t)), codomain(t));\nt5 = TensorMap(undef, fuse(codomain(t)), domain(t));\nmul!(t5, t4, t) == t4*t\ninv(t4) * t4 ≈ id(codomain(t))\nt4 * inv(t4) ≈ id(fuse(codomain(t)))\nt4 \\ (t4 * t) ≈ t\nt6 = TensorMap(randn, ComplexF64, V1, codomain(t));\nnumout(t4) == numout(t6) == 1\nt7 = catcodomain(t4, t6);\nforeach(println, (codomain(t4), codomain(t6), codomain(t7)))\nnorm(t7) ≈ sqrt(norm(t4)^2 + norm(t6)^2)\nt8 = t4 ⊗ t6;\nforeach(println, (codomain(t4), codomain(t6), codomain(t8)))\nforeach(println, (domain(t4), domain(t6), domain(t8)))\nnorm(t8) ≈ norm(t4)*norm(t6)","category":"page"},{"location":"man/tensors/#Index-manipulations","page":"Tensors and the TensorMap type","title":"Index manipulations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In many cases, the bipartition of tensor indices (i.e. ElementarySpace instances) between the codomain and domain is not fixed throughout the different operations that need to be performed on that tensor map, i.e. we want to use the duality to move spaces from domain to codomain and vice versa. Furthermore, we want to use the braiding to reshuffle the order of the indices.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For this, we use an interface that is closely related to that for manipulating splitting- fusion tree pairs, namely braid and permute, with the interface","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"braid(t::AbstractTensorMap{S,N₁,N₂}, levels::NTuple{N₁+N₂,Int},\n        p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"permute(t::AbstractTensorMap{S,N₁,N₂},\n        p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int}; copy = false)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"both of which return an instance of AbstractTensorMap{S,N₁′,N₂′}.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In these methods, p1 and p2 specify which of the original tensor indices ranging from 1 to N₁+N₂ make up the new codomain (with N₁′ spaces) and new domain (with N₂′ spaces). Hence, (p1..., p2...) should be a valid permutation of 1:(N₁+N₂). Note that, throughout TensorKit.jl, permutations are always specified using tuples of Ints, for reasons of type stability. For braid, we also need to specify levels or depths for each of the indices of the original tensor, which determine whether indices will braid over or underneath each other (use the braiding or its inverse). We refer to the section on manipulating fusion trees for more details.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When BraidingStyle(sectortype(t)) isa SymmetricBraiding, we can use the simpler interface of permute, which does not require the argument levels. permute accepts a keyword argument copy. When copy == true, the result will be a tensor with newly allocated data that can independently be modified from that of the input tensor t. When copy takes the default value false, permute can try to return the result in a way that it shares its data with the input tensor t, though this is only possible in specific cases (e.g. when sectortype(S) == Trivial and (p1..., p2...) = (1:(N₁+N₂)...)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Both braid and permute come in a version where the result is stored in an already existing tensor, i.e. braid!(tdst, tsrc, levels, p1, p2) and permute!(tdst, tsrc, p1, p2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Another operation that belongs und index manipulations is taking the transpose of a tensor, i.e. LinearAlgebra.transpose(t) and LinearAlgebra.transpose!(tdst, tsrc), both of which are reexported by TensorKit.jl. Note that transpose(t) is not simply equal to reshuffling domain and codomain with braid(t, (1:(N₁+N₂)...), reverse(domainind(tsrc)), reverse(codomainind(tsrc)))). Indeed, the graphical representation (where we draw the codomain and domain as a single object), makes clear that this introduces an additional (inverse) twist, which is then compensated in the transpose implementation.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: transpose)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In categorical language, the reason for this extra twist is that we use the left coevaluation η, but the right evaluation tildeϵ, when repartitioning the indices between domain and codomain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are a number of other index related manipulations. We can apply a twist (or inverse twist) to one of the tensor map indices via twist(t, i; inv = false) or twist!(t, i; inv = false). Note that the latter method does not store the result in a new destination tensor, but just modifies the tensor t in place. Twisting several indices simultaneously can be obtained by using the defining property","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"θ_VW = τ_WV  (θ_W  θ_V)  τ_VW = (θ_V  θ_W)  τ_WV  τ_VW","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"but is currently not implemented explicitly.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For all sector types I with BraidingStyle(I) == Bosonic(), all twists are 1 and thus have no effect. Let us start with some examples, in which we illustrate that, albeit permute might act highly non-trivial on the fusion trees and on the corresponding data, after conversion to a regular Array (when possible), it just acts like permutedims","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"domain(t) → codomain(t)\nta = convert(Array, t);\nt′ = permute(t, (1,2,3,4));\ndomain(t′) → codomain(t′)\nconvert(Array, t′) ≈ ta\nt′′ = permute(t, (4,2,3),(1,));\ndomain(t′′) → codomain(t′′)\nconvert(Array, t′′) ≈ permutedims(ta, (4,2,3,1))\nm\ntranspose(m)\nconvert(Array, transpose(t)) ≈ permutedims(ta,(4,3,2,1))\ndot(t2, t) ≈ dot(transpose(t2), transpose(t))\ntranspose(transpose(t)) ≈ t\ntwist(t, 3) ≈ t\n# as twist acts trivially for\nBraidingStyle(sectortype(t))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that transpose acts like one would expect on a TensorMap{S,1,1}. On a TensorMap{S,N₁,N₂}, because transpose replaces the codomain with the dual of the domain, which has its tensor product operation reversed, this in the end amounts in a complete reversal of all tensor indices when representing it as a plain mutli-dimensional Array. Also, note that we have not defined the conjugation of TensorMap instances. One definition that one could think of is conj(t) = adjoint(transpose(t)). However note that codomain(adjoint(tranpose(t))) == domain(transpose(t)) == dual(codomain(t)) and similarly domain(adjoint(tranpose(t))) == dual(domain(t)), where dual of a ProductSpace is composed of the dual of the ElementarySpace instances, in reverse order of tensor product. This might be very confusing, and as such we leave tensor conjugation undefined. However, note that we have a conjugation syntax within the context of tensor contractions.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To show the effect of twist, we now consider a type of sector I for which BraidingStyle{I} != Bosonic(). In particular, we use FibonacciAnyon. We cannot convert the resulting TensorMap to an Array, so we have to rely on indirect tests to verify our results.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = GradedSpace{FibonacciAnyon}(:I=>3,:τ=>2)\nV2 = GradedSpace{FibonacciAnyon}(:I=>2,:τ=>1)\nm = TensorMap(randn, Float32, V1, V2)\ntranspose(m)\ntwist(braid(m, (1,2), (2,), (1,)), 1)\nt1 = TensorMap(randn, V1*V2', V2*V1);\nt2 = TensorMap(randn, ComplexF64, V1*V2', V2*V1);\ndot(t1, t2) ≈ dot(transpose(t1), transpose(t2))\ntranspose(transpose(t1)) ≈ t1","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A final operation that one might expect in this section is to fuse or join indices, and its inverse, to split a given index into two or more indices. For a plain tensor (i.e. with sectortype(t) == Trivial) amount to the equivalent of reshape on the multidimensional data. However, this represents only one possibility, as there is no canonically unique way to embed the tensor product of two spaces V₁ ⊗ V₂ in a new space V = fuse(V₁⊗V₂). Such a mapping can always be accompagnied by a basis transform. However, one particular choice is created by the function isomorphism, or for EuclideanSpace spaces, unitary. Hence, we can join or fuse two indices of a tensor by first constructing u = unitary(fuse(space(t, i) ⊗ space(t, j)), space(t, i) ⊗ space(t, j)) and then contracting this map with indices i and j of t, as explained in the section on contracting tensors. Note, however, that a typical algorithm is not expected to often need to fuse and split indices, as e.g. tensor factorizations can easily be applied without needing to reshape or fuse indices first, as explained in the next section.","category":"page"},{"location":"man/tensors/#ss_tensor_factorization","page":"Tensors and the TensorMap type","title":"Tensor factorizations","text":"","category":"section"},{"location":"man/tensors/#Eigenvalue-decomposition","page":"Tensors and the TensorMap type","title":"Eigenvalue decomposition","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"As tensors are linear maps, they have various kinds of factorizations. Endomorphism, i.e. tensor maps t with codomain(t) == domain(t), have an eigenvalue decomposition. For this, we overload both LinearAlgebra.eigen(t; kwargs...) and LinearAlgebra.eigen!(t; kwargs...), where the latter destroys t in the process. The keyword arguments are the same that are accepted by LinearAlgebra.eigen(!) for matrices. The result is returned as D, V = eigen(t), such that t*V ≈ V*D. For given t::TensorMap{S,N,N}, V is a TensorMap{S,N,1}, whose codomain corresponds to that of t, but whose domain is a single space S (or more correctly a ProductSpace{S,1}), that corresponds to fuse(codomain(t)). The eigenvalues are encoded in D, a TensorMap{S,1,1}, whose domain and codomain correspond to the domain of V. Indeed, we cannot reasonably associate a tensor product structure with the different eigenvalues. Note that D stores the eigenvalues on the diagonal of a (collection of) DenseMatrix instance(s), as there is currently no dedicated DiagonalTensorMap or diagonal storage support.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"We also define LinearAlgebra.ishermitian(t), which can only return true for instances of AbstractEuclideanTensorMap. In all other cases, as the inner product is not defined, there is no notion of hermiticity (i.e. we are not working in a †-category). For instances of EuclideanTensorMap, we also define and export the routines eigh and eigh!, which compute the eigenvalue decomposition under the guarantee (not checked) that the map is hermitian. Hence, eigenvalues will be real and V will be unitary with eltype(V) == eltype(t). We also define and export eig and eig!, which similarly assume that the TensorMap is not hermitian (hence this does not require EuclideanTensorMap), and always returns complex values eigenvalues and eigenvectors. Like for matrices, LinearAlgebra.eigen is type unstable and checks hermiticity at run-time, then falling back to either eig or eigh.","category":"page"},{"location":"man/tensors/#Orthogonal-factorizations","page":"Tensors and the TensorMap type","title":"Orthogonal factorizations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Other factorizations that are provided by TensorKit.jl are orthogonal or unitary in nature, and thus always require a AbstractEuclideanTensorMap. However, they don't require equal domain and codomain. Let us first discuss the singular value decomposition, for which we define and export the methods tsvd and tsvd! (where as always, the latter destroys the input).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"U, Σ, Vʰ, ϵ = tsvd(t; trunc = notrunc(), p::Real = 2,\n                        alg::OrthogonalFactorizationAlgorithm = SDD())","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"This computes a (possibly truncated) singular value decomposition of t::TensorMap{S,N₁,N₂} (with S<:EuclideanSpace), such that norm(t - U*Σ*Vʰ) ≈ ϵ, where U::TensorMap{S,N₁,1}, S::TensorMap{S,1,1}, Vʰ::TensorMap{S,1,N₂} and ϵ::Real. U is an isometry, i.e. U'*U approximates the identity, whereas U*U' is an idempotent (squares to itself). The same holds for adjoint(Vʰ). The domain of U equals the domain and codomain of Σ and the codomain of Vʰ. In the case of trunc = notrunc() (default value, see below), this space is given by min(fuse(codomain(t)), fuse(domain(t))). The singular values are contained in Σ and are stored on the diagonal of a (collection of) DenseMatrix instance(s), similar to the eigenvalues before.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The keyword argument trunc provides a way to control the truncation, and is connected to the keyword argument p. The default value notrunc() implies no truncation, and thus ϵ = 0. Other valid options are","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"truncerr(η::Real): truncates such that the p-norm of the truncated singular values   is smaller than η times the p-norm of all singular values;\ntruncdim(χ::Integer): finds the optimal truncation such that the equivalent total   dimension of the internal vector space is no larger than χ;\ntruncspace(W): truncates such that the dimension of the internal vector space is   smaller than that of W in any sector, i.e. with   W₀ = min(fuse(codomain(t)), fuse(domain(t))) this option will result in   domain(U) == domain(Σ) == codomain(Σ) == codomain(Vᵈ) == min(W, W₀);\ntrunbelow(η::Real): truncates such that every singular value is larger then η; this   is different from truncerr(η) with p = Inf because it works in absolute rather than   relative values.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Furthermore, the alg keyword can be either SVD() or SDD() (default), which corresponds to two different algorithms in LAPACK to compute singular value decompositions. The default value SDD() uses a divide-and-conquer algorithm and is typically the fastest, but can loose some accuracy. The SVD() method uses a QR-iteration scheme and can be more accurate, but is typically slower. Since Julia 1.3, these two algorithms are also available in the LinearAlgebra standard library, where they are specified as LinearAlgebra.DivideAndConquer() and LinearAlgebra.QRIteration().","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that we defined the new method tsvd (truncated or tensor singular value decomposition), rather than overloading LinearAlgebra.svd. We (will) also support LinearAlgebra.svd(t) as alternative for tsvd(t; trunc = notrunc()), but note that the return values are then given by U, Σ, V = svd(t) with V = adjoint(Vʰ).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"We also define the following pair of orthogonal factorization algorithms, which are useful when one is not interested in truncating a tensor or knowing the singular values, but only in its image or coimage.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Q, R = leftorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos(), kwargs...):   this produces an isometry Q::TensorMap{S,N₁,1} (i.e. Q'*Q approximates the identity,   Q*Q' is an idempotent, i.e. squares to itself) and a general tensor map   R::TensorMap{1,N₂}, such that t ≈ Q*R. Here, the domain of Q and thus codomain of   R is a single vector space of type S that is typically given by   min(fuse(codomain(t)), fuse(domain(t))).\nThe underlying algorithm used to compute this decomposition can be chosen among QR(),   QRpos(), QL(), QLpos(), SVD(), SDD(), Polar(). QR() uses the underlying   qr decomposition from LinearAlgebra, while QRpos() (the default) adds a correction   to that to make sure that the diagonal elements of R are positive. Both result in   block matrices in R which are upper triangular. QL() and QLpos() similarly result   in a lower triangular block matrices in R, but only work if all block matrices are   tall, i.e. blockdim(codomain(t), c) >= blockdim(domain(t), c) for all c ∈   blocksectors(t). All of these methods assume t has full rank.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then set   Q=U and R=Σ*Vʰ from the corresponding singular value decomposition, where only   these singular values σ >= max(atol, norm(t)*rtol) (and corresponding singular vectors   in U) are kept. More finegrained control on the chosen singular values can be   obtained with tsvd and its trunc keyword.\nFinally, Polar() sets Q=U*Vʰ and R = (Vʰ)'*Σ*Vʰ, such that R is positive   definite; in this case SDD() is used to actually compute the singular value   decomposition and no atol or rtol can be provided.\nL, Q = rightorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos()):   this produces a general tensor map L::TensorMap{S,N₁,1} and the adjoint of an isometry   Q::TensorMap{S,1,N₂}, such that t ≈ L*Q. Here, the domain of L and thus codomain   of Q is a single vector space of type S that is typically given by   min(fuse(codomain(t)), fuse(domain(t))).\nThe underlying algorithm used to compute this decomposition can be chosen among LQ(),   LQpos(), RQ(), RQpos(), SVD(), SDD(), Polar(). LQ() uses the underlying   qr decomposition from LinearAlgebra on the transposed data, and leads to lower   triangular block matrices in L; LQpos() makes sure the diagonal elements are   positive. RQ() and RQpos() similarly result in upper triangular block matrices in   L, but only works for wide matrices, i.e. blockdim(codomain(t), c) <=   blockdim(domain(t), c) for all c ∈ blocksectors(t). All of these methods assume t   has full rank.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then set   L=U*Σ and Q=Vʰ from the corresponding singular value decomposition, where only these   singular values σ >= max(atol, norm(t)*rtol) (and corresponding singular vectors in   Vʰ) are kept. More finegrained control on the chosen singular values can be obtained   with tsvd and its trunc keyword.\nFinally, Polar() sets L = U*Σ*U' and Q=U*Vʰ, such that L is positive definite;   in this case SDD() is used to actually compute the singular value decomposition and no   atol or rtol can be provided.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Furthermore, we can compute an orthonormal basis for the orthogonal complement of the image and of the co-image (i.e. the kernel) with the following methods:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"N = leftnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...):   returns an isometric TensorMap{S,N₁,1} (i.e. N'*N approximates the identity) such   that N'*t is approximately zero.\nHere, alg can be QR() (QRpos() acts identically in this case), which assumes that   t is full rank in all of its blocks and only returns an orthonormal basis for the   missing columns.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then   construct N from the left singular vectors corresponding to singular values   σ < max(atol, norm(t)*rtol).\nN = rightnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...):   returns a TensorMap{S,1,N₂} with isometric adjoint (i.e. N*N' approximates the   identity) such that t*N' is approximately zero.\nHere, alg can be LQ() (LQpos() acts identically in this case), which assumes that   t is full rank in all of its blocks and only returns an orthonormal basis for the   missing rows.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then   construct N from the right singular vectors corresponding to singular values   σ < max(atol, norm(t)*rtol).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the methods leftorth, rightorth, leftnull and rightnull also come in a form with exclamation mark, i.e. leftorth!, rightorth!, leftnull! and rightnull!, which destroy the input tensor t.","category":"page"},{"location":"man/tensors/#Factorizations-for-custom-index-bipartions","page":"Tensors and the TensorMap type","title":"Factorizations for custom index bipartions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, note that each of the factorizations take a single argument, the tensor map t, and a number of keyword arguments. They perform the factorization according to the given codomain and domain of the tensor map. In many cases, we want to perform the factorization according to a different bipartition of the indices. When BraidingStyle(sectortype(t)) isa SymmetricBraiding, we can immediately specify an alternative bipartition of the indices of t in all of these methods, in the form","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"factorize(t::AbstracTensorMap, pleft::NTuple{N₁′,Int}, pright::NTuple{N₂′,Int}; kwargs...)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where pleft will be the indices in the codomain of the new tensor map, and pright the indices of the domain. Here, factorize is any of the methods LinearAlgebra.eigen, eig, eigh, tsvd, LinearAlgebra.svd, leftorth, rightorth, leftnull and rightnull. This signature does not allow for the exclamation mark, because it amounts to","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"factorize!(permute(t, pleft, pright; copy = true); kwargs...)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where permute was introduced and discussed in the previous section. When the braiding is not symmetric, the user should manually apply braid to bring the tensor map in proper form before performing the factorization.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples to conclude this section","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = SU₂Space(0=>2,1/2=>1)\nV2 = SU₂Space(0=>1,1/2=>1,1=>1)\n\nt = TensorMap(randn, V1 ⊗ V1, V2);\nU, S, W = tsvd(t);\nt ≈ U * S * W\nD, V = eigh(t'*t);\nD ≈ S*S\nU'*U ≈ id(domain(U))\nS\n\nQ, R = leftorth(t; alg = Polar());\nisposdef(R)\nQ ≈ U*W\nR ≈ W'*S*W\n\nU2, S2, W2, ε = tsvd(t; trunc = truncspace(V1));\nW2*W2' ≈ id(codomain(W2))\nS2\nε ≈ norm(block(S, Irrep[SU₂](1)))*sqrt(dim(Irrep[SU₂](1)))\n\nL, Q = rightorth(t, (1,), (2,3));\ncodomain(L), domain(L), domain(Q)\nQ*Q'\nP = Q'*Q;\nP ≈ P*P\nt′ = permute(t, (1,), (2,3));\nt′ ≈ t′ * P","category":"page"},{"location":"man/tensors/#ss_tensor_contraction","page":"Tensors and the TensorMap type","title":"Bosonic tensor contractions and tensor networks","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"One of the most important operation with tensor maps is to compose them, more generally known as contracting them. As mentioned in the section on category theory, a typical composition of maps in a ribbon category can graphically be represented as a planar arrangement of the morphisms (i.e. tensor maps, boxes with lines eminating from top and bottom, corresponding to source and target, i.e. domain and codomain), where the lines connecting the source and targets of the different morphisms should be thought of as ribbons, that can braid over or underneath each other, and that can twist. Technically, we can embed this diagram in ℝ  01 and attach all the unconnected line endings corresponding objects in the source at some position (x0) for xℝ, and all line endings corresponding to objects in the target at some position (x1). The resulting morphism is then invariant under what is known as framed three-dimensional isotopy, i.e. three-dimensional rearrangements of the morphism that respect the rules of boxes connected by ribbons whose open endings are kept fixed. Such a two-dimensional diagram cannot easily be encoded in a single line of code.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"However, things simplify when the braiding is symmetric (such that over- and under- crossings become equivalent, i.e. just crossings), and when twists, i.e. self-crossings in this case, are trivial. This amounts to BraidingStyle(I) == Bosonic() in the language of TensorKit.jl, and is true for any subcategory of mathbfVect, i.e. ordinary tensors, possibly with some symmetry constraint. The case of mathbfSVect and its subcategories, and more general categories, are discussed below.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In the case of triival twists, we can deform the diagram such that we first combine every morphism with a number of coevaluations η so as to represent it as a tensor, i.e. with a trivial domain. We can then rearrange the morphism to be all ligned up horizontally, where the original morphism compositions are now being performed by evaluations ϵ. This process will generate a number of crossings and twists, where the latter can be omitted because they act trivially. Similarly, double crossings can also be omitted. As a consequence, the diagram, or the morphism it represents, is completely specified by the tensors it is composed of, and which indices between the different tensors are connect, via the evaluation ϵ, and which indices make up the source and target of the resulting morphism. If we also compose the resulting morphisms with coevaluations so that it has a trivial domain, we just have one type of unconnected lines, henceforth called open indices. We sketch such a rearrangement in the following picture","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor unitary)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, we can now specify such a tensor diagram, henceforth called a tensor contraction or also tensor network, using a one-dimensional syntax that mimicks abstract index notation and specifies which indices are connected by the evaluation map using Einstein's summation conventation. Indeed, for BraidingStyle(I) == Bosonic(), such a tensor contraction can take the same format as if all tensors were just multi-dimensional arrays. For this, we rely on the interface provided by the package TensorOperations.jl.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The above picture would be encoded as","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[a,b,c,d,e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[:] := A[1,2,-4,3]*B[4,5,-3,3]*C[1,-5,4,-2]*D[-1,2,5]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where the latter syntax is known as NCON-style, and labels the unconnected or outgoing indices with negative integers, and the contracted indices with positive integers.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A number of remarks are in order. TensorOperations.jl accepts both integers and any valid variable name as dummy label for indices, and everything in between [ ] is not resolved in the current context but interpreted as a dummy label. Here, we label the indices of a TensorMap, like A::TensorMap{S,N₁,N₂}, in a linear fashion, where the first position corresponds to the first space in codomain(A), and so forth, up to position N₁. Index N₁+1then corresponds to the first space in domain(A). However, because we have applied the coevaluation η, it actually corresponds to the corresponding dual space, in accordance with the interface of space(A, i) that we introduced above, and as indiated by the dotted box around A in the above picture. The same holds for the other tensor maps. Note that our convention also requires that we braid indices that we brought from the domain to the codomain, and so this is only unambiguous for a symmetric braiding, where there is a unique way to permute the indices.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"With the current syntax, we create a new object E because we use the definition operator :=. Furthermore, with the current syntax, it will be a Tensor, i.e. it will have a trivial domain, and correspond to the dotted box in the picture above, rather than the actual morphism E. We can also directly define E with the correct codomain and domain by rather using","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[a b c;d e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[(a,b,c);(d,e)] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where the latter syntax can also be used when the codomain is empty. When using the assignment operator =, the TensorMap E is assumed to exist and the contents will be written to the currently allocated memory. Note that for existing tensors, both on the left hand side and right hand side, trying to specify the indices in the domain and the codomain seperately using the above syntax, has no effect, as the bipartition of indices are already fixed by the existing object. Hence, if E has been created by the previous line of code, all of the following lines are now equivalent","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[(a,b,c);(d,e)] = A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]\n@tensor E[a,b,c,d,e] = A[v w d;x]*B[(y,z,c);(x,)]*C[v e y; b]*D[a,w,z]\n@tensor E[a b; c d e] = A[v; w d x]*B[y,z,c,x]*C[v,e,y,b]*D[a w;z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and none of those will or can change the partition of the indices of E into its codomain and its domain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Two final remarks are in order. Firstly, the order of the tensors appearing on the right hand side is irrelevant, as we can reorder them by using the allowed moves of the Penrose graphical calculus, which yields some crossings and a twist. As the latter is trivial, it can be omitted, and we just use the same rules to evaluate the newly ordered tensor network. For the particular case of matrix matrix multiplication, which also captures more general settings by appropriotely combining spaces into a single line, we indeed find","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor contraction reorder)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or thus, the following to lines of code yield the same result","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor C[i,j] := B[i,k]*A[k,j]\n@tensor C[i,j] := A[k,j]*B[i,k]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Reordering of tensors can be used internally by the @tensor macro to evaluate the contraction in a more efficient manner. In particular, the NCON-style of specifying the contraction gives the user control over the order, and there are other macros, such as @tensoropt, that try to automate this process. There is also an @ncon macro and ncon function, an we recommend reading the manual of TensorOperations.jl to learn more about the possibilities and how they work.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A final remark involves the use of adjoints of tensors. The current framework is such that the user should not be to worried about the actual bipartition into codomain and domain of a given TensorMap instance. Indeed, for factorizations one just specifies the requested bipartition via the factorize(t, pleft, pright) interface, and for tensor contractions the @contract macro figures out the correct manipulations automatically. However, when wanting to use the adjoint of an instance t::TensorMap{S,N₁,N₂}, the resulting adjoint(t) is a AbstractTensorMap{S,N₂,N₁} and one need to know the values of N₁ and N₂ to know exactly where the ith index of t will end up in adjoint(t), and hence to know and understand the index order of t'. Within the @tensor macro, one can instead use conj() on the whole index expression so as to be able to use the original index ordering of t. Indeed, for matrices of thus, TensorMap{S,1,1} instances, this yields exactly the equivalence one expects, namely equivalence between the following to expressions.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor C[i,j] := B'[i,k]*A[k,j]\n@tensor C[i,j] := conj(B[k,i])*A[k,j]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For e.g. an instance A::TensorMap{S,3,2}, the following two syntaxes have the same effect within an @tensor expression: conj(A[a,b,c,d,e]) and A'[d,e,a,b,c].","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples:","category":"page"},{"location":"man/tensors/#Fermionic-tensor-contractions","page":"Tensors and the TensorMap type","title":"Fermionic tensor contractions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Anyonic-tensor-contractions","page":"Tensors and the TensorMap type","title":"Anyonic tensor contractions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/spaces/#s_spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"using TensorKit","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"From the Introduction, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type VectorSpace","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type VectorSpace end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"which is actually a too restricted name. All instances of subtypes of VectorSpace will represent objects in 𝕜-linear monoidal categories, but this can go beyond normal vector spaces (i.e. objects in the category mathbfVect) and even beyond objects of mathbfSVect. However, in order not to make the remaining discussion to abstract or complicated, we will simply refer to subtypes of VectorSpace instead of specific categories, and to spaces (i.e. VectorSpace instances) instead of objects from these categories. In particular, we define two abstract subtypes","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type ElementarySpace{𝕜} <: VectorSpace end\nconst IndexSpace = ElementarySpace\n\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Here, ElementarySpace is a super type for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace. It is parametrically dependent on 𝕜, the field of scalars (see the next section on Fields).","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"On the other hand, subtypes of CompositeSpace{S} where S<:ElementarySpace are composed of a number of elementary spaces of type S. So far, there is a single concrete type ProductSpace{S,N} that represents the homogeneous tensor product of N vector spaces of type S. Its properties are discussed in the section on Composite spaces, together with possible extensions for the future.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Throughout TensorKit.jl, the function spacetype returns the type of ElementarySpace associated with e.g. a composite space or a tensor. It works both on instances and in the type domain. Its use will be illustrated below.","category":"page"},{"location":"man/spaces/#ss_fields","page":"Vector spaces","title":"Fields","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces (linear categories) are defined over a field of scalars 𝕜. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type Field end\n\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\n\nconst ℝ = RealNumbers()\nconst ℂ = ComplexNumbers()","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that ℝ and ℂ can be typed as \\bbR+TAB and \\bbC+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia's Number hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"3 ∈ ℝ\n5.0 ∈ ℂ\n5.0+1.0*im ∈ ℝ\nFloat64 ⊆ ℝ\nComplexF64 ⊆ ℂ\nℝ ⊆ ℂ\nℂ ⊆ ℝ","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"and furthermore —probably more usefully— ℝ^n and ℂ^n create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor a can be obtained with field(a).","category":"page"},{"location":"man/spaces/#ss_elementaryspaces","page":"Vector spaces","title":"Elementary spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of ElementarySpace. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every ElementarySpace should implement the following methods","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dim(::ElementarySpace) -> ::Int returns the dimension of the space as an Int\ndual(::S) where {S<:ElementarySpace} -> ::S returns the   dual space dual(V), using an instance of   the same concrete type (i.e. not via type parameters); this should satisfy   dual(dual(V))==V\nconj(::S) where {S<:ElementarySpace} -> ::S returns the   complex conjugate space   conj(V), using an instance of the same concrete type (i.e. not via type parameters);   this should satisfy conj(conj(V))==V and we automatically have   conj(V::ElementarySpace{ℝ}) = V.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"For convenience, the dual of a space V can also be obtained as V'.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"There is concrete type GeneralSpace which is completely characterized by its field 𝕜, its dimension and whether its the dual and/or complex conjugate of 𝕜^d.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct GeneralSpace{𝕜} <: ElementarySpace{𝕜}\n    d::Int\n    dual::Bool\n    conj::Bool\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We furthermore define the abstract type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type InnerProductSpace{𝕜} <: ElementarySpace{𝕜} end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"to contain all vector spaces V which have an inner product and thus a canonical mapping from dual(V) to V (for 𝕜 ⊆ ℝ) or from dual(V) to conj(V) (otherwise). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Finally there is","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type EuclideanSpace{𝕜} <: InnerProductSpace{𝕜} end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"to contain all spaces V with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms dual(V) == V (for 𝕜 == ℝ) or dual(V) == conj(V) (for 𝕜 == ℂ). In the language of the previous section on categories, this subtype represents dagger or unitary categories, and support an adjoint operation. In particular, we have two concrete types","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct CartesianSpace <: EuclideanSpace{ℝ}\n    d::Int\nend\nstruct ComplexSpace <: EuclideanSpace{ℂ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"to represent the Euclidean spaces ℝ^d or ℂ^d without further inner structure. They can be created using the syntax CartesianSpace(d) == ℝ^d == ℝ[d] and ComplexSpace(d) == ℂ^d == ℂ[d], or ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (ℂ^d)' == ℂ[d]' for the dual space of the latter. Note that the brackets are required because of the precedence rules, since d' == d for d::Integer.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dim(ℝ^10)\n(ℝ^10)' == ℝ^10 == ℝ[10] == ℝ[](10)\nisdual((ℂ^5))\nisdual((ℂ^5)')\nisdual((ℝ^5)')\ndual(ℂ^5) == (ℂ^5)' == conj(ℂ^5) == ComplexSpace(5; dual = true)\ntypeof(ℝ^3)\nspacetype(ℝ^3)\nspacetype(ℝ[])","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that ℝ[] and ℂ[] are synonyms for CartesianSpace and ComplexSpace respectively, such that yet another syntax is e.g. ℂ[](d). This is not very useful in itself, and is motivated by its generalization to GradedSpace. We refer to the subsection on graded spaces on the next page for further information about GradedSpace, which is another subtype of EuclideanSpace{ℂ} with an inner structure corresponding to the irreducible representations of a group, or more generally, the simple objects of a fusion category.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"note: Note\nFor ℂ^n the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for ℂ^n, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more purist approach can be useful to detect errors (e.g. unintended contractions). Only with ℝ^n will their be no distinction between a space and its dual. When creating tensors with indices in ℝ^n that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.","category":"page"},{"location":"man/spaces/#ss_compositespaces","page":"Vector spaces","title":"Composite spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent (and currently only) example is a tensor product of N elementary spaces of the same type S, which is implemented as","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Given some V1::S, V2::S, V3::S of the same type S<:ElementarySpace, we can easily construct ProductSpace{S,3}((V1,V2,V3)) as ProductSpace(V1,V2,V3) or using V1 ⊗ V2 ⊗ V3, where ⊗ is simply obtained by typing \\otimes+TAB. In fact, for convenience, also the regular multiplication operator * acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"V1 = ℂ^2\nV2 = ℂ^3\nV1 ⊗ V2 ⊗ V1' == V1 * V2 * V1' == ProductSpace(V1,V2,V1') == ProductSpace(V1,V2) ⊗ V1'\nV1^3\ndim(V1 ⊗ V2)\ndims(V1 ⊗ V2)\ndual(V1 ⊗ V2)\nspacetype(V1 ⊗ V2)\nspacetype(ProductSpace{ComplexSpace,3})","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Here, the new function dims maps dim to the individual spaces in a ProductSpace and returns the result as a tuple. Note that the rationale for the last result was explained in the subsection on duality in the introduction to category theory.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Following Julia's Base library, the function one applied to a ProductSpace{S,N} returns the multiplicative identity, which is ProductSpace{S,0}(()). The same result is obtained when acting on an instance V of S::ElementarySpace directly, however note that V ⊗ one(V) will yield a ProductSpace{S,1}(V) and not V itself. The same result can be obtained with ⊗(V). Similar to Julia Base, one also works in the type domain.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In the future, other CompositeSpace types could be added. For example, the wave function of an N-particle quantum system in first quantization would require the introduction of a SymmetricSpace{S,N} or a AntiSymmetricSpace{S,N} for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of V^N, where V::S represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.","category":"page"},{"location":"man/spaces/#ss_homspaces","page":"Vector spaces","title":"Space of morphisms","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Given that we define tensor maps as morphisms in a 𝕜-linear monoidal category, i.e. linear maps, we also define a type to denote the corresponding space. Indeed, in a 𝕜-linear category C, the set of morphisms mathrmHom(WV) for VW  C is always an actual vector space, irrespective of whether or not C is a subcategory of mathbf(S)Vect.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We introduce the type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct HomSpace{S<:ElementarySpace, P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}\n    codomain::P1\n    domain::P2\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"and can create it as either domain → codomain or codomain ← domain (where the arrows are obtained as \\to+TAB or \\leftarrow+TAB, and as \\rightarrow+TAB respectively). The reason for first listing the codomain and than the domain will become clear in the section on tensor maps.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that HomSpace is not a subtype of VectorSpace, i.e. we restrict the latter to denote certain categories and their objects, and keep HomSpace distinct. However, HomSpace has a number of properties defined, which we illustrate via examples","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"W = ℂ^2 ⊗ ℂ^3 → ℂ^3 ⊗ dual(ℂ^4)\nfield(W)\ndual(W)\nadjoint(W)\nspacetype(W)\nspacetype(typeof(W))\nW[1]\nW[2]\nW[3]\nW[4]\ndim(W)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that indexing W yields first the spaces in the codomain, followed by the dual of the spaces in the domain. This particular convention is useful in combination with the instances of type TensorMap, which represent morphisms living in such a HomSpace. Also note that dim(W) here seems to be the product of the dimensions of the individual spaces, but that this is no longer true once symmetries are involved. At any time will dim(::HomSpace) represent the number of linearly independent morphisms in this space.","category":"page"},{"location":"man/spaces/#Partial-order-among-vector-spaces","page":"Vector spaces","title":"Partial order among vector spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces of the same spacetype can be given a partial order, based on whether there exist injective morphisms (a.k.a monomorphisms) or surjective morphisms (a.k.a. epimorphisms) between them. In particular, we define ismonomorphic(V1, V2), with Unicode synonym V1 ≾ V2 (obtained as \\precsim+TAB), to express whether there exist monomorphisms in V1→V2. Similarly, we define isepimorphic(V1, V2), with Unicode synonym V1 ≿ V2 (obtained as \\succsim+TAB), to express whether there exist epimorphisms in V1→V2. Finally, we define isisomorphic(V1, V2), with Unicode alternative V1 ≅ V2 (obtained as \\cong+TAB), to express whether there exist isomorphism in V1→V2. In particular V1 ≅ V2 if and only if V1 ≾ V2 && V1 ≿ V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"For completeness, we also export the strict comparison operators ≺ and ≻ (\\prec+TAB and \\succ+TAB), with definitions","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"≺(V1::VectorSpace, V2::VectorSpace) = V1 ≾ V2 && !(V1 ≿ V2)\n≻(V1::VectorSpace, V2::VectorSpace) = V1 ≿ V2 && !(V1 ≾ V2)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"However, as we expect these to be less commonly used, no ASCII alternative is provided.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In the context of spacetype(V) <: EuclideanSpace, V1 ≾ V2 implies that there exists isometries WV1  V2 such that W^  W = mathrmid_V1, while V1 ≅ V2 implies that there exist unitaries UV1V2 such that U^  U = mathrmid_V1 and U  U^ = mathrmid_V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of ProductSpace, while the other is an ElementarySpace. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"There are also a number of convenience functions to create isomorphic spaces. The function fuse(V1, V2, ...) or fuse(V1 ⊗ V2 ⊗ ...) returns an elementary space that is isomorphic to V1 ⊗ V2 ⊗ .... The function flip(V::ElementarySpace) returns a space that is isomorphic to V but has isdual(flip(V)) == isdual(V'), i.e. if V is a normal space than flip(V) is a dual space. flip(V) is different from dual(V) in the case of GradedSpace. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from V1 to flip(V1). We refer to Index operations for further information. Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"ℝ^3 ≾ ℝ^5\nℂ^3 ≾ (ℂ^5)'\n(ℂ^5) ≅ (ℂ^5)'\nfuse(ℝ^5, ℝ^3)\nfuse(ℂ^3, (ℂ^5)' ⊗ ℂ^2)\nfuse(ℂ^3, (ℂ^5)') ⊗ ℂ^2 ≅ fuse(ℂ^3, (ℂ^5)', ℂ^2) ≅ ℂ^3 ⊗ (ℂ^5)' ⊗ ℂ^2\nflip(ℂ^4)\nflip(ℂ^4) ≅ ℂ^4\nflip(ℂ^4) == ℂ^4","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We also define the direct sum V1 and V2 as V1 ⊕ V2, where ⊕ is obtained by typing \\oplus+TAB. This is possible only if isdual(V1) == isdual(V2). With a little pun on Julia Base, oneunit applied to an elementary space (in the value or type domain) returns the one-dimensional space, which is isomorphic to the scalar field of the space itself. Some examples illustrate this better","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"ℝ^5 ⊕ ℝ^3\nℂ^5 ⊕ ℂ^3\nℂ^5 ⊕ (ℂ^3)'\noneunit(ℝ^3)\nℂ^5 ⊕ oneunit(ComplexSpace)\noneunit((ℂ^3)')\n(ℂ^5) ⊕ oneunit((ℂ^5))\n(ℂ^5)' ⊕ oneunit((ℂ^5)')","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Finally, while spaces have a partial order, there is no unique infimum or supremum of a two or more spaces. However, if V1 and V2 are two ElementarySpace instances with isdual(V1) == isdual(V2), then we can define a unique infimum V::ElementarySpace with the same value of isdual that satisfies V ≾ V1 and V ≾ V2, as well as a unique supremum W::ElementarySpace with the same value of isdual that satisfies W ≿ V1 and W ≿ V2. For CartesianSpace and ComplexSpace, this simply amounts to the space with minimal or maximal dimension, i.e.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"infimum(ℝ^5, ℝ^3)\nsupremum(ℂ^5, ℂ^3)\nsupremum(ℂ^5, (ℂ^3)')","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The names infimum and supremum are especially suited in the case of GradedSpace, as the infimum of two spaces might be different from either of those two spaces, and similar for the supremum.","category":"page"},{"location":"man/sectors/#s_sectorsrepfusion","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"using TensorKit\nimport LinearAlgebra","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The corresponding vector spaces will be canonically represented as V = _a ℂ^n_a  R_a, where a labels the different irreps, n_a is the number of times irrep a appears and R_a is the vector space associated with irrep a. Irreps are also known as spin sectors (in the case of mathsfSU_2) or charge sectors (in the case of mathsfU_1), and we henceforth refer to a as a sector. As discussed in the section on categories, and briefly summarized below, the approach we follow does in fact go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a unitary ribbon fusion category. Nonetheless, every step can be appreciated by using the representation theory of mathsfSU_2 or mathsfSU_3 as example. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space V is completely specified by the values of n_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using (technically: equivariant) tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group's Clebsch–Gordan (CG) coefficients. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or 6j-symbols (more accurately, the F-symbol is actually Racah's W-coefficients in the case of mathsfSU_2).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space V composed of a direct sum of different sectors. In the third section, we explain the details of fusion trees, i.e. their construction and manipulation. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists. But first, we provide a quick theoretical overview of the required data of the representation theory of a group. We refer to the section on categories, and in particular the subsection on topological data of a unitary fusion category, for further details.","category":"page"},{"location":"man/sectors/#ss_representationtheory","page":"Sectors, representation spaces and fusion trees","title":"Representation theory and unitary fusion categories","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let the different irreps or sectors be labeled as a, b, c, … First and foremost, we need to specify the fusion rules a  b =  N^ab_c c with N^ab_c some non-negative integers. There should always exists a unique trivial sector u (called the identity object I or 1 in the language of categories) such that a  u = a = u  a. Furthermore, there should exist a unique sector bara such that N^abara_u = 1, whereas for all b neq bara, N^ab_u = 0. For unitary irreps of groups, bara corresponds to the complex conjugate of the representation a, or a representation isomorphic to it. For example, for the representations of mathsfSU_2, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. a = bara), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal but related by a similarity transform).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The meaning of the fusion rules is that the space of transformations R_a  R_b  R_c (or vice versa) has dimension N^ab_c. In particular, we assume the existence of a basis consisting of unitary tensor maps X^ab_cμ  R_c  R_a  R_b with μ = 1  N^ab_c such that","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X^ab_cμ)^ X^ab_cν = δ_μν mathrmid_R_c","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_μ = 1^N^ab_c X^ab_cμ (X^ab_cμ)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X^ab_cμ are the splitting tensors, their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e. acting on the multiplicity label μ = 1  N^ab_c. For mathsfSU_2, where N^ab_c is zero or one and the multiplicity labels are absent, the entries of X^ab_cμ are precisely given by the CG coefficients. The point is that we do not need to know the tensors X^ab_cμ explicitly, but only the topological data of (the representation category of) the group, which describes the following transformation:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation between (a  b)  c to a  (b  c):\n(X^ab_eμ  mathrmid_c)  X^ec_dν = _fκλ F^abc_d_eμν^fκλ (mathrmid_a  X^bc_fκ)  X^af_dλ\nBraiding or permuting as defined by   τ_ab R_a  R_b  R_b  R_a:   τ_R_aR_b  X^ab_cμ = _ν R^ab_c^ν_μ X^ba_cν","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The dimensions of the spaces R_a on which representation a acts are denoted as d_a and referred to as quantum dimensions. In particular d_u = 1 and d_a = d_bara. This information is also encoded in the F-symbol as d_a =  F^a bara a_a^u_u ^-1. Note that there are no multiplicity labels in that particular F-symbol as N^abara_u = 1.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There is a graphical representation associated with the fusion tensors and their manipulations, which we summarize here:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: summary)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As always, we refer to the subsection on topological data of a unitary fusion category for further details.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Finally, for the implementation, it will be useful to distinguish between an number of different possibilities regarding the fusion rules. If, for every a and b, there is a unique c such that a  b = c (i.e. N^ab_c = 1 and N^ab_c = 0 for all other c), the category is abelian. Indeed, the representations of a group have this property if and only if the group multiplication law is commutative. In that case, all spaces R_a associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all N^ab_c equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of mathsfSU_2, and those where some N^ab_c are larger than one, e.g. the representations of mathsfSU_3.","category":"page"},{"location":"man/sectors/#ss_sectors","page":"Sectors, representation spaces and fusion trees","title":"Sectors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We introduce a new abstract type to represent different possible sectors","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Sector end","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Any concrete subtype of Sector should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category, as reviewed in the subsections on fusion categories and their topological data within the introduction to category theory. Throughout TensorKit.jl, the method sectortype can be used to query the subtype of Sector associated with a particular object, i.e. a vector space, fusion tree, tensor map, or a sector. It works on both instances and in the type domain, and its use will be illustrated further on.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The minimal data to completely specify a type of sector are","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"the fusion rules, i.e. a  b =  N^ab_c c; this is implemented by a function   Nsymbol(a,b,c)\nthe list of fusion outputs from a  b; while this information is contained in   N^ab_c, it might be costly or impossible to iterate over all possible values of   c and test Nsymbol(a,b,c); instead we implement for a ⊗ b to return an iterable   object (e.g. tuple, array or a custom Julia type that listens to Base.iterate) and   which generates all c for which N^ab_c  0 (just once even if N^ab_c1)\nthe identity object u, such that a  u = a = u  a; this is implemented by the   function one(a) (and also in type domain) from Julia Base\nthe dual or conjugate representation overlinea for which   N^abara_u = 1; this is implemented by conj(a) from Julia Base;   dual(a) also works as alias, but conj(a) is the method that should be defined\nthe F-symbol or recoupling coefficients F^abc_d^f_e, implemented as the   function Fsymbol(a,b,c,d,e,f)\nthe R-symbol R^ab_c, implemented as the function Rsymbol(a,b,c)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For practical reasons, we also require some additional methods to be defined:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"isreal(::Type{<:Sector}) returns whether the topological data of this type of sector   is real-valued or not (in which case it is complex-valued). Note that this does not   necessarily require that the representation itself, or the Clebsch-Gordan coefficients,   are real. There is a fallback implementation that checks whether the F-symbol and R-symbol evaluated with all sectors equal to the identity sector have real eltype.\nhash(a, h) creates a hash of sectors, because sectors and objects created from them   are used as keys in lookup tables (i.e. dictionaries)\nisless(a,b) associates a canonical order to sectors (of the same type), in order to   unambiguously represent representation spaces V = _a ℂ^n_a  R_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Further information, such as the quantum dimensions d_a and Frobenius-Schur indicator χ_a (only if a == overlinea) are encoded in the F-symbol. They are obtained as dim(a) and frobeniusschur(a). These functions have default definitions which extract the requested data from Fsymbol(a,conj(a),a,a,one(a),one(a)), but they can be overloaded in case the value can be computed more efficiently.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We also define a parametric type to represent an indexable iterator over the different values of a sector as","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorValues{I<:Sector} end\nBase.IteratorEltype(::Type{<:SectorValues}) = HasEltype()\nBase.eltype(::Type{SectorValues{I}}) where {I<:Sector} = I\nBase.values(::Type{I}) where {I<:Sector} = SectorValues{I}()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that an instance of the singleton type SectorValues{I} is obtained as values(I). A new sector I<:Sector should define","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.iterate(::SectorValues{I}[, state]) = ...\nBase.IteratorSize(::Type{SectorValues{I}}) = # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::SectorValues{I}) = ...\nBase.getindex(::SectorValues{I}, i::Int) = ...\nfindindex(::SectorValues{I}, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If the number of values in a sector I is finite (i.e. IteratorSize(values(I)) == HasLength()), the methods getindex and findindex provide a way to map the different sector values from and to the standard range 1, 2, …, length(values(I)). This is used to efficiently represent GradedSpace objects for this type of sector, as discussed in the next section on Graded spaces. Note that findindex acts similar to Base.indexin, but with the order of the arguments reversed (so that is more similar to getindex), and returns an Int rather than an Array{0,Union{Int,Nothing}}.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is useful to distinguish between three cases with respect to the fusion rules. For irreps of Abelian groups, we have that for every a and b, there exists a unique c such that a  b = c, i.e. there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. All other cases are referred to as non-abelian, i.e. the irreps of a non-abelian group or some more general fusion category. We still distinguish between the case where all entries of N^ab_c  1, i.e. they are zero or one. In that case, F^abc_d^f_e and R^ab_c are scalars. If some N^ab_c  1, it means that the same sector c can appear more than once in the fusion product of a and b, and we need to introduce some multiplicity label μ for the different copies. We implement a \"trait\" (similar to IndexStyle for AbstractArrays in Julia Base), i.e. a type hierarchy","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type FusionStyle end\nstruct Abelian <: FusionStyle\nend\nabstract type NonAbelian <: FusionStyle end\nstruct SimpleNonAbelian <: NonAbelian # non-abelian fusion but multiplicity free\nend\nstruct DegenerateNonAbelian <: NonAbelian # non-abelian fusion with multiplicities\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types I<:Sector should then indicate which fusion style they have by defining FusionStyle(::Type{I}).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In a similar manner, it is useful to distinguish between different styles of braiding. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case and, as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial twist. We thereto define a new type hierarchy","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type BraidingStyle end # generic braiding\nabstract type SymmetricBraiding <: BraidingStyle end\nstruct Bosonic <: SymmetricBraiding end\nstruct Fermionic <: SymmetricBraiding end\nstruct Anyonic <: BraidingStyle end","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types I<:Sector should then indicate which fusion style they have by defining BraidingStyle(::Type{}). Note that Bosonic() braiding does not mean that all permutations are trivial and R^ab_c = 1, but that R^ab_c R^ba_c = 1. For example, for the irreps of mathsfSU_2, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is -1, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a Bosonic() braiding style, all twists are simply +1. The case of fermions and anyons are discussed below.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Before discussing in more detail how a new sector type should be implemented, let us study the cases which have already been implemented. Currently, they all correspond to the irreps of groups.","category":"page"},{"location":"man/sectors/#sss_groups","page":"Sectors, representation spaces and fusion trees","title":"Existing group representations","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first sector type is called Trivial, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct Trivial <: Sector\nend\nBase.one(a::Sector) = one(typeof(a))\nBase.one(::Type{Trivial}) = Trivial()\nBase.conj(::Trivial) = Trivial()\n⊗(::Trivial, ::Trivial) = (Trivial(),)\nNsymbol(::Trivial, ::Trivial, ::Trivial) = true\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1\nBase.isreal(::Type{Trivial}) = true\nFusionStyle(::Type{Trivial}) = Abelian()\nBraidingStyle(::Type{Trivial}) = Bosonic()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The Trivial sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The most important class of sectors are irreducible representations of groups, for which we have an abstract supertype Irrep{G} that is parameterized on the type of group G. While the specific implementations of Irrep{G} depend on G, one can easily obtain the concrete type without knowing its name as Irrep[G].","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A number of groups have been defined, namely","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Group end\nabstract type AbelianGroup <: Group end\n\nabstract type ℤ{N} <: AbelianGroup end\nabstract type U₁ <: AbelianGroup end\nabstract type SU{N} <: Group end\nabstract type CU₁ <: Group end\n\nconst ℤ₂ = ℤ{2}\nconst ℤ₃ = ℤ{3}\nconst ℤ₄ = ℤ{4}\nconst SU₂ = SU{2}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Groups themselves are abstract types without any functionality (at least for now). We also provide a number of convenient Unicode aliases. These group names are probably self- explanatory, except for CU₁ which is explained below.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For all group irreps, the braiding style is bosonic","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Irrep{G<:Group} <: Sector end # irreps have integer quantum dimensions\nBase.@pure BraidingStyle(::Type{<:Irrep}) = Bosonic()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"while we gather some more common functionality for irreps of abelian groups (which exhaust all possibilities of fusion categories with abelian fusion)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const AbelianIrrep{G} = Irrep{G} where {G<:AbelianGroup}\nBase.@pure FusionStyle(::Type{<:AbelianIrrep}) = Abelian()\nBase.isreal(::Type{<:AbelianIrrep}) = true\n\nNsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = c == first(a ⊗ b)\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I<:AbelianIrrep} =\n    Int(Nsymbol(a, b, e)*Nsymbol(e, c, d)*Nsymbol(b, c, f)*Nsymbol(a, f, d))\nfrobeniusschur(a::AbelianIrrep) = 1\nBsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = Int(Nsymbol(a, b, c))\nRsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = Int(Nsymbol(a, b, c))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With these common definition, we implement the representation theory of the two most common Abelian groups, namely ℤ_N","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct ZNIrrep{N} <: Irrep{ℤ{N}}\n    n::Int8\n    function ZNIrrep{N}(n::Integer) where {N}\n        @assert N < 64\n        new{N}(mod(n, N))\n    end\nend\nBase.getindex(::Type{Irrep}, ::Type{ℤ{N}}) where {N} = ZNIrrep{N}\n\nBase.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)\nBase.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)\n⊗(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)\n\nBase.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()\nBase.length(::SectorValues{ZNIrrep{N}}) where N = N\nBase.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =\n    return i == N ? nothing : (ZNIrrep{N}(i), i+1)\nBase.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =\n    1 <= i <= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))\nfindindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and mathsfU_1","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct U1Irrep <: Irrep{U₁}\n    charge::HalfInt\nend\nBase.getindex(::Type{Irrep}, ::Type{U₁}) = U1Irrep\n\nBase.one(::Type{U1Irrep}) = U1Irrep(0)\nBase.conj(c::U1Irrep) = U1Irrep(-c.charge)\n⊗(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)\n\nBase.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{U1Irrep}, i = 0) =\n    return i <= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)\n# the following are not used and thus not really necessary\nfunction Base.getindex(::SectorValues{U1Irrep}, i::Int)\n    i < 1 && throw(BoundsError(values(U1Irrep), i))\n    return U1Irrep(iseven(i) ? half(i>>1) : -half(i>>1))\nend\nfindindex(::SectorValues{U1Irrep}, c::U1Irrep) = (n = twice(c.charge); 2*abs(n)+(n<=0))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The getindex definition just below the type definition provides the mechanism to get the concrete type as Irrep[G] for a given group G. In the definition of U1Irrep, HalfInt<:Number is a Julia type defined in HalfIntegers.jl, which is also used for SU2Irrep below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of U₁ can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of HalfInt, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Irrep[U₁](0.5)\nU1Irrep(0.4)\nU1Irrep(1) ⊗ Irrep[U₁](1//2)\nu = first(U1Irrep(1) ⊗ Irrep[U₁](1//2))\nNsymbol(u, conj(u), one(u))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For ZNIrrep{N}, we use an Int8 for compact storage, assuming that this type will not be used with N>64 (we need 2*(N-1) <= 127 in order for a ⊗ b to work correctly). We also define some aliases for the first (and most commonly used ℤ{N} irreps)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const Z2Irrep = ZNIrrep{2}\nconst Z3Irrep = ZNIrrep{3}\nconst Z4Irrep = ZNIrrep{4}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"so that we can do","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"z = Z3Irrep(1)\nZNIrrep{3}(1) ⊗ Irrep[ℤ₃](1)\nconj(z)\none(z)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As a further remark, even in the abelian case where a ⊗ b is equivalent to a single new label c, we return it as an iterable container, in this case a one-element tuple (c,).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned above, we also provide the following definitions","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)\nBase.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)\nBase.isless(c1::U1Irrep, c2::U1Irrep) where {N} =\n    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) < c1.charge == -c2.charge","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Since sectors or objects made out of tuples of sectors (see the section on Fusion Trees below) are often used as keys in look-up tables (i.e. subtypes of AbstractDictionary in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value. Note that hashes will only be used to compare sectors of the same type. The isless function provides a canonical order for sectors of a given type G<:Sector, which is useful to uniquely and unambiguously specify a representation space V = _a ℂ^n_a  R_a, as described in the section on Graded spaces below.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first example of a non-abelian representation category is that of mathsfSU_2, the implementation of which is summarized by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SU2Irrep <: Irrep{SU{2}}\n    j::HalfInt\nend\nBase.getindex(::Type{Irrep}, ::Type{SU₂}) = SU2Irrep\n\nBase.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))\nBase.conj(s::SU2Irrep) = s\n⊗(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))\ndim(s::SU2Irrep) = twice(s.j)+1\nBase.@pure FusionStyle(::Type{SU2Irrep}) = SimpleNonAbelian()\nBase.isreal(::Type{SU2Irrep}) = true\nNsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.δ(sa.j, sb.j, sc.j)\nFsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,\n        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =\n    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return 0.\n    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0\nend\n\nBase.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{SU2Irrep}, i = 0) = (SU2Irrep(half(i)), i+1)\n# unused and not really necessary:\nBase.getindex(::SectorValues{SU2Irrep}, i::Int) =\n    1 <= i ? SU2Irrep(half(i-1)) : throw(BoundsError(values(SU2Irrep), i))\nfindindex(::SectorValues{SU2Irrep}, s::SU2Irrep) = twice(s.j)+1","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and some methods for pretty printing and converting from real numbers to irrep labels. As one can notice, the topological data (i.e. Nsymbol and Fsymbol) are provided by the package WignerSymbols.jl. The iterable a ⊗ b is a custom type, that the user does not need to care about. Some examples","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = SU2Irrep(3//2)\nconj(s)\ndim(s)\ncollect(s ⊗ s)\nfor s2 in s ⊗ s\n    @show s2\n    @show Nsymbol(s, s, s2)\n    @show Rsymbol(s, s, s2)\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A final non-abelian representation theory is that of the semidirect product mathsfU₁  ℤ_2, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of ℤ_2 acts as charge conjugation C. It has the effect of interchaning mathsfU_1 irreps n and -n, and turns them together in a joint 2-dimensional index, except for the case n=0. Irreps are therefore labeled by integers n  0, however for n=0 the ℤ₂ symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with mathsfU)_1 charge 0. Given mathsfU_1  mathsfSO_2, this group is also simply known as mathsfO_2, and the two representations with n = 0 are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as Irrep[CU₁] or CU1Irrep in full.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct CU1Irrep <: Irrep\n    j::HalfInt # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::Real, s::Int = ifelse(j>zero(j), 2, 0))\n        if ((j > zero(j) && s == 2) || (j == zero(j) && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU₁ irrep\")\n        end\n    end\nend\nBase.getindex(::Type{Irrep}, ::Type{CU₁}) = CU1Irrep\n\nBase.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)\nBase.conj(c::CU1Irrep) = c\ndim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)\n\nBase.@pure FusionStyle(::Type{CU1Irrep}) = SimpleNonAbelian()\n...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of Fsymbol.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"So far, no sectors have been implemented with FusionStyle(G) == DegenerateNonAbelian(), though an example would be the representation theory of mathsfSU_N, i.e. represented by the group SU{N}, for N>2. Such sectors are not yet fully supported; certain operations remain to be implemented. Furthermore, the topological data of the representation theory of such groups is not readily available and needs to be computed.","category":"page"},{"location":"man/sectors/#sss_productsectors","page":"Sectors, representation spaces and fusion trees","title":"Combining different sectors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator ⊠, which can be entered as \\boxtimes+TAB. First some examples","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = Z3Irrep(1) ⊠ Irrep[U₁](1)\ntypeof(a)\nconj(a)\none(a)\ndim(a)\ncollect(a ⊗ a)\nFusionStyle(a)\nb = Irrep[ℤ₃](1) ⊠ Irrep[SU₂](3//2)\ntypeof(b)\nconj(b)\none(b)\ndim(b)\ncollect(b ⊗ b)\nFusionStyle(b)\nc = Irrep[SU₂](1) ⊠ SU2Irrep(3//2)\ntypeof(c)\nconj(c)\none(c)\ndim(c)\ncollect(c ⊗ c)\nFusionStyle(c)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We refer to the source file of ProductSector for implementation details.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The symbol ⊠ refers to the Deligne tensor product within the literature on category theory. Indeed, the category of representation of a product group G₁ × G₂ corresponds the Deligne tensor product of the categories of representations of the two groups separately. But this definition also extends to 𝕜-linear categories which are not the representation category of a group. Note that ⊠ also works in the type domain, i.e. Irrep[ℤ₃] ⊠ Irrep[CU₁] can be used to create ProductSector{Tuple{Irrep[ℤ₃], Irrep[CU₁]}}. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. Furthermore, for representations of groups, we also enabled the notation Irrep[ℤ₃ × CU₁], with × obtained using \\times+TAB. However, this is merely for convience; as Irrep[ℤ₃] ⊠ Irrep[CU₁] is not a subtype of the abstract type Irrep{ℤ₃ × CU₁}. That behavior cannot be obtained with the Julia's type system. Some more examples:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = Z3Irrep(1) ⊠ Irrep[CU₁](1.5)\na isa Irrep[ℤ₃] ⊠ CU1Irrep\na isa Irrep[ℤ₃ × CU₁]\na isa Irrep{ℤ₃ × CU₁}\na == Irrep[ℤ₃ × CU₁](1, 1.5)","category":"page"},{"location":"man/sectors/#sss_newsectors","page":"Sectors, representation spaces and fusion trees","title":"Defining a new type of sector","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"By now, it should be clear how to implement a new Sector subtype. Ideally, a new I<:Sector type is a struct I ... end (immutable) that has isbitstype(I) == true (see Julia's manual), and implements the following minimal set of methods","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.one(::Type{I}) = I(...)\nBase.conj(a::I) = I(...)\nBase.isreal(::Type{I}) = ... # true or false\nTensorKit.FusionStyle(::Type{I}) = ... # Abelian(), SimpleNonAbelian(), DegenerateNonAbelian()\nTensorKit.BraidingStyle(::Type{I}) = ... # Bosonic(), Fermionic(), Anyonic()\nTensorKit.Nsymbol(a::I, b::I, c::I) = ...\n    # Bool or Integer if FusionStyle(I) == DegenerateNonAbelian()\nBase.:⊗(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs\nTensorKit.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)\nTensorKit.Rsymbol(a::I, b::I, c::I)\nBase.hash(a::I, h::UInt)\nBase.isless(a::I, b::I)\nBase.iterate(::TensorKit.SectorValues{I}[, state]) = ...\nBase.IteratorSize(::Type{TensorKit.SectorValues{I}}) = ... # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::TensorKit.SectorValues{I}) = ...\nBase.getindex(::TensorKit.SectorValues{I}, i::Int) = ...\nTensorKit.findindex(::TensorKit.SectorValues{I}, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Additionally, suitable definitions can be given for","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.dim(a::I) = ...\nTensorKit.frobeniusschur(a::I) = ...\nTensorKit.Bsymbol(a::I, b::I, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Out of these, we have not yet encountered the Frobenius-Schur indicator and the B-symbol. They were both defined in the section on topological data of fusion categories and are fully determined by the F-symbol, just like the quantum dimensions. Hence, there is a default implementation for each of these three functions that just relies on Fsymbol, and alternative definitions need to be given only if a more efficient version is available.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If FusionStyle(I) == DegenerateNonAbelian(), then the multiple outputs c in the tensor product of a and b will be labeled as i=1, 2, …, Nsymbol(a,b,c). Optionally, a different label can be provided by defining","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.vertex_ind2label(i::Int, a::I, b::I, c::I) = ...\n# some label, e.g. a `Char` or `Symbol`","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following function will then automatically determine the corresponding label type (which should not vary, i.e. vertex_ind2label should be type stable)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.@pure vertex_labeltype(I::Type{<:Sector}) =\n    typeof(vertex_ind2label(1, one(I), one(I), one(I)))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following type, which already appeared in the implementation of SU2Irrep above, can be useful for providing the return type of a ⊗ b","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorSet{I<:Sector,F,S}\n    f::F\n    set::S\nend\n...\nfunction Base.iterate(s::SectorSet{I}, args...) where {I<:Sector}\n    next = iterate(s.set, args...)\n    next === nothing && return nothing\n    val, state = next\n    return convert(I, s.f(val)), state\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"That is, SectorSet(f, set) behaves as an iterator that applies x->convert(I, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.","category":"page"},{"location":"man/sectors/#sss_generalsectors","page":"Sectors, representation spaces and fusion trees","title":"Generalizations","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned before, the framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) fusion category, which was reviewed at the end of the introduction to category theory. For such categories, the objects are not necessarily vector spaces and the fusion and splitting tensors X^ab_cμ do not necessarily exist as actual tensors. However, the morphism spaces c  a  b still behave as vector spaces, and the X^ab_cμ act as generic basis for that space. As TensorKit.jl does not rely on the X^ab_cμ themselves (even when they do exist) it can also deal with such general fusion categories. Note, though, that when X^ab_cμ does exist, it is available as fusiontensor(a,b,c[,μ]) (even though it is actually the splitting tensor) and can be useful for checking purposes, as illustrated below.","category":"page"},{"location":"man/sectors/#ss_rep","page":"Sectors, representation spaces and fusion trees","title":"Graded spaces","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We have introduced Sector subtypes as a way to label the irreps or sectors in the decomposition V = _a ℂ^n_a  R_a. To actually represent such spaces, we now also introduce a corresponding type GradedSpace, which is a subtype of EuclideanSpace{ℂ}, i.e.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct GradedSpace{I<:Sector, D} <: EuclideanSpace{ℂ}\n    dims::D\n    dual::Bool\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Here, D is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions n_a of the different sectors. For conviency, GradedSpace[I] will return the fully concrete type with D specified, though it is hidden from the user using a custom Base.show method.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that, conventionally, a graded vector space is a space that has a natural direct sum decomposition over some set of labels, i.e. V = _a  I V_a where the label set I has the structure of a semigroup a  b = c  I. Here, we generalize this notation by using for I the fusion ring of a fusion category, a  b = _c  I _μ = 1^N_ab^c c. However, this is mostly to lower the barrier, as really the instances of GradedSpace represent just general objects in a fusion category (or strictly speaking, a pre-fusion category, as we allow for an infinite number of simple objects, e.g. the irreps of a continuous group).","category":"page"},{"location":"man/sectors/#Implementation-details","page":"Sectors, representation spaces and fusion trees","title":"Implementation details","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned, the way in which the degeneracy dimensions n_a are stored depends on the specific sector type I, more specifically on the IteratorSize of values(I). If IteratorSize(values(I)) isa Union{IsInfinite, SizeUnknown}, the different sectors a and their corresponding degeneracy n_a are stored as key value pairs in an Associative array, i.e. a dictionary dims::SectorDict. As the total number of sectors in values(I) can be infinite, only sectors a for which n_a are stored. Here, SectorDict is a constant type alias for a specific dictionary implementation, which currently resorts to SortedVectorDict implemented in TensorKit.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (Vector instances), which are ordered based on the property isless(a::I, b::I). This ensures that the space V = _a ℂ^n_a  R_a has some unique canonical order in the direct sum decomposition, such that two different but equal instances created independently always match.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If IteratorSize(values(I)) isa Union{HasLength, HasShape}, the degeneracy dimensions n_a are stored for all sectors a ∈ values(I) (also if n_a == 0) in a tuple, more specifically a NTuple{N, Int} with N = length(values(I)). The methods getindex(values(I), i) and findindex(values(I), a) are used to map between a sector a ∈ values(I) and a corresponding index i ∈ 1:N. As N is a compile time constant, these types can be created in a type stable manner.","category":"page"},{"location":"man/sectors/#Constructing-instances","page":"Sectors, representation spaces and fusion trees","title":"Constructing instances","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned, the convenience mehtod GradedSpace[I] will return the concrete type GradedSpace{I,D} with the matching value of D, so that should never be a user's concern. In fact, for consistency, GradedSpace[Trivial] will just return ComplexSpace, which is not even a specific type of GradedSpace. There is also the Unicode alias ℂ[I], and for the specific case of group irreps as sectors, one can use Rep[G] with G the group, as inspired by the categorical name mathbfRep_mathsfG. Here, Rep is a UnionAll type that for GradedSpace{I} where I is either the Irrep of some group, or a ProductSector of Irreps. Some illustrations:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"ℂ[]\nℂ[Trivial]\nGradedSpace[Trivial]\nGradedSpace[U1Irrep]\nℂ[Irrep[U₁]]\nRep[U₁]\nRep[ℤ₂ × SU₂]\nGradedSpace[Irrep[ℤ₂ × SU₂]]","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that we also have the specific alias U₁Space. In fact, for all the common groups we have a number of alias, both in ASCII and using Unicode:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"# ASCII type aliases\nconst ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}\nconst Z2Space = ZNSpace{2}\nconst Z3Space = ZNSpace{3}\nconst Z4Space = ZNSpace{4}\nconst U1Space = Rep[U₁]\nconst CU1Space = Rep[CU₁]\nconst SU2Space = Rep[SU₂]\n\n# Unicode alternatives\nconst ℤ₂Space = Z2Space\nconst ℤ₃Space = Z3Space\nconst ℤ₄Space = Z4Space\nconst U₁Space = U1Space\nconst CU₁Space = CU1Space\nconst SU₂Space = SU2Space","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To create specific instances of those types, one can e.g. just use V = GradedSpace(a=>n_a, b=>n_b, c=>n_c) or V = GradedSpace(iterator) where iterator is any iterator (e.g. a dictionary or a generator) that yields Pair{I,Int} instances. With those constructions, I is inferred from the type of sectors. However, it is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type; compare","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"GradedSpace[Irrep[U₁]](0=>3, 1=>2, -1=>1) ==\n    ℂ[U1Irrep(0)=>3, U1Irrep(1)=>2, U1Irrep(-1)=>1] == U1Space(0=>3, 1=>2, -1=>1)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The fact that Rep[G] also works with product groups makes it easy to specify e.g.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Rep[ℤ₂ × SU₂]((0,0) => 3, (1,1/2) => 2, (0,1) => 1) == ℂ[(Z2Irrep(0) ⊠ SU2Irrep(0)) => 3, (Z2Irrep(1) ⊠ SU2Irrep(1/2)) => 2, (Z2Irrep(0) ⊠ SU2Irrep(1)) => 1]","category":"page"},{"location":"man/sectors/#Methods","page":"Sectors, representation spaces and fusion trees","title":"Methods","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There are a number of methods to work with instances V of GradedSpace. The function sectortype returns the type of the sector labels. It also works on other vector spaces, in which case it returns Trivial. The function sectors returns an iterator over the different sectors a with non-zero n_a, for other ElementarySpace types it returns (Trivial,). The degeneracy dimensions n_a can be extracted as dim(V, a), it properly returns 0 if sector a is not present in the decomposition of V. With hassector(V, a) one can check if V contains a sector a with dim(V,a)>0. Finally, dim(V) returns the total dimension of the space V, i.e. _a n_a d_a or thus dim(V) = sum(dim(V,a) * dim(a) for a in sectors(V)). Note that a representation space V has certain sectors a with dimensions n_a, then its dual V' will report to have sectors dual(a), and dim(V', dual(a)) == n_a. There is a subtelty regarding the difference between the dual of a representation space R_a^*, on which the conjugate representation acts, and the representation space of the irrep dual(a)==conj(a) that is isomorphic to the conjugate representation, i.e. R_overlinea  R_a^* but they are not equal. We return to this in the section on fusion trees. This is true also in more general fusion categories beyond the representation categories of groups.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Other methods for ElementarySpace, such as dual, fuse and flip also work. In fact, GradedSpace is the reason flip exists, cause in this case it is different then dual. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a. In order for flip(V) to be isomorphic to V, it is such that, if V = GradedSpace(a=>n_a,...) then flip(V) = dual(GradedSpace(dual(a)=>n_a,....)).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Furthermore, for two spaces V1 = GradedSpace(a=>n1_a, ...) and V2 = GradedSpace(a=>n2_a, ...), we have infimum(V1,V2) = GradedSpace(a=>min(n1_a,n2_a), ....) and similarly for supremum, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of infimum(V1,V2) or supremum(V1,V2) is neither equal to V1 or V2.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For W a ProductSpace{GradedSpace[I], N}, sectors(W) returns an iterator that generates all possible combinations of sectors as represented as NTuple{I,N}. The function dims(W, as) returns the corresponding tuple with degeneracy dimensions, while dim(W, as) returns the product of these dimensions. hassector(W, as) is equivalent to dim(W, as)>0. Finally, there is the function blocksectors(W) which returns a list (of type Vector) with all possible \"block sectors\" or total/coupled sectors that can result from fusing the individual uncoupled sectors in W. Correspondingly, blockdim(W, a) counts the total degeneracy dimension of the coupled sector a in W. The machinery for computing this is the topic of the next section on Fusion trees, but first, it's time for some examples.","category":"page"},{"location":"man/sectors/#Examples","page":"Sectors, representation spaces and fusion trees","title":"Examples","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let's start with an example involving mathsfU_1:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = Rep[U₁](0=>3, 1=>2, -1=>1)\nV1 == U1Space(0=>3, 1=>2, -1=>1) == U₁Space(-1=>1, 1=>2,0=>3) # order doesn't matter\n(sectors(V1)...,)\ndim(V1, U1Irrep(1))\ndim(V1', Irrep[U₁](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))\nhassector(V1, Irrep[U₁](1))\nhassector(V1, Irrep[U₁](2))\ndual(V1)\nflip(V1)\ndual(V1) ≅ V1\nflip(V1) ≅ V1\nV2 = U1Space(0=>2, 1=>1, -1=>1, 2=>1, -2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n⊕(V1,V2)\nW = ⊗(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[U₁](0), Irrep[U₁](0)))\ndim(W, (Irrep[U₁](0), Irrep[U₁](0)))\nhassector(W, (Irrep[U₁](0), Irrep[U₁](0)))\nhassector(W, (Irrep[U₁](2), Irrep[U₁](0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, Irrep[U₁](0))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and then with mathsfSU_2:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = ℂ[Irrep[SU₂]](0=>3, 1//2=>2, 1=>1)\nV1 == SU2Space(0=>3, 1/2=>2, 1=>1) == SU₂Space(0=>3, 0.5=>2, 1=>1)\n(sectors(V1)...,)\ndim(V1, SU2Irrep(1))\ndim(V1', SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU₂](1))\ndim(V1)\nhassector(V1, Irrep[SU₂](1))\nhassector(V1, Irrep[SU₂](2))\ndual(V1)\nflip(V1)\nV2 = SU2Space(0=>2, 1//2=>1, 1=>1, 3//2=>1, 2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n⊕(V1,V2)\nW = ⊗(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[SU₂](0), Irrep[SU₂](0)))\ndim(W, (Irrep[SU₂](0), Irrep[SU₂](0)))\nhassector(W, (SU2Irrep(0), SU2Irrep(0)))\nhassector(W, (SU2Irrep(2), SU2Irrep(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, SU2Irrep(0))","category":"page"},{"location":"man/sectors/#ss_fusiontrees","page":"Sectors, representation spaces and fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric (equivariant) tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors, i.e. they exhibit block sparsity. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section blocksectors and blockdim defined on the type ProductSpace.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"This basis transform consists of a basis of inclusion and projection maps, denoted as X^a_1a_2a_N_cα R_c  R_a_1  R_a_2    R_a_N and their adjoints (X^a_1a_2a_N_cα)^, such that","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X^a_1a_2a_N_cα)^  X^a_1a_2a_N_cα = δ_cc δ_αα mathrmid_c","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"_cα X^a_1a_2a_N_cα  (X^a_1a_2a_N_cα)^  = mathrmid_a_1  a_2    a_N = mathrmid_a_1  mathrmid_a_2    mathrmid_a_N","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Fusion trees provide a particular way to construct such a basis. It is useful to know about the existence of fusion trees and how they are represented, as discussed in the first subsection. The next two subsections discuss possible manipulations that can be performed with fusion trees. These are used under the hood when manipulating the indices of tensors, but a typical user would not need to use these manipulations on fusion trees directly. Hence, these last two sections can safely be skipped.","category":"page"},{"location":"man/sectors/#Canonical-representation","page":"Sectors, representation spaces and fusion trees","title":"Canonical representation","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To couple or fuse the different sectors together into a single block sector, we can sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector, using the splitting tensors X_ab^cμ  R_c  R_a  R_b and their adjoints. This amounts to the canonical choice of our tensor product, and for a given tensor mapping from (((W_1  V_2)  V_3)   ) W_N_2) to (((V_1  V_2)  V_3)   ) V_N_1), the corresponding fusion and splitting trees take the form","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: double fusion tree)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"for the specific case N_1=4 and N_2=3. We can separate this tree into the fusing part (b_1b_2)b_3  c and the splitting part c(((a_1a_2)a_3)a_4). Given that the fusion tree can be considered to be the adjoint of a corresponding splitting tree c(b_1b_2)b_3, we now first consider splitting trees in isolation. A splitting tree which goes from one coupled sectors c to N uncoupled sectors a_1, a_2, …, a_N needs N-2 additional internal sector labels e_1, …, e_N-2, and, if FusionStyle(I) isa DegenerateNonAbelian, N-1 additional multiplicity labels μ_1, …, μ_N-1. We henceforth refer to them as vertex labels, as they are associated with the vertices of the splitting tree. In the case of FusionStyle(I) isa Abelian, the internal sectors e_1, …, e_N-2 are completely fixed, for FusionStyle(I) isa NonAbelian they can also take different values. In our abstract notation of the splitting basis X^a_1a_2a_N_cα used above, α can be consided a collective label, i.e. α = (e_1  e_N-2 μ₁  μ_N-1). Indeed, we can check the orthogonality condition (X^a_1a_2a_N_cα)^  X^a_1a_2a_N_cα = δ_cc δ_αα mathrmid_c, which now forces all internal lines e_k and vertex labels μ_l to be the same.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There is one subtle remark that we have so far ignored. Within the specific subtypes of Sector, we do not explicitly distinguish between R_a^* (simply denoted as a^* and graphically depicted as an upgoing arrow a) and R_bara (simply denoted as bara and depicted with a downgoing arrow), i.e. between the dual space of R_a on which the conjugated irrep acts, or the irrep bara to which the complex conjugate of irrep a is isomorphic. This distinction is however important, when certain uncoupled sectors in the fusion tree actually originate from a dual space. We use the isomorphisms Z_aR_a^*  R_bara and its adjoint Z_a^R_baraR_a^*, as introduced in the section on topological data of a fusion category, to build fusion and splitting trees that take the distinction between irreps and their conjugates into account. Hence, in the previous example, if e.g. the first and third space in the codomain and the second space in the domain of the tensor were dual spaces, the actual pair of splitting and fusion tree would look as","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: extended double fusion tree)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The presence of these isomorphisms will be important when we start to bend lines, to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. Note that we can still represent the fusion tree as the adjoint of a corresponding splitting tree, because we also use the adjoint of the Z isomorphisms in the splitting part, and the Z isomorphism in the fusion part. Furthermore, the presence of the Z isomorphisms does not affect the orthonormality.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We represent splitting trees and their adjoints using a specific immutable type called FusionTree (which actually represents a splitting tree, but fusion tree is a more common term), defined as","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct FusionTree{I<:Sector,N,M,L,T}\n    uncoupled::NTuple{N,I}\n    coupled::I\n    isdual::NTuple{N,Bool}\n    innerlines::NTuple{M,I} # fixed to M = N-2\n    vertices::NTuple{L,T} # fixed to L = N-1\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Here, the fields are probably self-explanotary. The isdual field indicates whether an isomorphism is present (if the corresponding value is true) or not. Note that the field uncoupled contains the sectors coming out of the splitting trees, before the possible Z isomorphism, i.e. the splitting tree in the above example would have sectors = (a₁, a₂, a₃, a₄). The FusionTree type has a number of basic properties and capabilities, such as checking for equality with == and support for hash(f::FusionTree, h::UInt), as splitting and fusion trees are used as keys in look-up tables (i.e. AbstractDictionary instances) to look up certain parts of the data of a tensor. The type of L of the vertex labels can be Nothing when they are not needed (i.e. if FusionStyle(I) ∈ (Abelian(), NonAbelian())).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"FusionTree instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. The most natural way to create them is by using the fusiontrees(uncoupled::NTuple{N,I}, coupled::I = one(I)) method, which returns an iterator over all possible fusion trees from a set of N uncoupled sectors to a given coupled sector, which by default is assumed to be the trivial sector of that group or fusion category (i.e. the identity object in categorical nomenclature). The return type of fusiontrees is a custom type FusionTreeIterator which conforms to the complete interface of an iterator, and has a custom length function that computes the number of possible fusion trees without iterating over all of them explicitly. This is best illustrated with some examples","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = Irrep[SU₂](1/2)\ncollect(fusiontrees((s,s,s,s)))\ncollect(fusiontrees((s,s,s,s,s), s, (true, false, false, true, false)))\niter = fusiontrees(ntuple(n->s, 16))\nsum(n->1, iter)\nlength(iter)\n@elapsed sum(n->1, iter)\n@elapsed length(iter)\ns2 = s ⊠ s\ncollect(fusiontrees((s2,s2,s2,s2)))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that FusionTree instances are shown (printed) in a way that is valid code to reproduce them, a property which also holds for both instances of Sector and instances of VectorSpace. All of those should be displayed in a way that can be copy pasted as valid code. Furthermore, we use contact to determine how to print e.g. a sector. In isolation, s2 is printed as (Irrep[SU₂](1/2) ⊠ Irrep[SU₂](1/2)), however, within the fusion tree, it is simply printed as (1/2, 1/2), because it will be converted back into a ProductSector, namely Irrep[SU₂] ⊠ Irrep[SU₂] by the constructor of FusionTree{Irrep[SU₂] ⊠ Irrep[SU₂]}.","category":"page"},{"location":"man/sectors/#Manipulations-on-a-fusion-tree","page":"Sectors, representation spaces and fusion trees","title":"Manipulations on a fusion tree","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We now discuss elementary manipulations that we want to perform on or between fusion trees (where we actually mean splitting trees), which will form the building block for more general manipulations on a pair of a fusion and splitting tree discussed in the next subsection, and then for casting a general index manipulation of a tensor map as a linear operation in the basis of canonically ordered splitting and fusion trees. In this section, we will ignore the Z isomorphisms, as they are just trivially reshuffled under the different operations that we describe. These manipulations are used as low-level methods by the TensorMap methods discussed on the next page. As such, they are not exported by TensorKit.jl, nor do they overload similarly named methods from Julia Base (see split and merge below).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first operation we discuss is an elementary braid of two neighbouring sectors (indices), i.e. a so-called Artin braid or Artin generator of the braid group. Because these two sectors do not appear on the same fusion vertex, some recoupling is necessary. The following represents two different ways to compute the result of such a braid as a linear combination of new fusion trees in canonical order:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: artin braid)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"While the upper path is the most intuitive, it requires two recouplings or F-moves (one forward and one reverse). On the other hand, the lower path requires only one (reverse) F- move, and two R-moves. The latter are less expensive to compute, and so the lower path is computationally more efficient. However, the end result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any new subtype of Sector, and it is up to the user to verify that they are when implementing new custom Sector types. This result is implemented in the function artin_braid(f::FusionTree, i; inv = false) where i denotes the position of the first sector (i.e. labeled b in the above graph) which is then braided with the sector at position i+1 in the fusion tree f. The keyword argument inv allows to select the inverse braiding operation, which amounts to replacing the R-matrix with its inverse (or thus, adjoint) in the above steps. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as value. In the case of FusionStyle(I) == Abelian(), their is only one resulting fusion tree, with corresponding coefficient a complex phase (which is one for the bosonic representation theory of an Abelian group), and the result is a special SingletonDict<:AbstractDict, a struct type defined in TensorKit.jl to hold a single key value pair.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With the elementary artin_braid, we can then compute a more general braid. For this, we provide an interface","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"braid(f::FusionTree{I,N}, levels::NTuple{N,Int}, permutation::NTuple{N,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where the braid is specified as a permutation, such that the new sector at position i was originally at position permutation[i], and where every uncoupled sector is also assigned a level or depth. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor. This interface does not allow to specify the most general braid, and in particular will never wind one line around another, but can be used as a more general building block for arbitrary braids than the elementary Artin generators. A graphical example makes this probably more clear, i.e for levels=(1,2,3,4,5) and permutation=(5,3,1,4,2), the corresponding braid is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: braid interface)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"that is, the first sector or space goes to position 3, and crosses over all other lines, because it has the lowest level (i.e. think of level as depth in the third dimension), and so forth. We sketch this operation both as a general braid on the left hand side, and as a particular composition of Artin braids on the right hand side.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"When BraidingStyle(I) == SymmetricBraiding(), there is no distinction between applying the braiding or its inverse (i.e. lines crossing over or under each other in the graphical notation) and the whole operation simplifies down to a permutation. We then also support the interface","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"permute(f::FusionTree{I,N}, permutation::NTuple{N,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Other manipulations which are sometimes needed are","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"insertat(f1::FusionTree{I,N₁}, i::Int, f2::FusionTree{I,N₂}) :   inserts a fusion tree f2 at the ith uncoupled sector of fusion tree f1 (this   requires that the coupled sector f2 matches with the ith uncoupled sector of f1,   and that !f1.isdual[i], i.e. that there is no Z-isomorphism on the ith line of   f1), and recouple this into a linear combination of trees in canonical order, with   N₁+N₂-1 uncoupled sectors, i.e. diagrammatically for i=3\n(Image: insertat)\nsplit(f::FusionTree{I,N}, M::Int) :   splits a fusion tree f into two trees f1 and f2, such that f1 has the first M   uncoupled sectors of f, and f2 the remaining N-M. This function is type stable if M is a compile time constant.\nsplit(f, M) is the inverse of insertat in the sence that insertat(f2, 1, f1)   should return a dictionary with a single key-value pair f=>1. Diagrammatically, for   M=4, the function split returns\n(Image: split)\nmerge(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, c::I, μ=nothing) :   merges two fusion trees f1 and f2 by fusing the coupled sectors of f1 and f2   into a sector c (with vertex label μ if FusionStyle(I) == DegenerateNonAbelian()),   and reexpressing the result as a linear combination of fusion trees with N₁+N₂   uncoupled sectors in canonical order. This is a simple application of insertat.   Diagrammatically, this operation is represented as:\n(Image: merge)","category":"page"},{"location":"man/sectors/#Manipulations-on-a-splitting-fusion-tree-pair","page":"Sectors, representation spaces and fusion trees","title":"Manipulations on a splitting - fusion tree pair","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In this subsection we discuss manipulations that act on a splitting and fusion tree pair, which we will always as two separate trees f1, f2, where f1 is the splitting tree and f2 represents the fusion tree, and they should have f1.coupled == f2.coupled.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The most important manipulation on such a pair is to move sectors from one to the other. Given the canonical order of these trees, we exclusively use the left duality (see the section on categories), for which the evaluation and coevaluation maps establish isomorphisms between","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"mathrmHom((((b_1  b_2)  )  b_N_2) (((a_1  a_2)  )  a_N_1))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":" mathrmHom((((b_1  b_2)  )  b_N_2-1) ((((a_1  a_2)  )  a_N_1)  b_N_2^*))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":" mathrmHom(1 (((((((a_1  a_2)  )  a_N_1)  b_N_2^*)  )  b_2^*)  b_1^*) )","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where the last morphism space is then labeled by the basis of only splitting trees. We can then use the manipulations from the previous section, and then again use the left duality to bring this back to a pair of splitting and fusion tree with N₂′ incoming and N₁′ incoming sectors (with N₁′ + N₂′ == N₁ + N₂).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We now discuss how to actually bend lines, and thus, move sectors from the incoming part (fusion tree) to the outgoing part (splitting tree). Hereby, we exploit the relations between the (co)evaluation (exact pairing) and the fusion tensors, discussed in topological data of a fusion category. The main ingredient that we need is summarized in","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: line bending)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We will only need the B-symbol and not the A-symbol. Applying the left evaluation on the second sector of a splitting tensor thus yields a linear combination of fusion tensors (when FusionStyle(I) == DegenerateNonAbelian(), or just a scalar times the corresponding fusion tensor otherwise), with corresponding Z ismorphism. Taking the adjoint of this relation yields the required relation to transform a fusion tensor into a splitting tensor with an added Z^ isomorphism.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"However, we have to be careful if we bend a line on which a Z isomorphism (or its adjoint) is already present. Indeed, it is exactly for this operation that we explicitly need to take the presence of these isomorphisms into account. Indeed, we obtain the relation","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: dual line bending)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Hence, bending an isdual sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and of course leads to a normal sector (which is no longer isdual and does thus not come with a Z-isomorphism) on the fusion side. We again use the adjoint of this relation to bend an isdual sector from the fusion tree to the splitting tree.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The FusionTree interface to duality and line bending is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"repartition(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, N::Int)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which takes a splitting tree f1 with N₁ outgoing sectors, a fusion tree f2 with N₂ incoming sectors, and applies line bending such that the resulting splitting and fusion trees have N outgoing sectors, corresponding to the first N sectors out of the list (a_1 a_2  a_N_1 b_N_2^*  b_1^*) and N₁+N₂-N incoming sectors, corresponding to the dual of the last N₁+N₂-N sectors from the previous list, in reverse. This return values are correctly inferred if N is a compile time constant.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Graphically, for N₁ = 4, N₂ = 3, N = 2 and some particular choice of isdual in both the fusion and splitting tree:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: repartition)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The result is returned as a dictionary with keys (f1′, f2′) and the corresponding coeff as value. Note that the summation is only over the κ_j labels, such that, in the case of FusionStyle(I) ∈ (Abelian(), SimpleNonAbelian()), the linear combination simplifies to a single term with a scalar coefficient.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With this basic function, we can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear. The interface provided for this is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"braid(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, levels1::NTuple{N₁,Int}, levels2::NTuple{N₂,Int}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where we now have splitting tree f1 with N₁ outgoing sectors, a fusion tree f2 with N₂ incoming sectors, levels1 and levels2 assign a level or depth to the corresponding uncoupled sectors in f1 and f2, and we represent the new configuration as a pair p1 and p2. Together, (p1..., p2...) represents a permutation of length N₁+N₂ = N₁′+N₂′, where p1 indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and p2 indicates which appear as incoming sectors in the new fusion tree. Hereto, we label the uncoupled sectors of f1 from 1 to N₁, followed by the uncoupled sectors of f2 from N₁+1 to N₁+N₂. Note that simply repartitioning the splitting and fusion tree such that e.g. all sectors appear in the new splitting tree (i.e. are outgoing), amounts to chosing p1 = (1,..., N₁, N₁+N₂, N₁+N₂-1, ... , N₁+1) and p2=(), because the duality isomorphism reverses the order of the tensor product.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"This routine is implemented by indeed first making all sectors outgoing using the repartition function discussed above, such that only splitting trees remain, then braiding those using the routine from the previous subsection such that the new outgoing sectors appear first, followed by the new incoming sectors (in reverse order), and then again invoking the repartition routine to bring everything in final form. The result is again returned as a dictionary where the keys are (f1′,f2′) and the values the corresponding coefficients.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As before, there is a simplified interface for the case where BraidingStyle(I) isa SymmetricBraiding and the levels are not needed. This is simply given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"permute(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The braid and permute routines for double fusion trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memoized, i.e. they are stored in some package wide 'least-recently used' cache (from LRUCache.jl) that can be accessed as TensorKit.braidcache. By default, this cache stores up to 10^5 different braid or permute resuls, where one result corresponds to one particular combination of (f1, f2, p1, p2, levels1, levels2). This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to resize!(TensorKit.permutecache) and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type RefValue{Bool}, namely usebraidcache_abelian and usebraidcache_nonabelian. The default values are given by TensorKit.usebraidcache_abelian[] = false and TensorKit.usebraidcache_nonabelian[] = true, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with FusionStyle(f) isa Abelian, but is probably useful for fusion trees with FusionStyle(f) isa NonAbelian. One can change these values and test the effect on their application.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The existence of braidcache also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.","category":"page"},{"location":"man/sectors/#Inspecting-fusion-trees-as-tensors","page":"Sectors, representation spaces and fusion trees","title":"Inspecting fusion trees as tensors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For those cases where the fusion and splitting tensors have an explicit representation as a tensor, i.e. a morphism in the category Vect (this essentially coincides with the case of group representations), this explicit representation can be created, which can be useful for checking purposes. Hereto, it is necessary that the splitting tensor X^ab_cμ, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine fusiontensor(a,b,c [,μ = nothing]), where the last argument is only necessary in the case of FusionStyle(I) == DegenerateNonAbelian(). We can then convert a FusionTree{I,N} into an Array, which will yield a rank N+1 array where the first N dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector. Note that this is mostly useful for the case of FusionStyle(I) isa NonAbelian groups, as in the case of abelian groups, all irreps are one-dimensional.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some examples:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = Irrep[SU₂](1/2)\niter = fusiontrees((s, s, s, s), SU2Irrep(1))\nf = first(iter)\nconvert(Array, f)\n\nI ≈ convert(Array, FusionTree((SU₂(1/2),), SU₂(1/2), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))\ntranspose(Z) ≈ frobeniusschur(SU2Irrep(1/2)) * Z\n\nI ≈ convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (true,), ())))\ntranspose(Z) ≈ frobeniusschur(Irrep[SU₂](1)) * Z\n\n#check orthogonality\nfor f1 in iter\n  for f2 in iter\n    dotproduct  = dot(convert(Array, f1), convert(Array, f2))\n    println(\"< $f1, $f2> = $dotproduct\")\n  end\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that we take the adjoint when computing Z, because convert(Array, f) assumes f to be splitting tree, which is built using Z^. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the mathrmid_c when checking the orthogonality by computing dot of the corresponding tensors.","category":"page"},{"location":"man/sectors/#Fermions","page":"Sectors, representation spaces and fusion trees","title":"Fermions","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Support for fermionic sectors and corresponding super vector spaces is on its way. This section will be completed when the implementation is finished.)","category":"page"},{"location":"man/sectors/#Anyons","page":"Sectors, representation spaces and fusion trees","title":"Anyons","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There is currently one example of a Sector subtype that has anyonic braiding style, namely that of the Fibonacci fusion category. It has to (isomorphism classes of) simple objects, namely the identity 𝟙 and a non-trivial object known as τ, with fusion rules τ ⊗ τ = 𝟙 ⊕ τ. Let's summarize the topological data","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"𝟙 = FibonacciAnyon(:I)\nτ = FibonacciAnyon(:τ)\ncollect(τ ⊗ τ)\nFusionStyle(τ)\nBraidingStyle(τ)\ndim(𝟙)\ndim(τ)\nF𝟙 = Fsymbol(τ,τ,τ,𝟙,τ,τ)\nFτ = [Fsymbol(τ,τ,τ,τ,𝟙,𝟙) Fsymbol(τ,τ,τ,τ,𝟙,τ); Fsymbol(τ,τ,τ,τ,τ,𝟙) Fsymbol(τ,τ,τ,τ,τ,τ)]\nFτ'*Fτ\npolar(x) = rationalize.((abs(x), angle(x)/(2pi)))\nRsymbol(τ,τ,𝟙) |> polar\nRsymbol(τ,τ,τ) |> polar\ntwist(τ) |> polar","category":"page"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"man/tutorial/#s_tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before discussing at length all aspects of this package, both its usage and implementation, we start with a short tutorial to sketch the main capabilities. Thereto, we start by loading TensorKit.jl","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TensorKit","category":"page"},{"location":"man/tutorial/#Cartesian-tensors","page":"Tutorial","title":"Cartesian tensors","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The most important objects in TensorKit.jl are tensors, which we now create with random (normally distributed) entries in the following manner","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = Tensor(randn, ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that we entered the tensor size not as plain dimensions, by specifying the vector space associated with these tensor indices, in this case ℝ^n, which can be obtained by typing \\bbR+TAB. The tensor then lives in the tensor product of the different spaces, which we can obtain by typing ⊗ (i.e. \\otimes+TAB), although for simplicity also the usual multiplication sign * does the job. Note also that A is printed as an instance of a parametric type TensorMap, which we will discuss below and contains Tensor.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Briefly sidetracking into the nature of ℝ^n:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = ℝ^3\ntypeof(V)\nV == CartesianSpace(3)\nsupertype(CartesianSpace)\nsupertype(EuclideanSpace)\nsupertype(InnerProductSpace)\nsupertype(ElementarySpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"i.e. ℝ^n can also be created without Unicode using the longer syntax CartesianSpace(n). It is subtype of EuclideanSpace{ℝ}, a space with a standard (Euclidean) inner product over the real numbers. Furthermore,","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"W = ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4\ntypeof(W)\nsupertype(ProductSpace)\nsupertype(CompositeSpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"i.e. the tensor product of a number of CartesianSpaces is some generic parametric ProductSpace type, specifically ProductSpace{CartesianSpace,N} for the tensor product of N instances of CartesianSpace.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Tensors are itself vectors (but not Vectors), so we can compute linear combinations, provided they live in the same space.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, ℝ^3 * ℝ^2 * ℝ^4);\nC = 0.5*A + 2.5*B","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Given that they are behave as vectors, they also have a scalar product and norm, which they inherit from the Euclidean inner product on the individual ℝ^n spaces:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"scalarBA = dot(B,A)\nscalarAA = dot(A,A)\nnormA² = norm(A)^2","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"If two tensors live on different spaces, these operations have no meaning and are thus not allowed","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B′ = Tensor(randn, ℝ^4 * ℝ^2 * ℝ^3);\nspace(B′) == space(A)\nC′ = 0.5*A + 2.5*B′\nscalarBA′ = dot(B′,A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"However, in this particular case, we can reorder the indices of B′ to match space of A, using the routine permute (we deliberately choose not to overload permutedims from Julia Base, for reasons that become clear below):","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"space(permute(B′,(3,2,1))) == space(A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can contract two tensors using Einstein summation convention, which takes the interface from TensorOperations.jl. TensorKit.jl reexports the @tensor macro","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]\n@tensor d = A[a,b,c]*A[a,b,c]\nd ≈ scalarAA ≈ normA²","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We hope that the index convention is clear. The := is to create a new tensor D, without the : the result would be written in an existing tensor D, which in this case would yield an error as no tensor D exists. If the contraction yields a scalar, regular assignment with = can be used.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can factorize a tensor, creating a bipartition of a subset of its indices and its complement. With a plain Julia Array, one would apply permutedims and reshape to cast the array into a matrix before applying e.g. the singular value decomposition. With TensorKit.jl, one just specifies which indices go to the left (rows) and right (columns)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"U, S, Vd = tsvd(A, (1,3), (2,));\n@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA ≈ A′\nU","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the tsvd routine returns the decomposition of the linear map as three factors, U, S and Vd, each of them a TensorMap, such that Vd is already what is commonly called V'. Furthermore, observe that U is printed differently then A, i.e. as a TensorMap((ℝ^3 ⊗ ℝ^4) ← ProductSpace(ℝ^2)). What this means is that tensors (or more appropriately, TensorMap instances) in TensorKit.jl are always considered to be linear maps between two ProductSpace instances, with","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"codomain(U)\ndomain(U)\ncodomain(A)\ndomain(A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Hence, a Tensor instance such as A is just a specific case of TensorMap with an empty domain, i.e. a ProductSpace{CartesianSpace,0} instance. In particular, we can represent a vector v and matrix m as","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"v = Tensor(randn, ℝ^3)\nm1 = TensorMap(randn, ℝ^4, ℝ^3)\nm2 = TensorMap(randn, ℝ^4 → ℝ^2) # alternative syntax for TensorMap(randn, ℝ^2, ℝ^4)\nw = m1 * v # matrix vector product\nm3 = m2*m1 # matrix matrix product","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that for the construction of m1, in accordance with how one specifies the dimensions of a matrix (e.g. randn(4,3)), the first space is the codomain and the second the domain. This is somewhat opposite to the general notation for a function f:domain→codomain, so that we also support this more mathemical notation, as illustrated in the construction of m2. In fact, there is a third syntax which mixes both and reads as TensorMap(randn, codomain←domain).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This 'matrix vector' or 'matrix matrix' product can be computed between any two TensorMap instances for which the domain of the first matches with the codomain of the second, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"v′ = v ⊗ v\nm1′ = m1 ⊗ m1\nw′ = m1′ * v′\nw′ ≈ w ⊗ w","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Another example involves checking that U from the singular value decomposition is a unitary, or at least a left isometric tensor","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"codomain(U)\ndomain(U)\nspace(U)\nU'*U # should be the identity on the corresponding domain = codomain\nU'*U ≈ one(U'*U)\nP = U*U' # should be a projector\nP*P ≈ P","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, the adjoint of a TensorMap results in a new tensor map (actually a simple wrapper of type AdjointTensorMap <: AbstractTensorMap) with domain and codomain interchanged.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Our original tensor A living in ℝ^4 * ℝ^2 * ℝ^3 is isomorphic to e.g. a linear map ℝ^3 → ℝ^4 * ℝ^2. This is where the full power of permute emerges. It allows to specify a permutation where some indices go to the codomain, and others go to the domain, as in","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A2 = permute(A,(1,2),(3,))\ncodomain(A2)\ndomain(A2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In fact, tsvd(A, (1,3),(2,)) is a shorthand for tsvd(permute(A,(1,3),(2,))), where tsvd(A::TensorMap) will just compute the singular value decomposition according to the given codomain and domain of A.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note, finally, that the @tensor macro treats all indices at the same footing and thus does not distinguish between codomain and domain. The linear numbering is first all indices in the codomain, followed by all indices in the domain. However, when @tensor creates a new tensor (i.e. when using :=), the default syntax always creates a Tensor, i.e. with all indices in the codomain.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\ncodomain(A′)\ndomain(A′)\n@tensor A2′[(a,b);(c,)] := U[a,c,d]*S[d,e]*Vd[e,b];\ncodomain(A2′)\ndomain(A2′)\n@tensor A2′′[a b; c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA2 ≈ A2′ == A2′′","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As illustrated for A2′ and A2′′, additional syntax is available that enables one to immediately specify the desired codomain and domain indices.","category":"page"},{"location":"man/tutorial/#Complex-tensors","page":"Tutorial","title":"Complex tensors","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For applications in e.g. quantum physics, we of course want to work with complex tensors. Trying to create a complex-valued tensor with CartesianSpace indices is of course somewhat contrived and prints a (one-time) warning","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = Tensor(randn, ComplexF64, ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"although most of the above operations will work in the expected way (at your own risk). Indeed, we instead want to work with complex vector spaces","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = Tensor(randn, ComplexF64, ℂ^3 ⊗ ℂ^2 ⊗ ℂ^4)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"where ℂ is obtained as \\bbC+TAB and we also have the non-Unicode alternative ℂ^n == ComplexSpace(n). Most functionality works exactly the same","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, ℂ^3 * ℂ^2 * ℂ^4);\nC = im*A + (2.5-0.8im)*B\nscalarBA = dot(B,A)\nscalarAA = dot(A,A)\nnormA² = norm(A)^2\nU,S,Vd = tsvd(A,(1,3),(2,));\n@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA′ ≈ A\npermute(A,(1,3),(2,)) ≈ U*S*Vd","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"However, trying the following","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]\n@tensor d = A[a,b,c]*A[a,b,c]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"we obtain SpaceMismatch errors. The reason for this is that, with ComplexSpace, an index in a space ℂ^n can only be contracted with an index in the dual space dual(ℂ^n) == (ℂ^n)'. Because of the complex Euclidean inner product, the dual space is equivalent to the complex conjugate space, but not the the space itself.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"dual(ℂ^3) == conj(ℂ^3) == (ℂ^3)'\n(ℂ^3)' == ℂ^3\n@tensor d = conj(A[a,b,c])*A[a,b,c]\nd ≈ normA²","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This might seem overly strict or puristic, but we believe that it can help to catch errors, e.g. unintended contractions. In particular, contracting two indices both living in ℂ^n would represent an operation that is not invariant under arbitrary unitary basis changes.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It also makes clear the isomorphism between linear maps ℂ^n → ℂ^m and tensors in ℂ^m ⊗ (ℂ^n)':","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"m = TensorMap(randn, ComplexF64, ℂ^3, ℂ^4)\nm2 = permute(m, (1,2), ())\ncodomain(m2)\nspace(m, 1)\nspace(m, 2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Hence, spaces become their corresponding dual space if they are 'permuted' from the domain to the codomain or vice versa. Also, spaces in the domain are reported as their dual when probing them with space(A, i). Generalizing matrix vector and matrix matrix multiplication to arbitrary tensor contractions require that the two indices to be contracted have spaces which are each others dual. Knowing this, all the other functionality of tensors with CartesianSpace indices remains the same for tensors with ComplexSpace indices.","category":"page"},{"location":"man/tutorial/#Symmetries","page":"Tutorial","title":"Symmetries","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"So far, the functionality that we have illustrated seems to be just a convenience (or inconvenience?) wrapper around dense multidimensional arrays, e.g. Julia's Base Array. More power becomes visible when involving symmetries. With symmetries, we imply that there is some symmetry action defined on every vector space associated with each of the indices of a TensorMap, and the TensorMap is then required to be equivariant, i.e. it acts as an intertwiner between the tensor product representation on the domain and that on the codomain. By Schur's lemma, this means that the tensor is block diagonal in some basis corresponding to the irreducible representations that can be coupled to by combining the different representations on the different spaces in the domain or codomain. For Abelian symmetries, this does not require a basis change and it just imposes that the tensor has some block sparsity. Let's clarify all of this with some examples.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We start with a simple ℤ₂ symmetry:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V1 = ℤ₂Space(0=>3,1=>2)\ndim(V1)\nV2 = ℤ₂Space(0=>1,1=>1)\ndim(V2)\nA = Tensor(randn, V1*V1*V2')\nconvert(Array, A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we create a space 5-dimensional space V1, which has a three-dimensional subspace associated with charge 0 (the trivial irrep of ℤ₂) and a two-dimensional subspace with charge 1 (the non-trivial irrep). Similar for V2, where both subspaces are one- dimensional. Representing the tensor as a dense Array, we see that it is zero in those regions where the charges don't add to zero (modulo 2). Of course, the Tensor(Map) type in TensorKit.jl won't store these zero blocks, and only stores the non-zero information, which we can recognize also in the full Array representation.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"From there on, the resulting tensors support all of the same operations as the ones we encountered in the previous examples.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, V1'*V1*V2);\n@tensor C[a,b] := A[a,c,d]*B[c,b,d]\nU,S,V = tsvd(A,(1,3),(2,));\nU'*U # should be the identity on the corresponding domain = codomain\nU'*U ≈ one(U'*U)\nP = U*U' # should be a projector\nP*P ≈ P","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We also support other abelian symmetries, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = U₁Space(0=>2,1=>1,-1=>1)\ndim(V)\nA = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)\n\nV = GradedSpace[Irrep[U₁×ℤ₂]]((0,0)=>2,(1,1)=>1,(-1,0)=>1)\ndim(V)\nA = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, the dim of a TensorMap returns the number of linearly independent components, i.e. the number of non-zero entries in the case of an abelian symmetry. Also note that we can use × (obtained as \\times+TAB) to combine different symmetries. The general space associated with symmetries is a GradedSpace. Although this is actually an abstract type, it is the access point for users to construct spaces with arbitrary symmetries, and ℤ₂Space (also Z2Space as non-Unicode alternative) and U₁Space (or U1Space) are just convenient synonyms, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"GradedSpace[Irrep[U₁]](0=>3,1=>2,-1=>1) == U1Space(-1=>1,1=>2,0=>3)\nV = U₁Space(1=>2,0=>3,-1=>1)\nfor s in sectors(V)\n  @show s, dim(V, s)\nend\nU₁Space(-1=>1,0=>3,1=>2) == GradedSpace(Irrep[U₁](1)=>2, Irrep[U₁](0)=>3, Irrep[U₁](-1)=>1)\nsupertype(GradedSpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that GradedSpace is not immediately parameterized by some group G, but actually by the set of irreducible representations of G, denoted as Irrep[G]. Indeed, GradedSpace also supports a grading that is derived from the fusion ring of a (unitary) pre-fusion category. Also note that the order in which the charges and their corresponding subspace dimensionality are specified is irrelevant, and that the charges, henceforth called sectors (which is a more general name for charges or quantum numbers) are of a specific type, in this case Irrep[U₁] == U1Irrep. However, the GradedSpace[I] constructor automatically converts the keys in the list of Pairs it receives to the correct type. Alternatively, we can directly create the sectors of the correct type and use the generic GradedSpace","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"constructor. We can probe the subspace dimension of a certain sector s in a space V with dim(V, s). Finally, note that GradedSpace is also a subtype of EuclideanSpace{ℂ}, which implies that it still has the standard Euclidean inner product and we assume all representations to be unitary.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"TensorKit.jl also allows for non-abelian symmetries such as SU₂. In this case, the vector space is characterized via the spin quantum number (i.e. the irrep label of SU₂) for each of its subspaces, and is created using SU₂Space (or SU2Space or GradedSpace[Irrep[SU₂]])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = SU₂Space(0=>2,1/2=>1,1=>1)\ndim(V)\nV == GradedSpace[Irrep[SU₂]](0=>2, 1=>1, 1//2=>1)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that now V has a two-dimensional subspace with spin zero, and two one-dimensional subspaces with spin 1/2 and spin 1. However, a subspace with spin j has an additional 2j+1 dimensional degeneracy on which the irreducible representation acts. This brings the total dimension to 2*1 + 1*2 + 1*3. Creating a tensor with SU₂ symmetry yields","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)\nnorm(A) ≈ norm(convert(Array, A))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the full Array representation of the tensor has again many zeros, but it is less obvious to recognize the dense blocks, as there are additional zeros and the numbers in the original tensor data do not match with those in the Array. The reason is of course that the original tensor data now needs to be transformed with a construction known as fusion trees, which are made up out of the Clebsch-Gordan coefficients of the group. Indeed, note that the non-zero blocks are also no longer labeled by a list of sectors, but by pair of fusion trees. This will be explained further in the manual. However, the Clebsch-Gordan coefficients of the group are only needed to actually convert a tensor to an Array. For working with tensors with SU₂Space indices, e.g. contracting or factorizing them, the Clebsch-Gordan coefficients are never needed explicitly. Instead, recoupling relations are used to symbolically manipulate the basis of fusion trees, and this only requires what is known as the topological data of the group (or its representation theory).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In fact, this formalism extends beyond the case of group representations on vector spaces, and can also deal with super vector spaces (to describe fermions) and more general (unitary) fusion categories. Preliminary support for these generalizations is present in TensorKit.jl and will be extended in the near future.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these concepts will be explained throughout the remainder of this manual, including several details regarding their implementation. However, to just use tensors and their manipulations (contractions, factorizations, ...) in higher level algorithms (e.g. tensoer network algorithms), one does not need to know or understand most of these details, and one can immediately refer to the general interface of the TensorMap type, discussed on the last page. Adhering to this interface should yield code and algorithms that are oblivious to the underlying symmetries and can thus work with arbitrary symmetric tensors.","category":"page"},{"location":"lib/spaces/#Vector-spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"CurrentModule = TensorKit","category":"page"},{"location":"lib/spaces/#Type-hierarchy","page":"Vector spaces","title":"Type hierarchy","text":"","category":"section"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Field\nVectorSpace\nElementarySpace\nGeneralSpace\nInnerProductSpace\nEuclideanSpace\nCartesianSpace\nComplexSpace\nGradedSpace\nCompositeSpace\nProductSpace","category":"page"},{"location":"lib/spaces/#TensorKit.Field","page":"Vector spaces","title":"TensorKit.Field","text":"abstract type Field end\n\nAbstract type at the top of the type hierarchy for denoting fields over which vector spaces (or more generally, linear categories) can be defined. Two common fields are ℝ and ℂ, representing the field of real or complex numbers respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.VectorSpace","page":"Vector spaces","title":"TensorKit.VectorSpace","text":"abstract type VectorSpace end\n\nAbstract type at the top of the type hierarchy for denoting vector spaces, or, more accurately, 𝕜-linear categories. All instances of subtypes of VectorSpace will represent objects in 𝕜-linear monoidal categories.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ElementarySpace","page":"Vector spaces","title":"TensorKit.ElementarySpace","text":"abstract type ElementarySpace{𝕜} <: VectorSpace end\n\nElementary finite-dimensional vector space over a field 𝕜 that can be used as the index space corresponding to the indices of a tensor. ElementarySpace is a super type for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace.\n\nEvery elementary vector space should respond to the methods conj and dual, returning the complex conjugate space and the dual space respectively. The complex conjugate of the dual space is obtained as dual(conj(V)) === conj(dual(V)). These different spaces should be of the same type, so that a tensor can be defined as an element of a homogeneous tensor product of these spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GeneralSpace","page":"Vector spaces","title":"TensorKit.GeneralSpace","text":"struct GeneralSpace{𝕜} <: ElementarySpace{𝕜}\n\nA finite-dimensional space over an arbitrary field 𝕜 without additional structure. It is thus characterized by its dimension, and whether or not it is the dual and/or conjugate space. For a real field 𝕜, the space and its conjugate are the same.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.InnerProductSpace","page":"Vector spaces","title":"TensorKit.InnerProductSpace","text":"abstract type InnerProductSpace{𝕜} <: ElementarySpace{𝕜} end\n\nAbstract type for denoting vector spaces with an inner product, thus a canonical mapping from dual(V) to V (for 𝕜 ⊆ ℝ) or from dual(V) to conj(V) (otherwise). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.EuclideanSpace","page":"Vector spaces","title":"TensorKit.EuclideanSpace","text":"abstract type EuclideanSpace{𝕜} <: InnerProductSpace{𝕜} end\n\nAbstract type for denoting real or complex spaces with a standard Euclidean inner product (i.e. orthonormal basis, and the metric is identity), such that the dual space is naturally isomorphic to the conjugate space dual(V) == conj(V) (in the complex case) or even to the space itself dual(V) == V (in the real case), also known as the category of finite-dimensional Hilbert spaces FdHilb. In the language of categories, this subtype represents dagger or unitary categories, and support an adjoint operation.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CartesianSpace","page":"Vector spaces","title":"TensorKit.CartesianSpace","text":"struct CartesianSpace <: EuclideanSpace{ℝ}\n\nA real Euclidean space ℝ^d, which is therefore self-dual. CartesianSpace has no additonal structure and is completely characterised by its dimension d. This is the vector space that is implicitly assumed in most of matrix algebra.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ComplexSpace","page":"Vector spaces","title":"TensorKit.ComplexSpace","text":"struct ComplexSpace <: EuclideanSpace{ℂ}\n\nA standard complex vector space ℂ^d with Euclidean inner product and no additional structure. It is completely characterised by its dimension and whether its the normal space or its dual (which is canonically isomorphic to the conjugate space).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GradedSpace","page":"Vector spaces","title":"TensorKit.GradedSpace","text":"struct GradedSpace{I<:Sector, D} <: EuclideanSpace{ℂ}\n    dims::D\n    dual::Bool\nend\n\nA complex Euclidean space with a direct sum structure corresponding to labels in a set I, the objects of which have the structure of a monoid with respect to a monoidal product ⊗. In practice, we restrict the label set to be a set of superselection sectors of type I<:Sector, e.g. the set of distinct irreps of a finite or compact group, or the isomorphism classes of simple objects of a unitary and pivotal (pre-)fusion category.\n\nHere dims represents the degeneracy or multiplicity of every sector.\n\nThe data structure D of dims will depend on the result Base.IteratorElsize(values(I)); if the result is of type HasLength or HasShape, dims will be stored in a NTuple{N,Int} with N = length(values(I)). This requires that a sector s::I can be transformed into an index via s == getindex(values(I), i) and i == findindex(values(I), s). If Base.IteratorElsize(values(I)) results IsInfinite() or SizeUnknown(), a SectorDict{I,Int} is used to store the non-zero degeneracy dimensions with the corresponding sector as key. The parameter D is hidden from the user and should typically be of no concern\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CompositeSpace","page":"Vector spaces","title":"TensorKit.CompositeSpace","text":"abstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\n\nAbstract type for composite spaces that are defined in terms of a number of elementary vector spaces of a homogeneous type S<:ElementarySpace{𝕜}.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ProductSpace","page":"Vector spaces","title":"TensorKit.ProductSpace","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n\nA ProductSpace is a tensor product space of N vector spaces of type S<:ElementarySpace. Only tensor products between ElementarySpace objects of the same type are allowed.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#Methods","page":"Vector spaces","title":"Methods","text":"","category":"section"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Methods often apply similar to e.g. spaces and corresponding tensors or tensor maps, e.g.:","category":"page"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"field\nsectortype\nsectors\nhassector\ndim\ndims\nblocksectors\nblockdim\nspace","category":"page"},{"location":"lib/spaces/#TensorKit.field","page":"Vector spaces","title":"TensorKit.field","text":"field(V::VectorSpace) -> Field\n\nReturn the field type over which a vector space is defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectortype","page":"Vector spaces","title":"TensorKit.sectortype","text":"sectortype(a) -> Type{<:Sector}\n\nReturn the type of sector over which object a (e.g. a representation space or a tensor) is defined. Also works in type domain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectors","page":"Vector spaces","title":"TensorKit.sectors","text":"sectors(V::ElementarySpace)\n\nReturn an iterator over the different sectors of V.\n\n\n\n\n\nsectors(P::ProductSpace{S, N}) where {S<:ElementarySpace}\n\nReturn an iterator over all possible combinations of sectors (represented as an NTuple{N, sectortype(S)}) that can appear within the tensor product space P.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.hassector","page":"Vector spaces","title":"TensorKit.hassector","text":"hassector(V::VectorSpace, a::Sector) -> Bool\n\nReturn whether a vector space V has a subspace corresponding to sector a with non-zero dimension, i.e. dim(V, a) > 0.\n\n\n\n\n\nhassector(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) where {S<:ElementarySpace}\n-> Bool\n\nQuery whether P has a non-zero degeneracy of sector s, representing a combination of sectors on the individual tensor indices.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dim","page":"Vector spaces","title":"TensorKit.dim","text":"dim(V::VectorSpace) -> Int\n\nReturn the total dimension of the vector space V as an Int.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dims","page":"Vector spaces","title":"TensorKit.dims","text":"dims(::ProductSpace{S, N}) -> Dims{N} = NTuple{N, Int}\n\nReturn the dimensions of the spaces in the tensor product space as a tuple of integers.\n\n\n\n\n\ndims(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) where {S<:ElementarySpace}\n-> Dims{N} = NTuple{N, Int}\n\nReturn the degeneracy dimensions corresponding to a tuple of sectors s for each of the spaces in the tensor product P.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blocksectors","page":"Vector spaces","title":"TensorKit.blocksectors","text":"blocksectors(P::ProductSpace)\n\nReturn an iterator over the different unique coupled sector labels, i.e. the different fusion outputs that can be obtained by fusing the sectors present in the different spaces that make up the ProductSpace instance.\n\n\n\n\n\nblocksectors(W::HomSpace)\n\nReturn an iterator over the different unique coupled sector labels, i.e. the intersection of the different fusion outputs that can be obtained by fusing the sectors present in the domain, as well as from the codomain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blockdim","page":"Vector spaces","title":"TensorKit.blockdim","text":"blockdim(P::ProductSpace, c::Sector)\n\nReturn the total dimension of a coupled sector c in the product space, by summing over all dim(P, s) for all tuples of sectors s::NTuple{N, <:Sector} that can fuse to  c, counted with the correct multiplicity (i.e. number of ways in which s can fuse to c).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.space","page":"Vector spaces","title":"TensorKit.space","text":"space(a) -> VectorSpace\n\nReturn the vector space associated to object a.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The following methods act specifically on ElementarySpace spaces:","category":"page"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"isdual\ndual\nconj\nflip\n:⊕\noneunit\nsupremum\ninfimum","category":"page"},{"location":"lib/spaces/#TensorKit.isdual","page":"Vector spaces","title":"TensorKit.isdual","text":"isdual(V::ElementarySpace) -> Bool\n\nReturn wether an ElementarySpace V is normal or rather a dual space. Always returns false for spaces where V == dual(V).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dual","page":"Vector spaces","title":"TensorKit.dual","text":"dual(V::VectorSpace) -> VectorSpace\n\nReturn the dual space of V; also obtained via V'. This should satisfy dual(dual(V)) == V. It is assumed that typeof(V) == typeof(V').\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.conj","page":"Vector spaces","title":"Base.conj","text":"conj(V::S) where {S<:ElementarySpace} -> S\n\nReturn the conjugate space of V. This should satisfy conj(conj(V)) == V.\n\nFor field(V)==ℝ, conj(V) == V. It is assumed that typeof(V) == typeof(conj(V)).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.flip","page":"Vector spaces","title":"TensorKit.flip","text":"flip(V::S) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that has the same value of isdual as dual(V), but yet is isomorphic to V rather than to dual(V). The spaces flip(V) and dual(V) only differ in the case of GradedSpace{I}.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:⊕","page":"Vector spaces","title":"TensorKit.:⊕","text":"⊕(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the direct sum sum of the spaces V1, V2, ... Note that all the individual spaces should have the same value for isdual, as otherwise the direct sum is not defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.oneunit","page":"Vector spaces","title":"Base.oneunit","text":"oneunit(V::S) where {S<:ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the trivial one-dimensional space, i.e. the space that is isomorphic to the corresponding field. Note that this is different from one(V::S), which returns the empty product space ProductSpace{S,0}(()).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.supremum","page":"Vector spaces","title":"TensorKit.supremum","text":"supremum(V1::ElementarySpace, V2::ElementarySpace, V3::ElementarySpace...)\n\nReturn the supremum of a number of elementary spaces, i.e. an instance V::ElementarySpace such that V ≿ V1, V ≿ V2, ... and no other W ≺ V has this property. This requires that all arguments have the same value of isdual( ), and also the return value V will have the same value.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.infimum","page":"Vector spaces","title":"TensorKit.infimum","text":"infimum(V1::ElementarySpace, V2::ElementarySpace, V3::ElementarySpace...)\n\nReturn the infimum of a number of elementary spaces, i.e. an instance V::ElementarySpace such that V ≾ V1, V ≾ V2, ... and no other W ≻ V has this property. This requires that all arguments have the same value of isdual( ), and also the return value V will have the same value.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"while the following also work on both ElementarySpace and ProductSpace","category":"page"},{"location":"lib/spaces/","page":"Vector spaces","title":"Vector spaces","text":"fuse\n:⊗\n:⊠\none\nismonomorphic\nisepimorphic\nisisomorphic\ninsertunit","category":"page"},{"location":"lib/spaces/#TensorKit.fuse","page":"Vector spaces","title":"TensorKit.fuse","text":"fuse(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\nfuse(P::ProductSpace{S}) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that is isomorphic to the fusion product of the individual spaces V1, V2, ..., or the spaces contained in P.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:⊗","page":"Vector spaces","title":"TensorKit.:⊗","text":"⊗(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\n\nCreate a ProductSpace{S}(V1, V2, V3...) representing the tensor product of several elementary vector spaces. For convience, Julia's regular multiplication operator * applied to vector spaces has the same effect.\n\nThe tensor product structure is preserved, see fuse for returning a single elementary space of type S that is isomorphic to this tensor product.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:⊠","page":"Vector spaces","title":"TensorKit.:⊠","text":"⊠(s₁::Sector, s₂::Sector)\n\nGiven two sectors s₁ and s₂, which label an isomorphism class of simple objects in a fusion category C₁ and C₂, s1 ⊠ s2 (obtained as \boxtimes+TAB) labels the isomorphism class of simple objects in the Deligne tensor product category C₁  C₂.\n\nThe Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have Irrep[G₁] ⊠ Irrep[G₂] == Irrep[G₁ × G₂].\n\n\n\n\n\n⊠(V₁::VectorSpace, V₂::VectorSpace)\n\nGiven two vector spaces V₁ and V₂ (ElementarySpace or ProductSpace), or thus, objects of corresponding fusion categories C₁ and C₂, V₁  V₂ constructs the Deligne tensor product, an object in C₁  C₂ which is the natural tensor product of those categories. In particular, the corresponding type of sectors (simple objects) is given by sectortype(V₁ ⊠ V₂) == sectortype(V₁) ⊠ sectortype(V₂) and can be thought of as a tuple of the individual sectors.\n\nThe Deligne tensor product also works in the type domain and for sectors and tensors. For group representations, we have Rep[G₁] ⊠ Rep[G₂] == Rep[G₁ × G₂], i.e. these are the natural representation spaces of the direct product of two groups.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.one","page":"Vector spaces","title":"Base.one","text":"one(::Sector) -> Sector\none(::Type{<:Sector}) -> Sector\n\nReturn the unit element within this type of sector.\n\n\n\n\n\none(::S) where {S<:ElementarySpace} -> ProductSpace{S, 0}\none(::ProductSpace{S}) where {S<:ElementarySpace} -> ProductSpace{S, 0}\n\nReturn a tensor product of zero spaces of type S, i.e. this is the unit object under the tensor product operation, such that V ⊗ one(V) == V.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.ismonomorphic","page":"Vector spaces","title":"TensorKit.ismonomorphic","text":"ismonomorphic(V1::VectorSpace, V2::VectorSpace)\nV1 ≾ V2\n\nReturn whether there exist monomorphisms from V1 to V2, i.e. 'injective' morphisms with left inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isepimorphic","page":"Vector spaces","title":"TensorKit.isepimorphic","text":"isepimorphic(V1::VectorSpace, V2::VectorSpace)\nV1 ≿ V2\n\nReturn whether there exist epimorphisms from V1 to V2, i.e. 'surjective' morphisms with right inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.isisomorphic","page":"Vector spaces","title":"TensorKit.isisomorphic","text":"isisomorphic(V1::VectorSpace, V2::VectorSpace)\nV1 ≅ V2\n\nReturn if V1 and V2 are isomorphic, meaning that there exists isomorphisms from V1 to V2, i.e. morphisms with left and right inverses.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.insertunit","page":"Vector spaces","title":"TensorKit.insertunit","text":"insertunit(P::ProductSpace, i::Int = length(P)+1; dual = false, conj = false)\n\nFor P::ProductSpace{S,N}, this adds an extra tensor product factor at position 1 <= i <= N+1 (last position by default) which is just a the S-equivalent of the underlying field of scalars, i.e. oneunit(S). With the keyword arguments, one can choose to insert the conjugated or dual space instead, which are all isomorphic to the field of scalars.\n\n\n\n\n\n","category":"function"},{"location":"man/intro/#s_intro","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Before providing a typical \"user guide\" and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.","category":"page"},{"location":"man/intro/#ss_whatistensor","page":"Introduction","title":"What is a tensor?","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor t is an element from the   tensor product of N vector spaces   V_1  V_2  V_N, where N is referred to as the rank or order of the   tensor, i.e.\nt  V_1  V_2    V_N","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"If you think of a tensor as an object with indices, a rank N tensor has N indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"As the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field of scalars, e.g. there is no meaning in ℝ^5  ℂ^3. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on Vector spaces.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Aside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term \"tensor map\" as follows:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor map t is a linear map from a source or domain   W_1  W_2    W_N_2 to a target or codomain V_1  V_2    V_N_1, i.e.\ntW_1  W_2    W_N_2  V_1  V_2    V_N_1","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor of rank N is then just a special case of a tensor map with N_1 = N and N_2 = 0. A contraction between two tensors is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map W  V is often denoted as a rank 2 tensor in V  W^*, where W^* corresponds to the dual space of W. This simple example introduces two new concepts.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Typical vector spaces can appear in the domain and codomain in different related forms,  e.g. as normal space or dual space. In fact, the most generic case is that every vector  space V has associated with it  a dual space V^*,  a conjugate space  overlineV and a conjugate dual space overlineV^*. The four different  vector spaces V, V^*, overlineV and overlineV^* correspond to the  representation spaces of respectively the fundamental, dual or contragredient, complex  conjugate and dual complex conjugate representation of the general linear group  mathsfGL(V). In index notation these spaces are denoted with respectively  contravariant (upper), covariant (lower), dotted contravariant and dotted covariant  indices.\nFor real vector spaces, the conjugate (dual) space is identical to the normal (dual)  space and we only have upper and lower indices, i.e. this is the setting of e.g.  general relativity. For (complex) vector spaces with a sesquilinear inner product  overlineV  V  ℂ, the inner product allows to define an isomorphism from the  conjugate space to the dual space (known as  Riesz representation theorem  in the more general context of Hilbert spaces).\nIn particular, in spaces with a Euclidean inner product (the setting of e.g. quantum  mechanics), the conjugate and dual space are naturally isomorphic (because the dual and  conjugate representation of the unitary group are the same). Again we only need upper  and lower indices (or kets and bras).\nFinally, in ℝ^d with a Euclidean inner product, these four different spaces are all  equivalent and we only need one type of index. The space is completely characterized by  its dimension d. This is the setting of much of classical mechanics and we refer to  such tensors as cartesian tensors and the corresponding space as cartesian space. These  are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some AbstractArray{<:Real,N} in Julia) without loss of structure.\nThe implementation of all of this is discussed in Vector spaces.\nIn the generic case, the identification between maps W  V and tensors in  V  W^* is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between V  W and W  V that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories, which is introduced on the next  page. Nonetheless, we try to hide these canonical isomorphisms from the user wherever  possible, and one does not need to know category theory to be able to use this package.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"This brings us to our final (yet formal) definition","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor (map) is a homomorphism between two objects from the category mathbfVect   (or some subcategory thereof). In practice, this will be mathbfFinVect, the   category of finite dimensional vector spaces. More generally even, our concept of a   tensor makes sense, in principle, for any linear (a.k.a. mathbfVect-enriched)   monoidal category. We refer to the next page on   \"Monoidal categories and their properties\".","category":"page"},{"location":"man/intro/#ss_symmetries","page":"Introduction","title":"Symmetries and block sparsity","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group mathsfG which acts on the vector spaces V in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space V can be specified as the number of times every irreducible representation (irrep) a of mathsfG appears, i.e.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"V = bigoplus_a ℂ^n_a  R_a","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"with R_a the space associated with irrep a of mathsfG, which itself has dimension d_a (often called the quantum dimension), and n_a the number of times this irrep appears in V. If the unitary irrep a for g  mathsfG is given by u_a(g), then there exists a specific basis for V such that the group action of mathsfG on V is given by the unitary representation","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"u(g) = bigoplus_a  𝟙_n_a  u_a(g)","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"with 𝟙_n_a the n_a  n_a identity matrix. The total dimension of V is given by _a n_a d_a.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps tW_1  W_2    W_N_2  V_1  V_2    V_N_1 that are equivariant under the symmetry, i.e. that act as intertwiners between the symmetry action on the domain and the codomain. Indeed, such tensors should be block diagonal because of Schur's lemma, but only after we couple the individual irreps in the spaces W_i to a joint irrep, which is then again split into the individual irreps of the spaces V_i. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebsch–Gordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups mathsfG. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, and only requires the topological data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah's W-symbol in the case of mathsfSU_2). In particular, we don't actually need the Clebsch–Gordan coefficients themselves (but they can be useful for checking purposes).","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Hence, a second major part of TensorKit.jl is the interface and implementation for specifying symmetries, and further details are provided in Sectors, representation spaces and fusion trees.","category":"page"},{"location":"lib/sectors/#Symmetry-sectors-an-fusion-trees","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"","category":"section"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"CurrentModule = TensorKit","category":"page"},{"location":"lib/sectors/#Type-hierarchy","page":"Symmetry sectors an fusion trees","title":"Type hierarchy","text":"","category":"section"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"Sector\nSectorValues\nFusionStyle\nBraidingStyle\nIrrep\nZNIrrep\nU1Irrep\nSU2Irrep\nCU1Irrep\nFibonacciAnyon\nFusionTree","category":"page"},{"location":"lib/sectors/#TensorKit.Sector","page":"Symmetry sectors an fusion trees","title":"TensorKit.Sector","text":"abstract type Sector end\n\nAbstract type for representing the (isomorphism classes of) simple objects in (unitary and pivotal) (pre-)fusion categories, e.g. the irreducible representations of a finite or compact group. Subtypes I<:Sector as the set of labels of a GradedSpace.\n\nEvery new I<:Sector should implement the following methods:\n\none(::Type{I}): unit element of I\nconj(a::I): a, conjugate or dual label of a\n⊗(a::I, b::I): iterable with unique fusion outputs of a  b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::I, b::I, c::I): number of times c appears in a ⊗ b, i.e. the   multiplicity\nFusionStyle(::Type{I}): Abelian(), SimpleNonAbelian() or   DegenerateNonAbelian()\nBraidingStyle(::Type{I}): Bosonic(), Fermionic(), Anyonic(), ...\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I): F-symbol: scalar (in case of   Abelian/SimpleNonAbelian) or matrix (in case of DegenerateNonAbelian)\nRsymbol(a::I, b::I, c::I): R-symbol: scalar (in case of   Abelian/SimpleNonAbelian) or matrix (in case of DegenerateNonAbelian)\n\nand optionally\n\ndim(a::I): quantum dimension of sector a\nfrobeniusschur(a::I): Frobenius-Schur indicator of a\nBsymbol(a::I, b::I, c::I): B-symbol: scalar (in case of   Abelian/SimpleNonAbelian) or matrix (in case of DegenerateNonAbelian)\ntwist(a::I) -> twist of sector a\n\nand optionally, if FusionStyle(I) isa DegenerateNonAbelian\n\nvertex_ind2label(i::Int, a::I, b::I, c::I) -> a custom label for the ith copy of   c appearing in a ⊗ b\n\nFurthermore, iterate and Base.IteratorSize should be made to work for the singleton type SectorValues{I}.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.SectorValues","page":"Symmetry sectors an fusion trees","title":"TensorKit.SectorValues","text":"struct SectorValues{I<:Sector}\n\nSingleton type to represent an iterator over the possible values of type I, whose instance is obtained as values(I). For a new I::Sector, the following should be defined\n\nBase.iterate(::SectorValues{I}[, state]): iterate over the values\nBase.IteratorSize(::Type{SectorValues{I}}): HasLenght(), SizeUnkown()   or IsInfinite() depending on whether the number of values of type I is finite   (and sufficiently small) or infinite; for a large number of values, SizeUnknown() is   recommend because this will trigger the use of GenericGradedSpace.\n\nIf IteratorSize(I) == HasLength(), also the following must be implemented:\n\nBase.length(::SectorValues{I}): the number of different values\nBase.getindex(::SectorValues{I}, i::Int): a mapping between an index i and an   instance of I\nfindindex(::SectorValues{I}, c::I): reverse mapping between a value c::I and an   index i::Integer ∈ 1:length(values(I))\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.FusionStyle","page":"Symmetry sectors an fusion trees","title":"TensorKit.FusionStyle","text":"FusionStyle(a::Sector) -> ::FusionStyle\nFusionStyle(I::Type{<:Sector}) -> ::FusionStyle\n\nReturn the type of fusion behavior of sectors of type I, which can be either\n\nAbelian(): single fusion output when fusing two sectors;\nSimpleNonAbelian(): multiple outputs, but every output occurs at most one,   also known as multiplicity free (e.g. irreps of SU(2));\nDegenerateNonAbelian(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\nThere is an abstract supertype NonAbelian of which both SimpleNonAbelian and DegenerateNonAbelian are subtypes.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.BraidingStyle","page":"Symmetry sectors an fusion trees","title":"TensorKit.BraidingStyle","text":"BraidingStyle(::Sector) -> ::BraidingStyle\nBraidingStyle(I::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding and twist behavior of sectors of type I, which can be either\n\nBosonic(): symmetric braiding with trivial twist (i.e. identity)\nFermionic(): symmetric braiding with non-trivial twist (squares to identity)\nAnyonic(): general R_(ab)^c phase or matrix (depending on SimpleNonAbelian or   DegenerateNonAbelian fusion) and arbitrary twists\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: isone(Rsymbol(b,a,c)*Rsymbol(a,b,c)) == true) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.Irrep","page":"Symmetry sectors an fusion trees","title":"TensorKit.Irrep","text":"abstract type Irrep{G<:Group} <: Sector end\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of a group G. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.\n\nActual concrete implementations of those irreps can be obtained as Irrep[G], or via their actual name, which generically takes the form (asciiG)Irrep, i.e. the ASCII spelling of the group name followed by Irrep.\n\nAll irreps have BraidingStyle equal to Bosonic() and thus trivial twists.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.ZNIrrep","page":"Symmetry sectors an fusion trees","title":"TensorKit.ZNIrrep","text":"ZNIrrep{N}(n::Integer)\nIrrep[ℤ{N}](n::Integer)\n\nRepresents irreps of the group ℤ_N for some value of N<64. (We need 2*(N-1) <= 127 in order for a ⊗ b to work correctly.) For N equals 2, 3 or 4, ℤ{N} can be replaced by ℤ₂, ℤ₃, ℤ₄, whereas Parity is a synonym for Irrep{ℤ₂}. An arbitrary Integer n can be provided to the constructor, but only the value mod(n, N) is relevant.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.U1Irrep","page":"Symmetry sectors an fusion trees","title":"TensorKit.U1Irrep","text":"U1Irrep(j::Real)\nIrrep[U₁](j::Real)\n\nRepresents irreps of the group U₁. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps ofU₁subgroups ofSU₂, such as the Sz of spin-1/2 system. Hence, the charge is stored as aHalfIntfrom the package HalfIntegers.jl, but can be entered as arbitraryReal`. The sequence of the charges is: 0, 1/2, -1/2, 1, -1, ...\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.SU2Irrep","page":"Symmetry sectors an fusion trees","title":"TensorKit.SU2Irrep","text":"SU2Irrep(j::Real)\nIrrep[SU₂](j::Real)\n\nRepresents irreps of the group SU₂. The irrep is labelled by a half integer j which can be entered as an abitrary Real, but is stored as a HalfInt from the HalfIntegers.jl package.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.CU1Irrep","page":"Symmetry sectors an fusion trees","title":"TensorKit.CU1Irrep","text":"CU1Irrep(j, s = ifelse(j>zero(j), 2, 0))\nIrrep[CU₁](j, s = ifelse(j>zero(j), 2, 0))\n\nRepresents irreps of the group U₁  C (U₁ and charge conjugation or reflection), which is also known as just O₂. The irrep is labelled by a positive half integer j (the U₁ charge) and an integer s indicating the behaviour under charge conjugation. They take values:\n\nif j == 0, s = 0 (trivial charge conjugation) or   s = 1 (non-trivial charge conjugation)\nif j > 0, s = 2 (two-dimensional representation)\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.FibonacciAnyon","page":"Symmetry sectors an fusion trees","title":"TensorKit.FibonacciAnyon","text":"struct FibonacciAnyon <: Sector\nFibonacciAnyon(s::Union{Symbol, Integer})\n\nRepresents the anyons (isomorphism classes of simple objects) of the Fibonacci fusion category. It can take two values, corresponding to the trivial sector FibonacciAnyon(:I) == FibonacciAnyon(0) and the non-trivial sector FibonacciAnyon(:τ) = FibonacciAnyon(1) with fusion rules τ  τ = 1  τ.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#TensorKit.FusionTree","page":"Symmetry sectors an fusion trees","title":"TensorKit.FusionTree","text":"struct FusionTree{I, N, M, L, T}\n\nRepresents a fusion tree of sectors of type I<:Sector, fusing (or splitting) N uncoupled sectors to a coupled sector. (It actually represents a splitting tree, but fusion tree is a more common term). The isdual field indicates whether an isomorphism is present (if the corresponding value is true) or not. The field uncoupled contains the sectors coming out of the splitting trees, before the possible 𝑍 isomorphism. This fusion tree has M=max(0, N-2) inner lines. Furthermore, for FusionStyle(I) isa DegenerateNonAbelian, the L=max(0, N-1) corresponding vertices carry a label of type T. If FusionStyle(I) isa Union{Abelian, SimpleNonAbelian}, T = Nothing.\n\n\n\n\n\n","category":"type"},{"location":"lib/sectors/#Methods-for-defining-and-characterizing-Sector-subtypes","page":"Symmetry sectors an fusion trees","title":"Methods for defining and characterizing Sector subtypes","text":"","category":"section"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"Base.one(::Sector)\ndual(::Sector)\nNsymbol\nFsymbol\nRsymbol\nBsymbol\ndim(::Sector)\nfrobeniusschur\ntwist\nBase.isreal(::Type{<:Sector})\nTensorKit.vertex_labeltype\nTensorKit.vertex_ind2label\n⊠(::Sector, ::Sector)","category":"page"},{"location":"lib/sectors/#Base.one-Tuple{Sector}","page":"Symmetry sectors an fusion trees","title":"Base.one","text":"one(::Sector) -> Sector\none(::Type{<:Sector}) -> Sector\n\nReturn the unit element within this type of sector.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.dual-Tuple{Sector}","page":"Symmetry sectors an fusion trees","title":"TensorKit.dual","text":"dual(a::Sector) -> Sector\n\nReturn the conjugate label conj(a).\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.Nsymbol","page":"Symmetry sectors an fusion trees","title":"TensorKit.Nsymbol","text":"Nsymbol(a::I, b::I, c::I) where {I<:Sector} -> Integer\n\nReturn an Integer representing the number of times c appears in the fusion product a ⊗ b. Could be a Bool if FusionStyle(I) == Abelian() or SimpleNonAbelian().\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.Fsymbol","page":"Symmetry sectors an fusion trees","title":"TensorKit.Fsymbol","text":"Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I<:Sector}\n\nReturn the F-symbol F^abc_d that associates the two different fusion orders of sectors a, b and c into an ouput sector d, using either an intermediate sector a  b  e or b  c  f:\n\na-<-μ-<-e-<-ν-<-d                                     a-<-λ-<-d\n    ∨       ∨       -> Fsymbol(a,b,c,d,e,f)[μ,ν,κ,λ]      ∨\n    b       c                                             f\n                                                          v\n                                                      b-<-κ\n                                                          ∨\n                                                          c\n\nIf FusionStyle(I) is Abelian or SimpleNonAbelian, the F-symbol is a number. Otherwise it is a rank 4 array of size (Nsymbol(a, b, e), Nsymbol(e, c, d), Nsymbol(b, c, f), Nsymbol(a, f, d)).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.Rsymbol","page":"Symmetry sectors an fusion trees","title":"TensorKit.Rsymbol","text":"Rsymbol(a::I, b::I, c::I) where {I<:Sector}\n\nReturns the R-symbol R^ab_c that maps between c  a  b and c  b  a as in\n\na -<-μ-<- c                                 b -<-ν-<- c\n     ∨          -> Rsymbol(a,b,c)[μ,ν]           v\n     b                                           a\n\nIf FusionStyle(I) is Abelian() or SimpleNonAbelian(), the R-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a,b,c) == Nsymbol(b,a,c).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.Bsymbol","page":"Symmetry sectors an fusion trees","title":"TensorKit.Bsymbol","text":"Bsymbol(a::I, b::I, c::I) where {I<:Sector}\n\nReturn the value of B^ab_c which appears in transforming a splitting vertex into a fusion vertex using the transformation\n\na -<-μ-<- c                                                    a -<-ν-<- c\n     ∨          -> √(dim(c)/dim(a)) * Bsymbol(a,b,c)[μ,ν]           ∧\n     b                                                            dual(b)\n\nIf FusionStyle(I) is Abelian() or SimpleNonAbelian(), the B-symbol is a number. Otherwise it is a square matrix with row and column size Nsymbol(a, b, c) == Nsymbol(c, dual(b), a).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.dim-Tuple{Sector}","page":"Symmetry sectors an fusion trees","title":"TensorKit.dim","text":"dim(a::Sector)\n\nReturn the (quantum) dimension of the sector a.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.frobeniusschur","page":"Symmetry sectors an fusion trees","title":"TensorKit.frobeniusschur","text":"frobeniusschur(a::Sector)\n\nReturn the Frobenius-Schur indicator of a sector a.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.twist","page":"Symmetry sectors an fusion trees","title":"TensorKit.twist","text":"twist(a::Sector)\n\nReturn the twist of a sector a\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#Base.isreal-Tuple{Type{#s4} where #s4<:Sector}","page":"Symmetry sectors an fusion trees","title":"Base.isreal","text":"isreal(::Type{<:Sector}) -> Bool\n\nReturn whether the topological data (Fsymbol, Rsymbol) of the sector is real or not (in which case it is complex).\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.vertex_labeltype","page":"Symmetry sectors an fusion trees","title":"TensorKit.vertex_labeltype","text":"vertex_labeltype(I::Type{<:Sector}) -> Type\n\nReturn the type of labels for the fusion vertices of sectors of type I.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.vertex_ind2label","page":"Symmetry sectors an fusion trees","title":"TensorKit.vertex_ind2label","text":"vertex_ind2label(k::Int, a::I, b::I, c::I) where {I<:Sector}\n\nConvert the index k of the fusion vertex (a,b)->c into a label. For FusionStyle(I) == Abelian() or FusionStyle(I) == NonAbelian(), where every fusion output occurs only once and k == 1, the default is to suppress vertex labels by setting them equal to nothing. For FusionStyle(I) == DegenerateNonAbelian(), the default is to just use k, unless a specialized method is provided.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.:⊠-Tuple{Sector,Sector}","page":"Symmetry sectors an fusion trees","title":"TensorKit.:⊠","text":"⊠(s₁::Sector, s₂::Sector)\n\nGiven two sectors s₁ and s₂, which label an isomorphism class of simple objects in a fusion category C₁ and C₂, s1 ⊠ s2 (obtained as \boxtimes+TAB) labels the isomorphism class of simple objects in the Deligne tensor product category C₁  C₂.\n\nThe Deligne tensor product also works in the type domain and for spaces and tensors. For group representations, we have Irrep[G₁] ⊠ Irrep[G₂] == Irrep[G₁ × G₂].\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#Methods-for-manipulating-fusion-trees-or-pairs-of-fusion-splitting-trees","page":"Symmetry sectors an fusion trees","title":"Methods for manipulating fusion trees or pairs of fusion-splitting trees","text":"","category":"section"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"The main method for manipulating a fusion-splitting tree pair is","category":"page"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"braid(f1::FusionTree{G}, f2::FusionTree{G}, levels1::IndexTuple, levels2::IndexTuple,\n        p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {G<:Sector,N₁,N₂}","category":"page"},{"location":"lib/sectors/#TensorKit.braid-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N}} where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G<:Sector","page":"Symmetry sectors an fusion trees","title":"TensorKit.braid","text":"braid(f1::FusionTree{I}, f2::FusionTree{I},\n        levels1::IndexTuple, levels2::IndexTuple,\n        p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I<:Sector, N₁, N₂}\n-> <:AbstractDict{Tuple{FusionTree{I, N₁}, FusionTree{I, N₂}}, <:Number}\n\nInput is a fusion-splitting tree pair that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the splitting tree f1 and fusion tree f2, such that the incoming sectors f2.uncoupled are fused to f1.coupled == f2.coupled and then to the outgoing sectors f1.uncoupled. Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors p1 become outgoing and sectors p2 become incoming. The uncoupled indices in splitting tree f1 and fusion tree f2 have levels (or depths) levels1 and levels2 respectively, which determines how indices braid. In particular, if i and j cross, τ_ij is applied if levels[i] < levels[j] and τ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"which, for FusionStyle(G) isa SymmetricBraiding, simplifies to","category":"page"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"permute(f1::FusionTree{G}, f2::FusionTree{G},\n        p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {G<:Sector,N₁,N₂}","category":"page"},{"location":"lib/sectors/#TensorKit.permute-Union{Tuple{N₂}, Tuple{N₁}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M where N,FusionTree{G,N,M,L,T} where T where L where M where N,Tuple{Vararg{Int64,N₁}},Tuple{Vararg{Int64,N₂}}}} where N₂ where N₁ where G<:Sector","page":"Symmetry sectors an fusion trees","title":"TensorKit.permute","text":"permute(f1::FusionTree{I}, f2::FusionTree{I},\n        p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int}) where {I, N₁, N₂}\n-> <:AbstractDict{Tuple{FusionTree{I, N₁}, FusionTree{I, N₂}}, <:Number}\n\nInput is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (t1) and incoming sectors (t2) respectively (with identical coupled sector t1.coupled == t2.coupled). Computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors p1 become outgoing and sectors p2 become incoming.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"These operations are implemented by composing the following more elementary manipulations","category":"page"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"braid(f::FusionTree{G,N}, levels::NTuple{N,Int}, p::NTuple{N,Int}) where {G<:Sector, N}\npermute(f::FusionTree{G,N}, p::NTuple{N,Int}) where {G<:Sector, N}\nTensorKit.repartition\nTensorKit.artin_braid","category":"page"},{"location":"lib/sectors/#TensorKit.braid-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}} where N where G<:Sector","page":"Symmetry sectors an fusion trees","title":"TensorKit.braid","text":"braid(f::FusionTree{<:Sector, N}, levels::NTuple{N, Int}, p::NTuple{N, Int})\n-> <:AbstractDict{typeof(t), <:Number}\n\nPerform a braiding of the uncoupled indices of the fusion tree f and returns the result as a <:AbstractDict of output trees and corresponding coefficients. The braiding is specified by specifying that the new sector at position i was originally at position p[i] and assinging to every index a distinct level or depth levels[i]. This permutation is then decomposed into elementary swaps between neighbouring indices, where the swaps are applied as braids such that if i and j cross, τ_ij is applied if levels[i] < levels[j] and τ_ji^-1 if levels[i] > levels[j]. This does not allow to encode the most general braid, but a general braid can be obtained by combining such operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.permute-Union{Tuple{N}, Tuple{G}, Tuple{FusionTree{G,N,M,L,T} where T where L where M,Tuple{Vararg{Int64,N}}}} where N where G<:Sector","page":"Symmetry sectors an fusion trees","title":"TensorKit.permute","text":"permute(f::FusionTree, p::NTuple{N, Int}) -> <:AbstractDict{typeof(t), <:Number}\n\nPerform a permutation of the uncoupled indices of the fusion tree f and returns the result as a <:AbstractDict of output trees and corresponding coefficients; this requires that BraidingStyle(sectortype(f)) isa SymmetricBraiding.\n\n\n\n\n\n","category":"method"},{"location":"lib/sectors/#TensorKit.repartition","page":"Symmetry sectors an fusion trees","title":"TensorKit.repartition","text":"repartition(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, N::Int) where {I, N₁, N₂}\n-> <:AbstractDict{Tuple{FusionTree{I, N}, FusionTree{I, N₁+N₂-N}}, <:Number}\n\nInput is a double fusion tree that describes the fusion of a set of incoming uncoupled sectors to a set of outgoing uncoupled sectors, represented using the individual trees of outgoing (f1) and incoming sectors (f2) respectively (with identical coupled sector f1.coupled == f2.coupled). Computes new trees and corresponding coefficients obtained from repartitioning the tree by bending incoming to outgoing sectors (or vice versa) in order to have N outgoing sectors.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.artin_braid","page":"Symmetry sectors an fusion trees","title":"TensorKit.artin_braid","text":"artin_braid(f::FusionTree, i; inv::Bool = false) -> <:AbstractDict{typeof(t), <:Number}\n\nPerform an elementary braid (Artin generator) of neighbouring uncoupled indices i and i+1 on a fusion tree f, and returns the result as a dictionary of output trees and corresponding coefficients.\n\nThe keyword inv determines whether index i will braid above or below index i+1, i.e. applying artin_braid(f′, i; inv = true) to all the outputs f′ of artin_braid(f, i; inv = false) and collecting the results should yield a single fusion tree with non-zero coefficient, namely f with coefficient 1. This keyword has no effect if  BraidingStyle(sectortype(f)) isa SymmetricBraiding.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"Finally, there are some additional manipulations for internal use","category":"page"},{"location":"lib/sectors/","page":"Symmetry sectors an fusion trees","title":"Symmetry sectors an fusion trees","text":"TensorKit.insertat\nTensorKit.split\nTensorKit.merge","category":"page"},{"location":"lib/sectors/#TensorKit.insertat","page":"Symmetry sectors an fusion trees","title":"TensorKit.insertat","text":"insertat(f::FusionTree{I, N₁}, i::Int, f2::FusionTree{I, N₂})\n-> <:AbstractDict{<:FusionTree{I, N₁+N₂-1}, <:Number}\n\nAttach a fusion tree f2 to the uncoupled leg i of the fusion tree f1 and bring it into a linear combination of fusion trees in standard form. This requires that f2.coupled == f1.uncoupled[i] and f1.isdual[i] == false.\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.split","page":"Symmetry sectors an fusion trees","title":"TensorKit.split","text":"split(f::FusionTree{I, N}, M::Int)\n-> (::FusionTree{I, M}, ::FusionTree{I, N-M+1})\n\nSplit a fusion tree with the first M outgoing indices, and an incoming index corresponding to the internal fusion tree index between outgoing indices N and N+1 of the original tree f; and a second fusion tree whose first outgoing index is that same internal index. Its remaining outgoing indices are the N-M outgoing indices of the original tree f, and also the incoming index is the same. This is in the inverse of insertat in the sense that if f1, f2 = split(t, M) ⇒ f == insertat(f2, 1, f1).\n\n\n\n\n\n","category":"function"},{"location":"lib/sectors/#TensorKit.merge","page":"Symmetry sectors an fusion trees","title":"TensorKit.merge","text":"merge(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, c::I, μ = nothing)\n-> <:AbstractDict{<:FusionTree{I, N₁+N₂}, <:Number}\n\nMerge two fusion trees together to a linear combination of fusion trees whose uncoupled sectors are those of f1 followed by those of f2, and where the two coupled sectors of f1 and f2 are further fused to c. In case of FusionStyle(I) == DegenerateNonAbelian(), also a degeneracy label μ for the fusion of the coupled sectors of f1 and f2 to c needs to be specified.\n\n\n\n\n\n","category":"function"},{"location":"#TensorKit.jl","page":"Home","title":"TensorKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for large-scale tensor computations, with a hint of category theory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorKit","category":"page"},{"location":"#Package-summary","page":"Home","title":"Package summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorKit.jl aims to be a generic package for working with tensors as they appear throughout the physical sciences. TensorKit implements a parametric type Tensor (which is actually a specific case of the type TensorMap) and defines for these types a number of vector space operations (scalar multiplication, addition, norms and inner products), index operations (permutations) and linear algebra operations (multiplication, factorizations). Finally, tensor contractions can be performed using the @tensor macro from TensorOperations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, most effort is oriented towards tensors as they appear in the context of quantum many body physics and in particular the field of tensor networks. Such tensors often have large dimensions and take on a specific structure when symmetries are present. To deal with generic symmetries, we employ notations and concepts from category theory all the way down to the definition of a tensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the same time, TensorKit.jl focusses on computational efficiency and performance. The underlying storage of a tensor's data can be any DenseArray. Currently, certain operations are already multithreaded, either by distributing the different blocks in case of a structured tensor (i.e. with symmetries) or by using multithreading provided by the package Strided.jl. In the future, we also plan to investigate using CuArrays as underlying storage for the tensors data, so as to leverage GPUs for the different operations defined on tensors.","category":"page"},{"location":"#Contents-of-the-manual","page":"Home","title":"Contents of the manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\", \"man/categories.md\", \"man/spaces.md\", \"man/sectors.md\", \"man/tensors.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/spaces.md\",\"lib/sectors.md\",\"lib/tensors.md\"]\nDepth = 2","category":"page"},{"location":"man/categories/#s_categories","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The purpose of this page (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors. In particular, we are interested in the category mathbfVect, but our concept of tensors can be extended to morphisms of any category that shares similar properties. These properties are reviewed below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, we will as example also study the more general case of mathbfSVect, i.e. the category of super vector spaces, which contains mathbfVect as a subcategory and which are useful to describe fermions.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the end, the goal of identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following exposition is mostly based on [turaev], combined with input from [selinger], [kassel], [kitaev], and nLab, to which  we refer for further information. Furthermore, we recommend the nice introduction of [beer].","category":"page"},{"location":"man/categories/#ss_categoryfunctor","page":"Optional introduction to category theory","title":"Categories, functors and natural transformations","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"To start, a category C consists of","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a class mathrmOb(C) of objects V, W, …\nfor each pair of objects V and W, a set mathrmHom_C(WV) of morphisms   fWV; for a given map f, W is called the domain or source, and V   the codomain or target.\ncomposition of morphisms fWV and gXW into (f  g)XV that is   associative, such that for hYX we have f  (g  h) = (f  g)  h\nfor each object V, an identity morphism mathrmid_VVV such that   f  mathrmid_W = f = mathrmid_V  f.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The morphisms in mathrmHom_C(VV) are known as endomorphism and this set is also denoted as End_C(V). When the category C is clear, we can drop the subscript in mathrmHom(WV). A morphism fWV is an isomorphism if there exists a morphism f^-1VW called its inverse, such that f^-1  f = mathrmid_W and f  f^-1 = mathrmid_V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Throughout this manual, we associate a graphical representation to morphisms and compositions thereof, which is sometimes referred to as the Penrose graphical calculus. To morphisms, we associate boxes with an incoming and outgoing line denoting the object in its source and target. The flow from source to target, and thus the direction of morphism composition f  g (sometimes known as the flow of time) can be chosen left to right (like the arrow in fWV), right to left (like the composition order f  g, or the matrix product), bottom to top (quantum field theory convention) or top to bottom (quantum circuit convention). Throughout this manual, we stick to this latter convention (which is not very common in manuscripts on category theory):","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: composition)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The direction of the arrows, which become important once we introduce duals, are also subject to convention, and are here chosen to follow the arrow in fWV, i.e. the source comes in and the target goes out. Strangely enough, this is opposite to the most common convention.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of interest, i.e. the category mathbf(Fin)Vect_𝕜 (or some subcategory thereof), the objects are (finite-dimensional) vector spaces over a field 𝕜, and the morphisms are linear maps between these vector spaces with \"matrix multiplication\" as composition. More importantly, the morphism spaces mathrmHom(WV) are themselves vector spaces. More general categories where the morphism spaces are vector spaces over a field 𝕜 (or modules over a ring 𝕜) and the composition of morphisms is a bilinear operation are called 𝕜-linear categories (or 𝕜-algebroids, or mathbfVect_𝕜-enriched categories). In that case, the endomorphisms mathrmEnd(V) are a 𝕜-algebra with mathrmid_V as the identity.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We also introduce some definitions which will be useful further on. A functor F between two categories C and D is, colloquially speaking, a mapping between categories that preserves morphism composition and identities. More specifically, FCD assigns to every object V  mathrmOb(C) an object F(V)  mathrmOb(D), and to each morphism f  mathrmHom_C(WV) a morphism F(f)  mathrmHom_D(F(W) F(V)) such that F(f) _D F(g) = F(f _C g) and F(mathrmid_V) = mathrmid_F(V) (where we denoted the possibly different composition laws in C and D explicitly with a subscript). In particular, every category C has an identity functor 1_C that acts trivially on objects and morphisms. Functors can also be composed. A 𝕜-linear functor between two 𝕜-linear categories has a linear action on morphisms.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Given two categories C and D, and two functors F and G that map from C to D, a natural transformation φFG is a family of morphisms φ_V  mathrmHom_D(F(V)G(V)) in D, labeled by the objects V of C, such that φ_V  F(f) = G(f)  φ_W for all morphisms f  mathrmHom_C(WV). If all morphisms φ_V are isomorphisms, φ is called a natural isomorphism and the two functors F and G are said to be isomorphic.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The product of two categories C and C, denoted C  C, is the category with objects mathrmOb(CC) = mathrmOb(C)  mathrmOb(C), whose elements are denoted as tuples (VV), and morphisms mathrmHom_CC((WW) (VV)) = mathrmHom_C(WV)  mathrmHom_C(WV). Composition acts as (ff)  (gg) = (ff gg) and the identity is given by mathrmid_VV = (mathrmid_V mathrmid_V). In a similar fashion, we can define the product of functors FCD and FCD as a functor FF (CC)(DD) mapping objects (VV) to (F(V) F(V)) and morphisms (ff) to (F(f) F(f)).","category":"page"},{"location":"man/categories/#ss_monoidalcategory","page":"Optional introduction to category theory","title":"Monoidal categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The next property of the category mathbfVect that we want to highlight and generalize is that which allows to take tensor products. Indeed, a category C is said to be a tensor category (a.k.a. a monoidal category), if it has","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a binary operation on objects  mathrmOb(C)  mathrmOb(C)  mathrmOb(C)\na binary operation on morphisms, also denoted as , such that    mathrmHom_C(W_1V_1)  mathrmHom_C(W_2V_2)  mathrmHom_C(W_1  W_2 V_1  V_2)\nan identity or unit object I\nthree families of natural isomorphisms:\n V  mathrmOb(C), a left unitor (a.k.a. left unitality constraint)   λ_V I  V  V\n V  mathrmOb(C), a right unitor (a.k.a. right unitality constraint)   ρ_V V  I  V\n V_1 V_2 V_3  mathrmOb(C), an associator (a.k.a. associativity   constraint) α_V_1V_2V_3(V_1  V_2)  V_3  V_1  (V_2  V_3)\nthat satisfy certain consistency conditions (coherence axioms), which are known as the   pentagon equation (stating that the two possible mappings from   (((V_1  V_2)  V_3)  V_4) to (V_1  (V_2  (V_3  V_4))) are compatible) and   the triangle equation (expressing compatibility between the two possible ways to map   ((V_1  I)  V_2) to (V_1  (I  V_2))).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In terms of functors and natural transformations,  is a functor from the product category C  C to C. Furthermore, the left (or right) unitor λ (or ρ) is a natural isomorphism between a nameless functor CC that maps objects V  I  V (or VV  I) and the identity functor 1_C. Similarly, the associator α is a natural isomorphism between the two functors (  1_C) and (1_C  ) from C  C  C to C.  In a k-linear category, the tensor product of morphisms is also a bilinear operation. A monoidal category is said to be strict if I  V = V = V  I and (V_1V_2)V_3 = V_1(V_2V_3), and the left and right unitor and associator are just the identity morphisms for these objects.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For the category mathbfVect, the identity object I is just the scalar field 𝕜 over which the vector spaces are defined, and which can be identified with a one- dimensional vector space. This is not automatically a strict category, especially if one considers how to represent tensor maps on a computer. The distinction between V, I  V and V  I amounts to adding or removing an extra factor I to the tensor product structure of the domain or codomain, and so the left and right unitor are analogous to removing extra dimensions of size 1 from a multidimensional array. The fact that arrays with and without additional dimensions 1 are not automatically identical and an actual operation is required to insert or remove them, has led to some discussion in several programming languages that provide native support for multidimensional arrays.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For what concerns the associator, the distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3) is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We elaborate on this in the context of Fusion categories below. However, we can already note that we will always represent tensor products using a canonical order (((V_1  V_2)  V_3)   V_N). A similar approach can be followed to turn any tensor category into a strict tensor category (see Section XI.5 of [kassel]).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The different natural isomorphisms involving the unit object have various relations, such as λ_VW  α_IVW = λ_V  mathrmid_W and λ_I = ρ_I  I  I  I. The last relation defines an isomorphism between I  I and I, which can also be used to state that for f g  End_C(I), f  g = ρ_I  (f  g)  λ_I^-1 = g  f. Hence, the tensor product of morphisms in End_C(I) can be related to morphism composition in End_C(I), and furthermore, the monoid of endomorphisms End_C(I) is commutative (abelian). In the case of a 𝕜-linear category, it is an abelian 𝕜-algebra. In the case of mathbfVect, mathrmEnd(I) is indeed isomorphic to the field of scalars 𝕜. We return to the general case where End_C(I) is isomorphic to 𝕜 itself in the section on pre-fusion categories.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Furthermore, Mac Lane's coherence theorem states that the triangle and pentagon condition are sufficient to ensure that any consistent diagram made of associators and left and right unitors (involving all possible objects in C) commutes. For what concerns the graphical notation, the natural isomorphisms will not be represented and we make no distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3). Similarly, the identity object I can be added or removed at will, and when drawn, is often represented by a dotted or dashed line. Note that any consistent way of inserting the associator or left or right unitor to convert a graphical representation to a diagram of compositions and tensor products of morphisms gives rise to the same result, by virtue of Mac Lane's coherence theorem. Using the horizontal direction (left to right) to stack tensor products, this gives rise to the following graphical notation for the tensor product of two morphisms, and for a general morphism t between a tensor product of objects in source and target:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: tensorproduct)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Another relevant example is the category mathbfSVect_𝕜, which has as objects super vector spaces over 𝕜, which are vector spaces with a ℤ₂ grading, i.e. they are decomposed as a direct sum V = V_0  V_1. Furthermore, the morphisms between two super vector spaces are restricted to be grading preserving, i.e. f mathrmHom_mathbfSVect(WV) has f(W_0)  V_0 and f(W_1)  V_1. The graded tensor product between two super vector spaces is defined as (V_mathrmgW) = (V _mathrmg W)_0  (V _mathrmg W)_1 with (V _mathrmg W)_0 = (V_0  W_0)  (V_1  W_1) and (V _mathrmg W)_1 = (V_0  W_1)  (V_1  W_0). The unit object I is again isomorphic to 𝕜, i.e. I_0 = 𝕜 and I_1 = 0, a zero-dimensional vector space. In particular, the category mathbfSVect_𝕜 contains mathbfVect_𝕜 as a (monoidal) subcategory, by only selecting those objects V for which V_1 = 0. We will return to the example of mathbfSVect throughout the remainder of this page.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Finally, we generalize the notion of a functor between monoidal categories. A monoidal functor between two tensor categories (C _C I_C α_C λ_C ρ_C) and (D _D I_D α_D λ_D ρ_D) is a functor FCD together with two monoidal constraints, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a morphism F₀I_D  F(I_C);\na natural transformation   F_2=F_2(XY) F(X) _D F(Y)  F(X _C Y)  XY mathrmOb(C)   between the functors _D(FF) and F _C from CC to D.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A monoidal natural transformation φ between two monoidal functors FCD and GCDis a natural transformation φFG that furthermore satisfies","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"φ_I_C F_0 = G_0;\n XY  mathrmOb(C): φ_X  Y F_2(XY) = G_2(XY)(φ_X  φ_Y).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For further reference, we also define the following categories which can be associated with the category mathcalC = (C  I α λ ρ)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathcalC^mathrmop = (C^mathrmop  I α^mathrmop λ^mathrmop ρ^mathrmop)   where the opposite category C^mathrmop has the same objects as C but has   mathrmHom_C^mathrmop(XY) = mathrmHom_C(YX) and a composition law   g ^mathrmop f = f  g, with  the composition law of C. Furthermore,   we have α^mathrmop_XYZ = (α_XYZ)^-1,   λ^mathrmop_X = (λ_X)^-1 and ρ^mathrmop_X = (ρ_X)^-1;\nmathcalC^mathrmop = (C ^mathrmop I α^mathrmop λ^mathrmop ρ^mathrmop)   where the functor ^mathrmopCC  C is the opposite monoidal product, which   acts as X ^mathrmop Y = Y  X on objects and similar on morphisms.   Furthermore, α^mathrmop_XYZ = (α_ZYX)^-1,   λ^mathrmop_X = ρ_X and ρ^mathrmop_X = λ_X;\nThe two previous transformations (which commute) composed:   mathcalC^mathrmrev = (C^mathrmop ^mathrmop I α^mathrmrev λ^mathrmrev ρ^mathrmrev)   with α^mathrmrev_XYZ = α_ZYX, λ^mathrmrev_X = (ρ_X)^-1,   ρ^mathrmrev_X = (λ_X)^-1.","category":"page"},{"location":"man/categories/#ss_dual","page":"Optional introduction to category theory","title":"Duality: rigid, pivotal and spherical categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Another property of the category mathbfVect that we want to generalize is the notion of duals. For a vector space V, i.e. an object of  mathbfVect, the dual V^* is itself a vector space. Evaluating the action of dual vector on a vector can, because of linearity, be interpreted as a morphism from V^*  V to I. Note that elements of a vector space V have no categorical counterpart in themselves, but can be interpreted as morphism from I to V. To map morphisms from mathrmHom(WV) to elements of V  W^*, i.e. morphisms in mathrmHom(I V  W^*), we use another morphism mathrmHom(I W  W^*) which can be considered as the inverse of the evaluation map.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Hence, duality in a monoidal category is defined via an exact paring, i.e. two families of non-degenerate morphisms, the evaluation (or co-unit) ϵ_V ^V  V  I and the coevaluation (or unit) η_V I  V  ^V which satisfy the \"snake rules\":","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"ρ_V  (mathrmid_V  ϵ_V)  (η_V  mathrmid_V)  λ_V^-1 = mathrmid_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"λ_^V^-1  (ϵ_V  mathrmid_^V)  (mathrmid_^V  η_V)  ρ_^V^-1 = mathrmid_^V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and can be used to define an isomorphism between mathrmHom(W  V U) and mathrmHom(W U  ^V) for any triple of objects U V W  mathrmOb(C). Note that if there are different duals (with corresponding exact pairings) associated to an object V, a mixed snake composition using the evaluation of one and coevaluation of the other duality can be used to construct an isomorphism between the two associated dual objects. Hence, duality is unique up to isomorphisms.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For (real or complex) vector spaces, we denote the dual as V^*, a notation that we preserve for pivotal categories (see below). Using a bra-ket notation and a generic basis n for V and dual basis m for V^* (such that mn = δ_mn), the evaluation is given by ϵ_V^V  V  ℂ m  n  δ_mn and the coevaluation or unit is η_Vℂ V  ^Vα  α _n n  n. Note that this does not require an inner product, i.e. no relation or mapping from n to n was defined. For a general tensor map tW_1  W_2    W_N_2  V_1  V_2    V_N_1, by successively applying η_W_N_2, η_W_N_2-1, …, η_W_1 (in combination with the left or right unitor), we obtain a tensor in V_1  V_2    V_N_1  W_N_2^*    W_1^*. Hence, we can define or identify (W_1  W_2    W_N_2)^* = W_N_2^*    W_1^*. Indeed, it can be shown that for any category which has duals for objects V and W, an exact pairing between V  W and ^W  ^V can be constructed out of the evaluation and coevaluation of V and W, such that ^W  ^V is at least isomorphic to ^(V  W).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Graphically, we represent the exact pairing and snake rules as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: left dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that we denote the dual objects ^V as a line V with arrows pointing in the opposite (i.e. upward) direction. This notation is related to quantum field theory, where anti-particles are (to some extent) interpreted as particles running backwards in time.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"These exact pairings are known as the left evaluation and coevaluation, and ^V is the left dual of V. Likewise, we can also define a right dual V^ of V and associated pairings, the right evaluation tildeϵ_V V  V^  I and coevaluation tildeη_V I  V^  V, satisfying","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: right dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, one could choose tildeϵ_^V = ϵ_V and thus define V as the right dual of ^V. While there might be other choices, this choice must at least be isomorphic, such that (^V)^  V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If objects V and W have left (respectively right) duals, than for a morphism f  mathrmHom(WV), we furthermore define the left (respectively right) transpose ^f  mathrmHom(^V ^W) (respectively  f^  mathrmHom(V^ W^)) as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: transpose)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where on the right we also illustrate the mapping from t  mathrmHom(W_1  W_2  W_3 V_1  V_2) to a morphism in mathrmHom(I V_1  V_2  ^ W_3  ^ W_2  ^ W_1).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the graphical notation, at least the lines with opposite arrows, do not allow to distinguish between the right dual V^ and the left dual ^V. We come back to this point below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A left (or right) duality in a (monoidal) category is now defined as an association of a left (or right) dual with every object of the category, with corresponding exact pairings, and a category admitting such a duality is a left (or right) rigid category (or left or right autonomous category). Given that left (or right) morphism transposition satisfies ^(f  g)= ^g  ^f= ^f ^mathrmop ^g and recalling ^(V  W) = ^W  ^V (and similar for right duality), we can define duality in a functorial way. A (left or right) rigid category mathcalC is a category which admits a (left or right) duality functor, i.e. a functor from mathcalC to mathcalC^mathrmrev that maps objects to its (left or right) dual, and morphisms to its (left or right) transpose. In particular, the snake rules can now be read as the functioral requirement that ^(mathrmid_V) = mathrmid_^V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In all of this, left and right duality can be completely distinct. Equivalently, the left dual of the left dual of an object V, i.e. ^V is not necessarily V itself, nor do the exact pairings enable us to construct an isomorphism between ^V and V. For finite-dimensional vector spaces, however, ^V and V, or thus ^V and V^ are known to be isomorphic. The categorical generalization is that of a pivotal category (or sovereign category), i.e. a monoidal category with two-sided duals X^* = ^X = X^ = X^* such that the left and right duality functor coincide, and thus also the left and right transpose of morphisms, i.e. f^* = ^f = f^  mathrmHom(V^*W^*) for any fmathrmHom(WV). Given that tildeϵ_X and tildeη_X can be interpreted as an exact pairing ϵ_X^* and η_X^*, this can be used to recognize X as a left dual of X^*, which is then not necessarily equal but at least isomorphic to X^** with the isomorphism given by the mixed snake composition alluded to in the beginning of this section, i.e. δ_X X  X^** given by δ_X = (tildeϵ_X  mathrmid_X^*)  (mathrmid_X  η_X^*). A more formal statement is that δ is a natural isomorphism between the double dual functor and the identity functor of a category C. In a similar manner, such a δ can be used to define a natural isomorphism between left and right dual functor (which is a slight generalization of the above definition of a pivotal category), and as such it is often called the pivotal structure.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Hence, in a pivotal category, left and right duals are the same or isomorphic, and so are objects and their double duals. As such, we will not distinguish between them in the graphical representation and suppress the natural isomorphism δ. Note, as already suggested by the graphical notation above, that we can interpret transposing a morphism as rotating its graphical notation by 180 degrees (either way).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Furthermore, in a pivotal category, we can define a map from mathrmEnd(V), the endomorphisms of an object V to endomorphisms of the identity object I, i.e. the field of scalars in the case of the category mathbfVect, known as the trace of f. In fact, we can define both a left trace as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr_mathrml(f) = ϵ_V  (mathrmid_V^*  f)  tildeη_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and a right trace as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr_mathrmr(f) = tildeϵ_V  (f  mathrmid_V^*)  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"They are graphically represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: trace)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and they do not need to coincide. Note that mathrmtr_mathrml(f) = mathrmtr_mathrmr(f*) and that mathrmtr_mathrmlmathrmr(fg) = mathrmtr_mathrmlmathrmr(gf). The (left or right) trace of the identity morphism mathrmid_V defines the corresponding (left or right) dimension of the object V, i.e. mathrmdim_mathrmlmathrmr(V) = tr_mathrmlmathrmr(mathrmid_V). In a spherical category, both definitions of the trace coincide for all V and we simply refer to the trace mathrmtr(f) of an endomorphism. The particular value mathrmdim(V) = mathrmtr(mathrmid_V) is known as the (quantum) dimension of the object V, referred to as dim(V) in TensorKit.jl.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For further information and a more detailed treatment of rigid and pivotal categories, we refer to [turaev] and [selinger]. We conclude this section by studying the example of mathbfSVect. Let us, in every super vector space V, define a basis n that is compatible with the grading, such n=01 indicates that n  V_n. We again define a dual basis m for V^* (such that mn = δ_mn), and then define the left evaluation by ϵ_VV^*  V  ℂ m _mathrmg n  mn = δ_mn and the left coevaluation by η_Vℂ V  V^*α  α _n n _mathrmg n. Note that this does not require an inner product and satisfies the snake rules. For the right evaluation and coevaluation, there are two natural choices, namely tildeϵ_VV  V^*  ℂ n _mathrmg m  (1)^n δ_mn and tildeη_Vℂ  V^*  V α  _n (1)^n n _mathrmg n. The resulting trace of an endomorphism f  mathrmEnd(V) is given by mathrmtr^mathrml(f) = mathrmtr^mathrmr(f) = mathrmtr(f) = _n ( 1)^n nfn and is known as either the regular trace (in the case of +1) or the supertrace (in the case of -1). In particular, mathrmdim(V) = mathrmdim(V_0)  mathrmdim(V_1), and can be negative in the case of the supertrace. Both are valid choices to make mathbfSVect into a spherical category.","category":"page"},{"location":"man/categories/#ss_braiding","page":"Optional introduction to category theory","title":"Braidings, twists and ribbons","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"While duality and the pivotal structure allow to move vector spaces back and forth between the domain (source) and codomain (target) of a tensor map, reordering vector spaces within the domain or codomain of a tensor map , i.e. within a tensor product V_1  V_2   V_N requires additional structure. In particular, we need at the very least a braided tensor category C, which is endowed with a braiding τ, i.e. a natural isomorphism τ_VWVW  WV_VW  mathrmOb(C) between the functors  and ^mathrmop such that τ_VV(f  g) = (g  f)τ_WW for any morphisms f  mathrmHom(WV) and g  mathrmHom(WV). A valid braiding needs to satisfy a coherence condition with the associator α known as the hexagon equation, which expresses that the braiding is -multiplicative, i.e. τ_UVW = (mathrmid_V  τ_UW)(τ_UVmathrmid_W) and τ_UVW = (τ_UWmathrmid_VW)(mathrmid_U  τ_VW) (where the associator has been omitted). We also have λ_V  τ_VI = ρ_VI, ρ_V  τ_IV = λ_V and τ_VI = τ_IV^-1 for any V  mathrmOb(C).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The braiding isomorphism τ_VW and its inverse are graphically represented as the lines V and W crossing over and under each other:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"such that we have","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding relations)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where the expression on the right hand side, τ_WVτ_VW can generically not be simplified. Hence, for general braidings, there is no unique choice to identify a tensor in VW and WV, as the isomorphisms τ_VW, τ_WV^-1, τ_VW  τ_WV  τ_VW, … mapping from VW to WV can all be different. In order for there to be a unique map from V_1  V_2   V_N to any permutation of the objects in this tensor product, the braiding needs to be symmetric, i.e. τ_VW = τ_WV^-1 or, equivalently τ_WV  τ_VW = mathrmid_VW. The resulting category is then referred to as a symmetric tensor category. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross, where the crossing represents the action of τ_VW = τ_WV^-1.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of the category mathbfVect a valid braiding consists of just flipping the the objects/morphisms involved, e.g. for a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia's function permutedims on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered, as discussed in Sectors, representation spaces and fusion trees) or in the case of mathbfSVect, which will again be studied in detail at the end of this section.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The braiding of a space and a dual space also follows naturally, it is given by τ_V^*W = λ_W  V^*  (ϵ_V  mathrmid_W  V^*)  (mathrmid_V^*  τ_VW^-1  mathrmid_V^*)  (mathrmid_V^* W  η_V)  ρ_V^*  W^-1, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Balanced categories C are braided categories that come with a twist θ, a natural transformation from the identity functor 1_C to itself, such that θ_V  f = f  θ_W for all morphisms f  mathrmHom(WV), and for which main requirement is that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_VW = τ_WV  (θ_W  θ_V)  τ_VW = (θ_V  θ_W)  τ_WV  τ_VW","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, a braided pivotal category is balanced, as we can even define two such twists, namely a left and right twist given by","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ^mathrml_V = (ϵ_V  mathrmid_V)(mathrmid_V*  τ_VV) (tildeη_V  mathrmid_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ^mathrmr_V = (mathrmid_V  tildeϵ_V)(τ_VV  mathrmid_V*)(mathrmid_V  ϵ_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where we omitted the necessary left and right unitors and associators. Graphically, the twists and their inverse (for which we refer to [turaev]) are then represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: twists)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The graphical representation also makes it straightforward to verify that (θ^mathrml_V)^* = θ^mathrmr_V^*, (θ^mathrmr_V)^* = θ^mathrml_V^* and mathrmtr_mathrml( θ^mathrmr_V ) = mathrmtr_mathrmr( θ^mathrml_V ).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"When θ^mathrml = θ^mathrmr, or thus, equivalently, θ_V^* = θ_V^* for either θ^mathrml or θ^mathrmr, the category is said to be tortile or also a ribbon category, because its graphical representation is compatible with the isotopy of a ribbon, i.e. where the lines representing objects are depicted as ribbons. For convenience, we continue to denote them as lines. Ribbon categories are necessarily spherical, i.e. one can prove the equivalence of the left and right trace.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Alternatively, one can start from a balanced and rigid category (e.g. with a left duality), and use the twist θ, which should satisfy θ_V^* = θ_V^*, to define a pivotal structure, or, to define the exact pairing for the right dual functor as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeη_V = τ_VV^*  (θ_V  mathrmid_V^*)  η_V = (mathrmid_V^*  θ_V)  τ_VV^*  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeϵ_V = ϵ_V  (mathrmid_V^*  θ_V)  τ_VV^* = ϵ_V  τ_VV^*  (θ_V  mathrmid_V^*)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: pivotal from twist)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where we have drawn θ as θ^mathrml on the left and as θ^mathrmr on the right, but in this case the starting assumption was that they are one and the same, and we defined the pivotal structure so as to make it compatible with the graphical representation. This construction of the pivotal structure can than be used to define the trace, which is spherical, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr(f) = ϵ_V  τ_VV^*  (( θ_V  f)  mathrmid_V^*)  η_V = ϵ_V  (mathrmid_V^*  (f  θ_V))  τ_VV^*  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note finally, that a ribbon category where the braiding is symmetric, is known as a compact closed category. For a symmetric braiding, the trivial twist θ_V = mathrmid_V is always a valid choice, but it might not be the choice that one necessarily want to use. Let us study the case of mathbfSVect again. Reinvoking our basis m  V and n  W, the braiding τ_VW is given by the Koszul sign rule, i.e. τ_VWm _mathrmg n  (-1)^m n n _mathrmg m. Hence, braiding amounts to flipping the two spaces, but picks up an additional minus sign if both m  V_1 and n  W_1. This braiding is symmetric, i.e. τ_WV  τ_VW = mathrmid_VW. Between spaces and dual spaces, we similarly obtain the braiding rule m _mathrmg n  (-1)^m n n _mathrmg m. Combining the braiding and the pivotal structure gives rise to a ribbon category, and thus, a compact closed category, where the resulting twist is given by θ_V  n  (1)^n n for tildeϵ_VV  V^*  ℂ n _mathrmg m  (1)^n δ_mn and corresponding tildeη_V. Hence, if the right (co)evaluation contains a minus sign, the twist is θ_V = mathrmid_V, which, as mentioned above, is always a valid twist for a symmetric category. However, if the right (co)evaluation contains no minus sign, the twist acts as the parity endomorphism, i.e. as +1 on V_0 and as -1 on V_1, which, as we will see in the next section, corresponds to a choice bearing additional structure.","category":"page"},{"location":"man/categories/#ss_adjoints","page":"Optional introduction to category theory","title":"Adjoints and dagger categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A dagger category C is a category together with an involutive functor CC^mathrmop, i.e. it acts as the identity on objects, whereas on morphisms fWV it defines a morphism f^VW such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmid_V^ = mathrmid_V\n(f  g)^ = f^ ^mathrmop g^ = g^  f^\n(f^)^ = f","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Sometimes also the symbol * is used instead of , however we have already used * to denote dual objects and transposed morphisms in the case of a pivotal category.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If the category is ℂ-linear, the dagger functor is often assumed to be antilinear, i.e. (λ f)^ = barλ f^ for λ  ℂ and f  mathrmHom(VW). In a dagger category, a morphism fWV is said to be unitary if it is an isomorphism and f^-1 = f^. Furthermore, an endomorphism fVV is hermitian or self-adjoint if f^ = f. Finally, we will also use the term isometry for a morphism fWV which has a left inverse f^, i.e. such that f^  f = mathrmid_W, but for which f  f^ is not necessarily the identity (but rather some orthogonal projector, i.e. a hermitian idempotent in mathrmEnd(V)).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the graphical representation, the dagger of a morphism can be represented by mirroring the morphism around a horizontal axis, and then reversing all arrows (bringing them back to their original orientation before the mirror operation):","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: dagger)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where for completeness we have also depicted the graphical representation of the transpose, which is a very different operation. In particular, the dagger does not reverse the order of the tensor product. Note that, for readibility, we have not mirrored or rotated the label in the box, but this implies that we need to use a type of box for which the action of mirroring or rotating can be observed.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"There is more to be said about the interplay between the dagger and duals. Given a left evaluation ϵ_V V^*  V  I and coevaluation η_V I  V  V^*, we can define a right evaluation tildeϵ_V = (η_V)^ and coevaluation tildeη_V = (ϵ_V)^. Hence, left rigid dagger categories are automatically pivotal dagger categories.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The (right) twist defined via the pivotal structure now becomes","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_V = (mathrmid_V  (η_V)^)  (τ_VV  mathrmid_V^*)  (mathrmid_V  η_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity, as we discuss for the mathbfSVect example below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Finally, the dagger allows to define two Hermitian forms on the morphisms, namely  f g _mathrmlmathrmr = mathrmtr_mathrmlmathrmr(f^ g), which coincide for a spherical category. For a unitary 𝕜-linear category, these Hermitian forms should be positive definite and thus define an inner product on each of the homomorphism spaces mathrmHom(WV). In particular then, dimensions of objects are positive, as they satisfy mathrmdim_mathrmlmathrmr(V) =  mathrmid_V mathrmid_V _mathrmlmathrmr.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"This concludes the most important categorical definitions and structures that we want to discuss for the category mathbfVect, but which can also be realized in other categories. In particular, the interface of TensorKit.jl could in principle represent morphisms from any 𝕜-linear monoidal category, but assumes categories with duals to be pivotal and in fact spherical, and categories with a braiding to be ribbon categories. A dagger ribbon category where the braiding is symmetric, i.e. a dagger category which is also a compact closed category and where the right (co)evaluation is given via the dagger of the left (co)evaluation is called a dagger compact category. This is the playground of quantum mechanics of bosonic and fermionic systems. However, we also allow for non- symmetric braiding in TensorKit.jl, though this functionality is currently much more limited.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Again studying the category mathbfSVect_ℂ (now explicitly over the complex numbers) and using the conventional adjoint or the complex Euclidean inner product to define the dagger functor, the right (co)evaluation that is obtained from applying the dagger to the left (co)evaluation is the definition we gave above with the +1 sign. This choice gives rise to a regular trace (versus the supertrace) of endomorphisms, to positive dimensions, and a non-trivial twist that acts as the parity endomorphism. The resulting category is then a dagger compact category, that can be used for the quantum mechanical description of fermionic systems. The bosonic version is obtained by restricting to the subcategory mathbfVect.","category":"page"},{"location":"man/categories/#ss_fusion","page":"Optional introduction to category theory","title":"Direct sums, simple objects and fusion categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"These last two section on fusion categories is also applicable, in a straightforward manner, to mathbfVect and mathbfSVect, but is rather meant to provide the background of working with symmetries. We first need two new concepts:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"An object W  mathrmOb(C) is a direct sum of objects   V_1 V_2  V_k  mathrmOb(C) if there exists a family morphisms   x_α  mathrmHom(V_αW) and y^α  mathrmHom(WV_α) such that   mathrmid_W = _α=1^k x_α  y^α and y^α  x_β = δ^α_β mathrmid_V_α.   The morphisms x_α and y^α are known as inclusions and projections   respectively, and in the context of dagger categories it is natural to assume   y^α = x_α^ in order to obtain an orthogonal direct sum decomposition.\nA simple object V  mathrmOb(C) of a 𝕜-linear category C is an   object for which End_C(V)  𝕜, i.e. the algebra of endomorphisms on V is   isomorphic to the field (or ring) 𝕜. As End_C(V) always contains the identity   morphism mathrmid_V, and this must be the only linearly independent endomorphism   if V is a simple object, the isomorphism between mathrmEnd_C(V) and 𝕜   is typically of the form k  𝕜  k mathrmid_V  End_C(V). In particular, for   mathbfSVect and its subcategory mathbfVect, the unit object I is a   simple object.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, for a pivotal 𝕜-linear category where I is simple, it holds that the left and right dimensions of any simple object V are invertible in 𝕜, and that any endomorphism f  mathrmEnd(V) can be written as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"f = (mathrmdim_mathrml(V))^-1 mathrmtr_mathrml(f) mathrmid_V = (mathrmdim_mathrmr(V))^-1 mathrmtr_mathrmr(f) mathrmid_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Strictly speaking, this holds only if the category is non-degenerate, which means that I is simple and that any non-degenerate pairing eV  W  I induces a non- degenerate pairing mathrmHom(IV)  mathrmHom(IW)  mathrmEnd(I). This property is always satisfied for a pre-fusion category C, i.e. a monoidal 𝕜- linear category having a set mathcalS  mathrmOb(C) of simple objects mathcalS=I V_1 V_2 ldots such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"the monoidal unit I_C  mathcalS;\nmathrmHom_C(V_iV_j) = 0 (the singleton set containing only the zero   homomorphism) for any distinct V_i V_j  mathcalS;\nevery object V  mathrmOb(C) can be written as a direct sum of a finite family of   elements from mathcalS.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that in the direct sum decomposition of an object V, a particular simple object V_i might appear multiple times. This number is known as the multiplicity index N^V_i, and equal to the rank of mathrmHom(VV_i) or, equivalently, of mathrmHom(V_iV). Hence, we can choose inclusion and projection maps x_iμV_iV and y^iμVV_i for μ = 1ldots N^V_i, such that mathrmid_V = sum_isum_μ=1^N_V^i x_iμ  y^iμ and y^iμ  x_jν = δ^i_j δ^μ_ν. In particular, for a simple object V, it either appears in mathcalS or is isomorphic to an object S. We thus have N^V_i = 1 for one particular object V_i and N^V_j= 0 for all other j, with x_i and y^i = (x_i)^-1 representing the isomorphism between V and V_i.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The homomorphisms between two general objects W and V in a pre-fusion category can be decomposed as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmHom(WV)  _V_i  mathcalS mathrmHom(WV_i)  mathrmHom(V_iV)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and thus that the rank of mathrmHom(WV) is given by _i N^W_i N^V_i.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A fusion category is a pre-fusion category that has (left or right) duals, i.e. that is rigid, and that only has a finite number of isomorphism classes of simple objects. Note that the duality functor maps mathrmEnd(V) to mathrmEnd(V^*), such that, if V is a simple object, so must be V^*. Henceforth, we will be sloppy about the distinction between a pre-fusion or fusion category, only use the latter term, even when it is not fully justified.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Before continuing, let us use some examples to sketch the relevance of the concept of fusion categories. As mentioned, the categories mathbfVect_𝕜 and mathbfSVect_𝕜 have I  𝕜 as simple object. For mathbfVect, this is the only simple object, i.e. any other vector space V over 𝕜, can be thought of as a direct sum over N^V_I = mathrmdim(V) multiple copies of 𝕜. In mathbfSVect, the object J = 0  𝕜 with J_0=0 the zero dimensional space and J_1  𝕜 is another simple object. Clearly, there are no non-zero grading preserving morphisms between I and J, i.e. mathrmHom(IJ) = 0, whereas mathrmHom(JJ)  𝕜. Any other super vector space V=V_0  V_1 can be written as a direct sum over N^V_I = mathrmdim(V_0) copies of I and N^V_J = mathrmdim(V_1) copies of J.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A more representative example is that of the category C = mathbfRep_mathsfG, the category of representations of a group mathsfG. Colloquially, this could be thought of as a subcategory of mathbfVect containing as objects vector spaces V on which a representation of mathsfG is defined, denoted as u_V(g) for g  mathsfG, and as morphisms the equivariant transformations, i.e. intertwiners between the representations on the source and target:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmHom_C(WV) = f  mathrmHom_mathbfVect(WV) u_V(g)  f = f  u_W(g)  g  G","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the u_V(g) is itself generally not an element from End_C(V). Simple objects V_a are those corresponding irreducible representations (irreps) a of the group mathsfG, for which Schur's lemma implies End_C(V_a)  𝕜 and mathrmHom_C(V_a V_b) = 0 if a and b are not equivalent irreps. On the dual space V^*, the group acts with the contragradient representation, i.e. u_V^*(g) = ((u_V(g))^-1)^* = u_V(g^-1)^*, where one should remind that ^* denotes the transpose. For a finite group or compact Lie group, we can introduce a dagger and restrict to unitary representations, such that u_V(g)^-1 = u_V(g)^ and the contragradient representation becomes the complex conjugated representation, denoted as u_V^*(g) = baru_V(g). The resulting category can then be given the structure of a unitary ribbon (pre-)fusion category. (Note that the number of isomorphism classes of simple objects, i.e. the number of non-equivalent irreps, is finite only in the case of a finite group). This example is very relevant to working with symmetries in TensorKit.jl, and will be expanded upon in more detail below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Fusion categories have a number of simplifying properties. A pivotal fusion category is spherical as soon as mathrmdim_mathrml(V_i) = mathrmdim_mathrmr(V_i) (i.e. the trace of the identity morphism) for all (isomorphism classes of) simple objects (note that all isomorphic simple objects have the same dimension). A braided pivotal fusion category is spherical if and only if it is a ribbon category.","category":"page"},{"location":"man/categories/#ss_topologicalfusion","page":"Optional introduction to category theory","title":"Topological data of a unitary pivotal fusion category","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"More explicitly, the different structures (monoidal structure, duals and pivotal structure, braiding and twists) in a fusion category can be characterized in terms of the simple objects, which we will henceforth denoted with just a instead of V_a. This gives rise to what is known as the topological data of a unitary pivotal fusion category, most importantly the N, F and R symbols, which are introduced in this final section.","category":"page"},{"location":"man/categories/#Monoidal-structure","page":"Optional introduction to category theory","title":"Monoidal structure","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Starting with the monoidal or tensor product, we start by characterizing how the object a  b can be decomposed as a direct sum over simple objects c, which gives rise to the multiplicity indices N_c^ab, as well as the inclusion maps, which we henceforth denote as X_cμ^abcab for μ=1N^c_ab. In the context of a unitary fusion category, on which we now focus, the corresponding projection maps are Y^cμ_ab = (X_cμ^ab)^abc such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(X_cμ^ab)^  X_cμ^ab = δ_cc δ_μμ mathrmid_c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Graphically, we represent these relations as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: fusion)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and also refer to the inclusion and projection maps as splitting and fusion tensor, respectively.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For both (ab)c and a(bc), which are isomorphic via the associator α_abc, we must thus obtain a direct sum decomposition with the same multiplicity indices, leading to the associativity constraint","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"N_d^abc= _e N_e^ab N_d^ec = _f N_f^bc N_d^af","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The corresponding inclusion maps can be chosen as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"X_d(eμν)^abc = (X_eμ^ab  mathrmid_c)  X_dν^ec  d(ab)c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeX_d(fκλ)^abc = (mathrmid_a  X_fκ^bc)  X_dλ^af  da(bc)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and satisfy","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(X_d(eμν)^abc)^  X_d(eμν)^abc = δ_ee δ_μμ δ_νν δ_dd mathrmid_d","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"_deμν X_d(eμν)^abc  (X_d(eμν)^abc)^ = mathrmid_(ab)c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and similar for tildeX_d(fκλ)^abc. Applying the associator leads to a relation","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"α_abc  X_d(eμν)^abc = _fκλ F^abc_d_(eμν)^(fκλ) tildeX_d(fκλ)^abc","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"which defines the F-symbol, i.e. the matrix elements of the associator","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(tildeX_d(fκλ)^abc)^  α_abc  X_d(eμν)^abc = δ_dd F^abc_d_(eμν)^(fκλ) mathrmid_d","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the left hand side represents a map in mathrmHom(dd), which must be zero if d is different from d, hence the δ_dd on the right hand side. In a strict category, or in the graphical notation, the associator α is omitted and these relations thus represent a unitary basis transform between the basis of inclusion maps X_d(eμν)^abc and tildeX_d(fκλ)^abc, which is also called an F-move, i.e. graphically:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Fmove)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The matrix F^abc_d is thus a unitary matrix. The pentagon coherence equation can also be rewritten in terms of these matrix elements, and as such yields the celebrated pentagon equation for the F-symbols. In a similar fashion, the unitors result in N^a1_b = N^1a_b = δ^a_b (where we have now written 1 instead of I for the unit object) and the triangle equation leads to additional relations between the F- symbols involving the unit object. In particular, if we identify X^1a_a1a(1a) with λ_a^ and X^a1_a1a(a1) with ρ_a^, the triangle equation and its collaries imply that F^1ab_c_(11μ)^(cν1) = δ^ν_μ, and similar relations for F^a1b_c and F^ab1_c, which are graphically represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Fmove1)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of group representations, i.e. the category mathbfRep_mathsfG, the splitting and fusion tensors are known as the Clebsch-Gordan coefficients, especially in the case of mathsfSU_2. An F-move amounts to a recoupling and the F-symbols can thus be identified with the 6j-symbols (strictly speaking, Racah's W-symbol for mathsfSU_2).","category":"page"},{"location":"man/categories/#Duality-and-pivotal-structure","page":"Optional introduction to category theory","title":"Duality and pivotal structure","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Next up is duality. Since we are assuming a dagger category, it can be assumed pivotal, where the left dual objects are identical to the right dual objects, and the left and right (co)evaluation are related via the dagger. We have already pointed out above that the dual object a^* of a simple object a is simple, and thus, it must be isomorphic to one of the representives bara of the different isomorphism classes of simple objects that we have chosen. Note that it can happen that bara=a. Duality implies an isomorphism between mathrmHom(WV) and mathrmHom(IVW^*), and thus, for a simple object a, mathrmEnd(a)  𝕜 is isomorphic to mathrmHom(1aa^*), such that the latter is also isomorphic to 𝕜, or thus N^abara_1 = 1. Also, all possible duals of a must be isomorphic, and thus there is a single representive bara, meaning that N^ab_1 = δ^bbara, i.e. for all other b  bara, mathrmHom(1ab)  mathrmHom(b^*a) = 0. Note that also barbara=a.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Let us now be somewhat careful with respect to the isomorphism between a^* and bara. If bara  a, we can basically choose the representative of that isomorphism class as bara = a^*. However, this choice might not be valid if bara=a, as in that case the choice is already fixed, and might be different from a. To give a concrete example, the j=12 representation of mathsfSU_2 has a dual (contragradient, but because of unitarity, complex conjugated) representation which is isomorphic to itself, but not equal. In the context of tensors in quantum physics, we would like to be able to represent this representation and its conjugate, so we need to take the distinction and the isomorphism between them into account. This means that mathrmHom(a^*bara) is isomorphic to 𝕜 and contains a single linearly independent element, Z_a, which is a unitary isomorphism such that Z_a^dagger  Z_a = mathrmid_a^* and Z_a  Z_a^dagger = mathrmid_bara. Using the transpose, we obtain Z_a^*  mathrmHom(bara^*a), and thus it is proportional to Z_bara, i.e. Z_a^* = χ_a Z_bara with χ_a a complex phase (assuming 𝕜 = ℂ). Another transpose results in Z_bara^* = χ_bara Z_a with χ_bara = overlineχ_a, where bar of a scalar quantity denotes its complex conjugate to avoid confusion with the transpose functor. If aand bara are distinct, we can essentially choose Z_bara such that χ_a is 1. However, for a=bara, the value of χ_a cannot be changed, but must satisfy χ_a^2 = 1, or thus χ_a = 1. This value is a topological invariant known as the Frobenius-Schur indicator. Graphically, we represent this isomorphism and its relations as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Zisomorphism)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We can now discuss the relation between the exact pairing and the fusion and splitting tensors. Given that the (left) coevaluation η_a  mathrmHom(1 aa^*), we can define the splitting tensor as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"X^abara_1 = frac1sqrtd_a(mathrmid_a  Z_a)  η_a = frac1sqrtd_a(Z_a^*  mathrmid_bara)  tildeη_bara  mathrmHom(1 abara)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The prefactor takes care of normalization, i.e. with η_a^ = tildeϵ_a, we find η_a^  η_a = tildeϵ_a  η_a = mathrmtr(mathrmid_a) = d_a mathrmid_1, and thus (X^abara_1)^  X^abara_1 = mathrmid_1. Here, we have denoted d_a = mathrmdim(a) = mathrmtr(mathrmid_a) for the quantum dimension of the simple objects a. With this information, we can then compute F^abaraa_a, which has a single element (it's a 1  1 matrix), and find F^abaraa_a = fracχ_ad_a, where we've used tildeη_a = ϵ_a^ and the snake rules. Hence, both the quantum dimensions and the Frobenius-Schur indicator are encoded in the F-symbol. Hence, they do not represent new independent data. Again, the graphical representation is more enlightning:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: ZtoF)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"With these definitions, we can now also evaluate the action of the evaluation map on the splitting tensors, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: splittingfusionrelation)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where again bar denotes complex conjugation in the second line, and we introduced two new families of matrices A^ab_c and B^ab_c, whose entries are composed out of entries of the F-symbol, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A^ab_c^nu_mu = sqrtfracd_a d_bd_c χ_bara   overlineF^baraab_b_(111)^(cμν)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"B^ab_c^nu_mu = sqrtfracd_a d_bd_c F^abbarb_a^(111)_(cμν)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Composing the left hand side of first graphical equation with its dagger, and noting that the resulting element f  mathrmEnd(a) must satisfy f = d_a^-1 mathrmtr(f) mathrmid_a, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Brelation)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"allows to conclude that _ν B^ab_c^ν_μ overlineB^ab_c^ν_μ = delta_μμ, i.e. B^ab_c is a unitary matrix. The same result follows for A^ab_c in analogue fashion.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"note: Note\nIn the context of fusion categories, one often resorts to the so-called isotopic normalization convention, where splitting tensors are normalized as (X^ab_cμ)^  X^ab_cmu = sqrtfracd_a d_bd_c δ_cc δ_μμ mathrmid_c. This kills some of the quantum dimensions in formulas like the ones above and essentially allows to rotate the graphical notation of splitting and fusion tensors (up to a unitary transformation). Nonetheless, for our implementation of tensors and manipulations thereof (in particular orthonormal factorizations such as the singular value decomposition), we find it more convenient to work with the original normalization convention.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Let us again study in more detail the example mathbfRep_mathsfG. The quantum dimension d_a of an irrep a is just the normal vector space dimension (over 𝕜) of the space on which the irrep acts. The dual of an irrep a is its contragradient representation, which in the case of unitary representations amounts to the complex conjugate representation. This representation can be isomorphic to an already defined irrep bara, for example a itself. If that happens, it does not automatically imply that the irrep a is real-valued. For example, all irreps of mathsfSU_2 are self- dual, with the isomorphism given by a π rotation over the y-axis (in the standard basis). The resulting Frobenius-Schur indicator is +1 for integer spin irreps, and -1 for half-integer spin irreps. The value χ_a=+1 indicates that the representation can be made real, e.g. the integer spin representations can be written as tensor representations of mathsfSO_3 by a change of basis. The value χ_a=-1 indicates that the representation is quaternionic and cannot be made real.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The (co)evaluation expresses that the standard contraction of a vector with a dual vector yields a scalar, i.e. a representation and its dual (the contragradient) yields the trivial representation when correctly contracted. The coevaluation together with the isomorphism between the conjugate of irrep a and some irrep bara yields a way to define the Clebsch-Gordan coefficients (i.e. the splitting and fusion tensor) for fusing a  bara to the trivial irrep, i.e. to what is called a singlet in the case of mathsfSU_2.","category":"page"},{"location":"man/categories/#Braidings-and-twists","page":"Optional introduction to category theory","title":"Braidings and twists","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Finally, we can study the braiding structure of a pivotal fusion category. Not all fusion categories have a braiding structure. The existence of a braiding isomorphism τ_VWVWWV requires at the very least that N^ab_c = N^ba_c at the level of the simple objects. We can then express τ_ab in terms of its matrix elements as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"τ_ab  X^ab_cμ = _ν R^ab_c^ν_μ X^ba_cν","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braidingR)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The hexagon coherence axiom for the braiding and the associator can then be reexpressed in terms of the F-symbols and R-symbols.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We can now compute the twist, which for simple objects needs to be scalars (or in fact complex phases because of unitarity) multiplying the identity morphism, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_a =  mathrmid_a sum_bμ fracd_bd_a R^aa_b^μ_μ","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: simpletwist)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Henceforth, we reserve θ_a for the scalar value itself. Note that θ_a = θ_bara as our category is spherical and thus a ribbon category, and that the defining relation of a twist implies","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"R^ba_c^κ_μ R^ab_c^μ_ν = fractheta_cθ_a θ_b δ^κ_ν","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If a = bara, we can furthermore relate the twist, the braiding and the Frobenius- Schur indicator via θ_a χ_a R^aa_1 =1, because of","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: twistfrobeniusschur)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For the recurring example of mathbfRep_mathsfG, the braiding acts simply as the swap of the two vector spaces on which the representations are acting and is thus symmetric, i.e. τ_ba  τ_ab = mathrmid_ab. All the twists are simply θ_a = 1. For an irrep that is self-dual, i.e. bara=a, the final expression simplifies to R^aa_1 = χ_a and thus states that the fusion from a  a to the trivial sector is either symmetric under swaps if χ_a=1 or antisymmetric if χ_a=-1. For the case of mathsfSU_2, the coupling of two spin j states to a singlet it symmetric for integer j and odd for half-integer j.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"With this, we conclude our exposition of unitary fusion categories. There are many fusion categories that do not originate from the representation theory of groups, but are related to quantum groups and the representation theory of quasi-triangular Hopf algebras. They have non-integer quantum dimensions and generically admit for braidings which are not symmetric. A particular class of interesting fusion categories are modular fusion categories, which provide the mathematical structure for the theory of anyons and topological sectors in topological quantum states of matter. Thereto, one defines the modular S matrix, defined as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"S_ab = frac1D mathrmtr(τ_ab  τ_ba) = frac1D _c N^ab_c d_c fracθ_cθ_a θ_b","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The normalization constant is given by D = sqrtsum_a d_a^2, and thus truly requires a fusion category with a finite number of (isomorphism classes of) simple objects. For a modular fusion category, the symmetric matrix S is non-degenerate, and in fact (for a unitary fusion category) unitary. Note, however, that for a symmetric braiding S_ab = fracd_a d_bD and thus S is a rank 1 matrix. In particular, mathbfRep_mathsfG is never a modular category and the properties associated with this are not of (direct) importance for TensorKit.jl. We refer to the references for further information about modular categories.","category":"page"},{"location":"man/categories/#Bibliography","page":"Optional introduction to category theory","title":"Bibliography","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[turaev]:   Turaev, V. G., & Virelizier, A. (2017). Monoidal categories and topological field theory (Vol. 322).\n        Birkhäuser.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[selinger]: Selinger, P. (2010). A survey of graphical languages for monoidal categories.\n        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.\n        [https://arxiv.org/abs/0908.3347](https://arxiv.org/abs/0908.3347)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[kassel]:   Kassel, C. (2012). Quantum groups (Vol. 155).\n        Springer Science & Business Media.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[kitaev]:   Kitaev, A. (2006). Anyons in an exactly solved model and beyond.\n        Annals of Physics, 321(1), 2-111.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[beer]:     From categories to anyons: a travelogue\n        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf\n        [https://arxiv.org/abs/1811.06670](https://arxiv.org/abs/1811.06670)","category":"page"}]
}
