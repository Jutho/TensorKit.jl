<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TensorKit.jl · TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/spaces/">Vector spaces, symmetry sectors an fusion trees</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TensorKit.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TensorKit.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/old.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TensorKit.jl-1"><a class="docs-heading-anchor" href="#TensorKit.jl-1">TensorKit.jl</a><a class="docs-heading-anchor-permalink" href="#TensorKit.jl-1" title="Permalink"></a></h1><p>A Julia tensor package with a hint of category theory. ***</p><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p><code>TensorKit.jl</code> is a Julia package for working with tensors, which are consistently treated as <a href="http://en.m.wikipedia.org/wiki/Tensor#Using_tensor_products">the elements of a tensor product of vector spaces</a> or, more generally, as linear maps between pairs of such tensor product spaces. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction.</p><h2 id="What-is-a-tensor?-1"><a class="docs-heading-anchor" href="#What-is-a-tensor?-1">What is a tensor?</a><a class="docs-heading-anchor-permalink" href="#What-is-a-tensor?-1" title="Permalink"></a></h2><p>In abstract sense, tensors (and tensor maps; see below) correspond to the morphisms in the category <span>$Vect$</span>, i.e. the category with vector spaces as objects, or some subcategory thereof.</p><p>some subspace thereof. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction. Henceforth, we represent a tensor using <a href="http://en.m.wikipedia.org/wiki/Abstract_index_notation">index notation</a> and refer to the different &quot;dimensons&quot; as <strong>indices</strong>. The tensor <span>$T^{i_1\;\;\;\overline{\imath}_4}_{\;i_2\overline{\imath}_3}$</span> represents a an element of the tensor product space <code>V_1 \otimes V_2^{\ast} \otimes \overline{V}_3 \otimes \overline{V}_4^{\ast}</code> where general complex vector spaces <code>V</code> can appear in four different ways:</p><ul><li>contravariant index <span>$i_1$</span> : normal vector space <span>$V_1$</span></li><li>contravariant index <span>$i_2$</span> : <a href="http://en.wikipedia.org/wiki/Dual_space">dual space</a> <span>$V_2^{\ast}$</span></li><li>barred or dotted covariant index <span>$\overline{\imath}_3$</span> : <a href="http://en.wikipedia.org/wiki/Complex_conjugate_vector_space">complex conjugate space</a> <span>$\overline{V}_3$</span></li><li>barred or dotted contravariant index <span>$\overline{\imath}_4$</span> : complex conjugate of the dual space <span>$\overline{V}_4^{\ast}$</span> , which is equivalent to the dual of the complex conjugate space</li></ul><p>The four different vector spaces <span>$V$</span> , <span>$V^{\ast}$</span> , <span>$\overline{V}$</span> and <span>$\overline{V}^{\ast}$</span> correspond to the representation spaces of respectively the fundamental, dual or contragredient, complex conjugate and dual complex conjugate representation of the general linear group <span>$\mathsf{GL}(V)$</span> <sup class="footnote-reference"><a id="citeref-tung" href="#footnote-tung">[tung]</a></sup>. Simplifications will occur for certain types of vector spaces.</p><hr/><h2 id="Vector-spaces-1"><a class="docs-heading-anchor" href="#Vector-spaces-1">Vector spaces</a><a class="docs-heading-anchor-permalink" href="#Vector-spaces-1" title="Permalink"></a></h2><h3 id="Elementary-vector-spaces-1"><a class="docs-heading-anchor" href="#Elementary-vector-spaces-1">Elementary vector spaces</a><a class="docs-heading-anchor-permalink" href="#Elementary-vector-spaces-1" title="Permalink"></a></h3><p>Tensors in TensorToolbox.jl are treated as elements of a tensor product of a homogeneous family of elementary vector spaces, which we also refer to as index spaces and can be user defined. We thus define a type hierarchy for representing a hierarchy of common vector spaces:</p><pre><code class="language-julia">abstract VectorSpace
abstract ElementarySpace{F} &lt;: VectorSpace
const IndexSpace = ElementarySpace</code></pre><p>where the parameter <code>F</code> can be used to represent a field over which the vector space is defined. In particular, we define a unicode shorthand for two common fields, which we take from the Julia <code>Number</code> type hierarchy:</p><pre><code class="language-julia">const ℝ=Real
const ℂ=Complex{Real}</code></pre><p>Every <code>ElementarySpace</code> should implement the following methods</p><ul><li><p><code>dim(::ElementarySpace) -&gt; ::Int</code>   returns the dimension of the space as an <code>Int</code></p></li><li><p><code>dual{S&lt;:ElementarySpace}(::S) -&gt; ::S</code>   returns the <a href="http://en.wikipedia.org/wiki/Dual_space">dual space</a> <code>dual(V)</code>, preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy <code>dual(dual(V)==V</code></p></li><li><p><code>conj{S&lt;:ElementarySpace}(::S) -&gt; ::S</code>   returns the <a href="http://en.wikipedia.org/wiki/Complex_conjugate_vector_space">complex conjugate space</a> <code>conj(V)</code>, preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy <code>conj(conj(V))==V</code> and we automatically have <code>conj{F&lt;:Real}(V::ElementarySpace{F}) = V</code>.</p></li></ul><p>In particular, there is concrete type <code>GeneralSpace</code> which is completely characterized by its field <code>F</code>, its dimension and whether its the dual and/or complex conjugate of <span>$\mathbb{F}^d$</span> .</p><p>We furthermore define the abstract type</p><pre><code class="language-julia">abstract InnerProductSpace{F} &lt;: ElementarySpace{F}</code></pre><p>to contain all vector spaces <code>V</code> which have an inner product and thus a natural mapping from <code>dual(V)</code> to <code>V</code> (for <code>F&lt;:Real</code>) or from <code>dual(V)</code> to <code>conj(V)</code> (for <code>F&lt;:Complex</code>). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.</p><p>Finally there is</p><pre><code class="language-julia">abstract EuclideanSpace{F} &lt;: InnerProductSpace{F}</code></pre><p>to contain all spaces <code>V</code> with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms <code>dual(V)==V</code> (for <code>F&lt;:Real</code>) or <code>dual(V)==conj(V)</code> (for <code>F&lt;:Complex</code>). In particular, we have two concrete types</p><pre><code class="language-julia">immutable CartesianSpace &lt;: EuclideanSpace{ℝ}
    d::Int
end
immutable ComplexSpace &lt;: EuclideanSpace{ℂ}
  d::Int
  dual::Bool
end</code></pre><p>to represent the Euclidean spaces <span>$ℝ^d$</span> or <span>$ℂ^d$</span> without further inner structure. They can be created using the syntax <code>ℝ^d</code> and <code>ℂ^d</code>.</p><h4 id="WIP:-Graded-spaces,-superselection-sectors-and-braiding-1"><a class="docs-heading-anchor" href="#WIP:-Graded-spaces,-superselection-sectors-and-braiding-1">WIP: Graded spaces, superselection sectors and braiding</a><a class="docs-heading-anchor-permalink" href="#WIP:-Graded-spaces,-superselection-sectors-and-braiding-1" title="Permalink"></a></h4><p>If tensors are used to describe system with a certain symmetry corresponding to a group <span>$\mathsf{G}$</span> , this implies that the vector spaces <span>$V$</span> involved carry a corresponding representation <span>$\rho_V: \mathsf{G} \to V$</span> . For compact groups and an otherwise complex euclidean space <span>$V$</span> , these representations can be chosen unitary and it makes sense to decompose <span>$V$</span> according to the irreducible representations of <span>$\mathsf{G}$</span> as</p><div>\[V=\bigoplus_{\lambda} R_{\lambda} \otimes \mathbb{C}^{d_{\lambda}}\]</div><div>\[V\]</div><p>thus becomes a <a href="http://en.m.wikipedia.org/wiki/Graded_vector_space">graded vector space</a> with the different sectors labelled by the irreducible representations <span>$\lambda$</span> of <span>$\mathsf{G}$</span> , and where every sector decomposes as the tensor product of the irrep space <span>$R_\lambda$</span> and a part <span>$\mathbb{C}^{d_\lambda}$</span> that transforms trivially. More generally, a vector space can be graded by the representations of a <a href="http://en.m.wikipedia.org/wiki/Hopf_algebra">Hopf algebra</a>, corresponding to a set of labels constituting a unitary <a href="http://ncatlab.org/nlab/show/fusion+category">fusion category</a>.</p><p>The implementation of graded vector spaces is currently limited to those cases where <span>$V$</span> represents a complex Euclidean space, which would be the typical case for unitary representations of groups. This amounts to the definition</p><pre><code class="language-julia">abstract UnitaryRepresentationSpace{G&lt;:Sector} &lt;: EuclideanSpace{ℂ}</code></pre><p>Here, <code>Sector</code> is an abstract type. A subtype of <code>Sector</code> corresponds to a particular fusion category and the possible objects correspond to the different labels, i.e. the different charges or superselection sectors. <code>Sector</code> objects should support the functionality to map objects (labels) to the corresponding conjugate label (anticharge), to create the trivial object (identity, zero charge) and to determine the outcome of the fusion product. So far, only abelian categories are implemented, corresponding to the representations of abelian groups:</p><pre><code class="language-julia">abstract Sector
abstract Abelian &lt;: Sector
abstract NonAbelian &lt;: Sector
immutable Parity &lt;: Abelian
    charge::Bool
end
immutable ZNCharge{N} &lt;: Abelian
    charge::Int
    ZNCharge(charge::Int)=new(mod(charge,N))
end
immutable U1Charge &lt;: Abelian
    charge::Int
end</code></pre><p>***TODO: Braiding***</p><p>When the different superselection sectors correspond to e.g. different fermion or anyon occupation numbers, a natural action will arise when changing the order of the corresponding vectors in a tensor product. The graded vector space thus becomes a <a href="http://en.m.wikipedia.org/wiki/Braided_vector_space">braided vector space</a>. The simplest example is that of a vector space <code>V</code> graded by fermion parity. An element of <code>V1⊗V2</code> can be mapped to one of <code>V2⊗V1</code> by permuting the two tensor indices and adding a phase <code>-1</code> in the sector where both indices have an odd fermion number. More generally, a complete braiding tensor <span>$R_{\alpha,\beta}^{\gamma}$</span> needs to be specified.</p><h4 id="ElementarySpace-methods-1"><a class="docs-heading-anchor" href="#ElementarySpace-methods-1">ElementarySpace methods</a><a class="docs-heading-anchor-permalink" href="#ElementarySpace-methods-1" title="Permalink"></a></h4><h3 id="Composite-spaces-1"><a class="docs-heading-anchor" href="#Composite-spaces-1">Composite spaces</a><a class="docs-heading-anchor-permalink" href="#Composite-spaces-1" title="Permalink"></a></h3><p>Composite spaces are built out of elementary vector spaces of a homogeneous type <code>S</code>. The most relevant case is the abstract family <code>TensorSpace{S,N}</code> used to denote certain subspaces in the tensor product space of <code>N</code> vector spaces of type <code>S</code>. These spaces will be used to define rank-<code>N</code> tensors, where the different tensor indices <span>$i_j$</span> correspond to the elements of a basis in <span>$V_j$</span> for <span>$j=1,2,...,N$</span> . We start with the definitions</p><pre><code class="language-julia">abstract CompositeSpace{S&lt;:ElementarySpace} &lt;: VectorSpace
abstract TensorSpace{S&lt;:ElementarySpace,N} &lt;: CompositeSpace{S}</code></pre><p>The homogenity restriction is the only sensible way of defining tensor product spaces, since there is no point in defining i.e. a tensor with a group action on some indices and not on other indices and it is even impossible to define the tensor product space of vector spaces over different fields. It is thus not possible to construct tensor product spaces of e.g. <span>$\mathbb{R}^{d_1}$</span> and <span>$\mathbb{C}^{d_2}$</span> , but it is possible to construct tensor product spaces of <span>$\mathbb{C}^{d_1}$</span> and <span>$\mathbb{C}^{d_2}$</span> , or even the dual of the latter. Therefore, for new vector spaces, it is important that any related vector space (e.g. the dual or conjugated space) with which one wants to construct tensor product spaces are of the same concrete type (e.g. no type parameters to denote dual spaces).</p><h4 id="ProductSpace-1"><a class="docs-heading-anchor" href="#ProductSpace-1">ProductSpace</a><a class="docs-heading-anchor-permalink" href="#ProductSpace-1" title="Permalink"></a></h4><p>The complete tensor product space is represented by the concrete type <code>ProductSpace{S,N}</code>. This corresponds to the definitions</p><pre><code class="language-julia">immutable ProductSpace{S&lt;:ElementarySpace,N} &lt;: TensorSpace{S,N}
    spaces::NTuple{N, S}
end</code></pre><p>The <code>ProductSpace</code> of a set of elementary spaces <code>V1</code>, <code>V2</code>, ... of type <code>S</code> can be created as  <code>V1 ⊗ V2 ⊗ ...</code>. Product spaces can be iterated over and indexed in order to extract the elementary spaces, or the tensor product of a subset of them. The dual and conjugate spaces are defined by mapping these actions to the respective elementary vector spaces <code>V1</code>, <code>V2</code>, ... For convience, we also define the <code>transpose</code> of a <code>ProductSpace</code> by reversing the factors <code>V1</code> to <code>VN</code>, and the <code>ctranspose</code> by reversing the conjugated spaces. While there is no such thing as the transpose of a vector space, this definition is convenient because it is compatible with the way <code>(c)transpose</code> is defined for tensors. Finally, the <code>dim</code> of a <code>ProductSpace</code> is given by the product of the <code>dim</code> of its constituents.</p><h4 id="WIP:-InvariantSpace-1"><a class="docs-heading-anchor" href="#WIP:-InvariantSpace-1">WIP: InvariantSpace</a><a class="docs-heading-anchor-permalink" href="#WIP:-InvariantSpace-1" title="Permalink"></a></h4><p>A <code>InvariantSpace</code> corresponds to the subspace of the tensor product of some <code>UnitaryRepresentationSpaces</code> that fuses to the identity (i.e. total &#39;charge&#39; zero). In the case of irreducible representations of groups, it corresponds to the invariant subspace, i.e. the subspace of the tensor product that couples to the trivial representation. The different sectors of an <code>InvariantSpace</code> are labelled not only by the set of sectors of the individual elementary spaces (under the constraint that they have a fusion channel to trivial charge), but also by the intermediate fusion sectors. This gives rise to the concept of a fusion tree.</p><p>In order to describe and manipulate the trivial sector in the tensor product of <code>UnitaryRepresentationSpace</code>s, one thus needs to be able to store and manipulate fusion trees using recouplings (F-moves) or braidings (R-moves). So far, this has only been implemented for spaces with Abelian fusion rules and trivial braiding.</p><ul><li><p>TODO: develop interface to work with fusion trees and braidings</p></li><li><p>TODO: implement some non-trivial cases (SU(2) symmetry, fermions, ...)</p></li></ul><p>References:</p><ul><li><a href="http://thesis.library.caltech.edu/2447/2/thesis.pdf">General theory of anyons and unitary fusion categoies</a></li><li><a href="http://arxiv.org/abs/0907.2994.pdf">General treatment of symmetries in tensors</a></li><li><a href="http://arxiv.org/abs/1008.4774.pdf">U1 symmetric tensors</a></li><li><a href="http://arxiv.org/abs/1208.3919.pdf">SU2 symmetric tensors</a></li><li><a href="http://arxiv.org/abs/1006.3532.pdf">Anyonic tensors 1</a> , <a href="http://arxiv.org/abs/1311.0967.pdf">Anyonic tensors 2</a></li></ul><h4 id="TODO:-Symmetric-and-antisymmetric-vector-spaces-(Fock-space)-1"><a class="docs-heading-anchor" href="#TODO:-Symmetric-and-antisymmetric-vector-spaces-(Fock-space)-1">TODO: Symmetric and antisymmetric vector spaces (Fock space)</a><a class="docs-heading-anchor-permalink" href="#TODO:-Symmetric-and-antisymmetric-vector-spaces-(Fock-space)-1" title="Permalink"></a></h4><p>For the tensor product of <code>N</code> identical copies of a given vector space <code>V</code>, we can also consider the symmetric or antisymmetric subspace of <span>$V^{\otimes N}$</span> , corresponding to e.g. the <code>N</code> particle boson or fermion Fock space corresponding to a single particle Hilbert Space <code>V</code>. This has of course also other applications and can be extended to tensors with (anti)symmetry in subsets of indices.</p><hr/><h2 id="Tensors-1"><a class="docs-heading-anchor" href="#Tensors-1">Tensors</a><a class="docs-heading-anchor-permalink" href="#Tensors-1" title="Permalink"></a></h2><p>The most important elements in <code>TensorToolbox.jl</code> are of course tensors. A rank <code>N</code> tensor is interpreted as the element of (a subspace of) the tensor product of some <code>N</code> elementary vector spaces, represented as a <code>TensorSpace{S,N}</code> object <code>V</code>. A tensor needs to store its components as a list of numbers of type <code>T&lt;:Number</code>. The following observations are in order:</p><ul><li>The element type <code>T</code> must not be the same as the field of the vector space, i.e. a tensor in a (tensor product) of <code>ComplexSpace</code>s can have real components, but a tensor in the product space of <code>CartesianSpace</code>s should not have complex entries. However, this is not strictly enforced.</li><li>The components represent the tensor with respect to a canonical choice of basis in <code>V</code>; so far there is no support to represent different basis choices and the transformations between them. This might change in the future.</li><li>The number of (independent) components of a tensor is given by <code>dim V</code>. When <code>V</code> is a proper subspace of <code>V1 ⊗ V2 ⊗ ... ⊗ VN</code>, then <code>dim V</code> is not just the product of the dimensions of the elementary spaces and the independent components cannot simply be represent as a <code>N</code>-dimensional array.</li></ul><h3 id="Different-tensor-types-1"><a class="docs-heading-anchor" href="#Different-tensor-types-1">Different tensor types</a><a class="docs-heading-anchor-permalink" href="#Different-tensor-types-1" title="Permalink"></a></h3><p>The only difference between tensors (so far) is how their independent components are stored. All other characteristics are encoded in the type of vector space.</p><h4 id="DenseTensor-1"><a class="docs-heading-anchor" href="#DenseTensor-1">DenseTensor</a><a class="docs-heading-anchor-permalink" href="#DenseTensor-1" title="Permalink"></a></h4><p>We start the type hierarchy with an abstract type and currently have a single concrete tensor type, <code>DenseTensor</code>, that stores its components using a <code>Vector{T}</code>, corresponding to the following definitions</p><pre><code class="language-julia">abstract AbstractTensor{S,T,N}
immutable DenseTensor{S,T,N,P} &lt;: AbstractTensor{S,T,N}
    data::Vector{T}
    space::P
end</code></pre><p>Here, we should have <code>P&lt;:TensorSpace{S,N}</code>. With the current Julia type system, this cannot be enforced in the type but only in its constructor (which also checks that <code>length(data)=dim(space)</code>. This might change with the type system redesign.</p><p>We can then define some useful type aliasses for e.g. the standard tensor living in the full tensor product space</p><pre><code class="language-julia">typealias Tensor{S,T,N} DenseTensor{S,T,N,ProductSpace{S,N}}
typealias CartesianTensor{T,N} Tensor{CartesianSpace,T,N}
typealias ComplexTensor{T,N} Tensor{ComplexSpace,T,N}
typealias InvariantTensor{S,T,N} DenseTensor{S,T,N,InvariantSpace{S,N}}
typealias U1Tensor{T,N} ...</code></pre><p>and so on.</p><p>A tensor can be created from a set of components as</p><pre><code class="language-julia">tensor(data, space)</code></pre><p>where <code>data</code> can be an arbitrary <code>Vector{T}</code>.</p><h4 id="TODO:-DiagonalTensor-1"><a class="docs-heading-anchor" href="#TODO:-DiagonalTensor-1">TODO: DiagonalTensor</a><a class="docs-heading-anchor-permalink" href="#TODO:-DiagonalTensor-1" title="Permalink"></a></h4><p>For the specific case of a rank <code>N=2</code> tensor in <code>V ⊗ dual(V)</code>, it is often useful to have an explicit diagonal representation, e.g. to store the eigenvalues or singular values corresponding to a given tensor factorization (see below).</p><h4 id="Other-tensors-?-1"><a class="docs-heading-anchor" href="#Other-tensors-?-1">Other tensors ?</a><a class="docs-heading-anchor-permalink" href="#Other-tensors-?-1" title="Permalink"></a></h4><p>Should there be sparse tensors?</p><h3 id="Tensor-properties-1"><a class="docs-heading-anchor" href="#Tensor-properties-1">Tensor properties</a><a class="docs-heading-anchor-permalink" href="#Tensor-properties-1" title="Permalink"></a></h3><p>The basic tensor methods allow to construct tensors and query their characteristics</p><ul><li><p><code>space(t)</code> returns the vector space of a tensor <code>t</code>.</p></li><li><p><code>eltype(t)</code> returns the element type <code>T</code> of the coefficient vector.</p></li><li><p><code>numind(t)=order(t)</code> returns the number of tensor indices <code>N</code>, i.e. the number of elementary vector spaces in <code>space(t)</code>.</p></li><li><p><code>in(t,V)</code> can be used to check if <code>space(t)</code> is a subspace of <code>V</code>.</p></li><li><p><code>vec(t)</code> returns the coefficient vector <code>data</code> which allows to modify the tensor components</p></li><li><p><code>full(t)</code> returns an <code>Array{T,N}</code> representation of a rank <code>N</code> tensor. Only when <code>space(t)</code> is a <code>ProductSpace</code> is this isomorphic to the vector of coefficients, otherwise zeros or repeated coefficients might appear. Therefore, <code>full(t)</code> does not share data with the tensor and cannot be used to modified its contens.</p></li></ul><h3 id="Constructing-and-converting-tensors-1"><a class="docs-heading-anchor" href="#Constructing-and-converting-tensors-1">Constructing and converting tensors</a><a class="docs-heading-anchor-permalink" href="#Constructing-and-converting-tensors-1" title="Permalink"></a></h3><ul><li><p><code>tensor(data,V)</code> can be used to construct a <code>DenseTensor</code>. Here, <code>data</code> represents an arbitrary <code>Array{T,N}</code>. If the vector space <code>V</code> is provided, the multidimensional characteristics of <code>data</code> are ignored. Only <code>vec(data)</code> is used and the only requirement is that <code>length(data)</code> equals <code>dim(V)</code>. If <code>V</code> is absent, then <code>tensor(data)</code> creates a <code>CartesianTensor</code> if <code>T&lt;:Real</code> with <code>V=ProductSpace(map(CartesianSpace,size(data)))</code>. If <code>T&lt;:Complex</code>, a <code>ComplexTensor</code> is constructed, even though there it is already ambiguous whether the normal complex Euclidean space or the dual space should be constructed for every index.</p></li><li><p><code>zeros(T,V)</code> creates a tensor in <code>V</code> filled with zero coefficients, which is equivalent to the zero vector. If <code>T</code> is omitted, it is given the default value <code>T=Float64</code>.</p></li><li><p><code>rand(T,V)</code> creates a tensor in <code>V</code> filled with random coefficients. A default value of <code>T=Float64</code> is asssumed when <code>T</code> is omitted.</p></li><li><p><code>similar(t,T,V)</code> constructs an unitialized tensor similar to <code>t</code>, but with element type <code>T</code> and for different space <code>V</code> (of the same type of <code>space(t)</code>).</p></li><li><p><code>complex(t)</code> converts <code>t</code> to a tensor with complex-valued coefficients; it does nothing if  <code>eltype(t)&lt;:Complex</code>.</p></li><li><p><code>real(t)</code> and <code>imag(t)</code> returns a tensor with the real and imaginary parts of the coefficients; this is a basis-dependent operations and refers to the canonical basis with respect to which the coefficients are stored.</p></li><li><p><code>float32</code>, <code>float64</code>, <code>complex64</code> and <code>complex128</code> can be used to cast the tensor coefficients into a specific format.</p></li></ul><h3 id="Basic-linear-algebra-methods-1"><a class="docs-heading-anchor" href="#Basic-linear-algebra-methods-1">Basic linear algebra methods</a><a class="docs-heading-anchor-permalink" href="#Basic-linear-algebra-methods-1" title="Permalink"></a></h3><p>The following methods allow to  perform basic linear algebra (corresponding to their interpretation as elements in a vector space):</p><ul><li>arithmetic: tensors in the same vector space can be added, subtracted en multiplied with scalars. There are also mutating methods such as <code>scale!</code> and <code>axpy!</code>.</li><li><code>conj(t)</code> conjugates the tensor in the canonical basis. Note that this also maps the tensor to the space <code>conj(V)</code> which is different from <code>V</code>. Therefore, <code>conj!</code> is not an inplace operation but can be used to store the result of conjugating the tensor <code>src</code> in a preallocated tensor <code>dst</code> in <code>conj(V)</code> using <code>conj!(dst,src)</code>.</li><li><code>transpose(t)</code> implements an isomorphism from <code>V=V1 ⊗ V2 ⊗ ... ⊗ VN</code> to <code>reverse(V) = VN ⊗ ... ⊗ V2 ⊗ V1</code>, i.e. it reverses the order of the indices. For a tensor with <code>N=1</code>, this has no effect. For a tensor with <code>N=2</code>, this corresponds to the most general definition of the <a href="http://en.wikipedia.org/wiki/Transpose#Transpose_of_a_linear_map">transpose of a linear map</a>. A linear map <span>$f:V\to W$</span> can be identified with a tensor in <code>W ⊗ dual(V)</code>. The transpose of this tensor lives in <code>dual(V) ⊗ W</code>, which can be identified with a linear map from <code>dual(W)</code> to <code>dual(V)</code>, in accordance with the aforementioned definition. Only for real Euclidean vector spaces is <code>dual(V) == V</code> and does this correspond to a map from <code>W</code> to <code>V</code>.  For <code>N&gt;2</code>, there is no standard definition of transpose, but reversing all indices corresponds to the convention used in the <a href="http://en.wikipedia.org/wiki/Penrose_graphical_notation">Penrose graphical notation</a>, where transposing corresponds to mirroring the diagrammatic representation of the tensor. There is again a mutating version <code>transpose!(dst,src)</code> that allows to store the result of transposing <code>src</code> in the preallocated tensor <code>dst</code>.</li><li><code>ctranspose(t)</code> is equivalent to <code>conj(transpose(t))</code> but performs this operation in a single step. In particular, for <code>N=2</code>, it maps a tensor in <code>W ⊗ dual(V)</code> to a tensor in <code>dual(conj(V)) ⊗ conj(W)</code>. For complex Euclidean spaces (where <code>dual(V)=conj(V)</code>) or real Euclidean spaces (where <code>dual(V)=V</code> and <code>conj(V)=V</code>), the conjugate transpose of a tensor in <code>W ⊗ dual(V)</code> is a tensor in <code>V ⊗ dual(W)</code>, which can be interpreted as a linear map from <code>W</code> to <code>V</code>, according to the definition of the adjoint map. As before, <code>ctranpose!(dst,src)</code> stores the result in the preallocated destination tensor.</li><li><code>dot(t1,t2)</code> computers the inner product between two tensors <code>t1</code> and <code>t2</code>. This is only possible if <code>space(t1)==space(t2)</code> and if this space is the tensor product of elementary vector spaces with an inner product, i.e. <code>S&lt;:InnerProductSpace</code>. However, the interface for specifying general inner products still needs to be developed, and thus so far <code>dot(t1,t2)</code> only works if <code>S&lt;:EuclideanSpace</code>. We choose the canonical basis of euclidean spaces orthonormal, such that <code>dot(t1,t2) = dot(vec(t1),vec(t2))</code>, i.e. the inner product corresponds to the normal scalar product of the coefficient vectors.</li><li><code>vecnorm(t)</code> computes the norm of tensor <code>t</code>; it is essentially equivalent to <code>sqrt(dot(t,t))</code> and is therefore subject to the same restrictions (<code>S&lt;:EuclideanSpace</code>) and satisfies <code>vecnorm(t)=norm(vec(t))</code>.</li></ul><p>Currently, <code>conj</code>, <code>transpose</code> and <code>ctranspose</code> allocate new tensors for storing the result. This might change in the future such that they return a simple view over the same data, although this is not entirely trivial for tensors which do not live in a simple <code>ProductSpace{S,N}</code>.</p><h3 id="TODO:-Indexing-1"><a class="docs-heading-anchor" href="#TODO:-Indexing-1">TODO: Indexing</a><a class="docs-heading-anchor-permalink" href="#TODO:-Indexing-1" title="Permalink"></a></h3><h3 id="Tensor-operations-1"><a class="docs-heading-anchor" href="#Tensor-operations-1">Tensor operations</a><a class="docs-heading-anchor-permalink" href="#Tensor-operations-1" title="Permalink"></a></h3><ul><li><code>scalar(t)</code> can be applied to a rank <code>N=0</code> tensor to construct the single scalar component, since in that case <code>space(t)</code> is an empty tensor product space and thus equivalent to the corresponding number field.</li></ul><h3 id="Tensor-factorizations-1"><a class="docs-heading-anchor" href="#Tensor-factorizations-1">Tensor factorizations</a><a class="docs-heading-anchor-permalink" href="#Tensor-factorizations-1" title="Permalink"></a></h3><hr/><h2 id="Tensor-Maps-1"><a class="docs-heading-anchor" href="#Tensor-Maps-1">Tensor Maps</a><a class="docs-heading-anchor-permalink" href="#Tensor-Maps-1" title="Permalink"></a></h2><p>Linear maps between tensor spaces with possible efficient implementation.</p><hr/><h2 id="Tensor-Networks-1"><a class="docs-heading-anchor" href="#Tensor-Networks-1">Tensor Networks</a><a class="docs-heading-anchor-permalink" href="#Tensor-Networks-1" title="Permalink"></a></h2><hr/><h2 id="Bibliography-1"><a class="docs-heading-anchor" href="#Bibliography-1">Bibliography</a><a class="docs-heading-anchor-permalink" href="#Bibliography-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-tung"><a class="tag is-link" href="#citeref-tung">tung</a>Wu-Ki Tung. Group Theory in Physics: Introduction to Symmetry Principles, Group Representations, and Special Functions in Classical and Quantum Physics. World Scientific Publishing Company, 1985.  </li></ul></section></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 February 2020 08:22">Wednesday 12 February 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
