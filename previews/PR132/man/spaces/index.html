<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector spaces ¬∑ TensorKit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li class="is-active"><a class="tocitem" href>Vector spaces</a><ul class="internal"><li><a class="tocitem" href="#ss_fields"><span>Fields</span></a></li><li><a class="tocitem" href="#ss_elementaryspaces"><span>Elementary spaces</span></a></li><li><a class="tocitem" href="#ss_compositespaces"><span>Composite spaces</span></a></li><li><a class="tocitem" href="#ss_homspaces"><span>Space of morphisms</span></a></li><li><a class="tocitem" href="#Partial-order-among-vector-spaces"><span>Partial order among vector spaces</span></a></li></ul></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors and fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Vector spaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vector spaces</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/spaces.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_spaces"><a class="docs-heading-anchor" href="#s_spaces">Vector spaces</a><a id="s_spaces-1"></a><a class="docs-heading-anchor-permalink" href="#s_spaces" title="Permalink"></a></h1><p>From the <a href="../intro/#s_intro">Introduction</a>, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type <code>VectorSpace</code></p><pre><code class="language-julia hljs">abstract type VectorSpace end</code></pre><p>which is actually a too restricted name. All instances of subtypes of <code>VectorSpace</code> will represent objects in <span>$ùïú$</span>-linear monoidal categories, but this can go beyond normal vector spaces (i.e. objects in the category <span>$\mathbf{Vect}$</span>) and even beyond objects of <span>$\mathbf{SVect}$</span>. However, in order not to make the remaining discussion to abstract or complicated, we will simply refer to subtypes of <code>VectorSpace</code> instead of specific categories, and to spaces (i.e. <code>VectorSpace</code> instances) instead of objects from these categories. In particular, we define two abstract subtypes</p><pre><code class="language-julia hljs">abstract type ElementarySpace{ùïú} &lt;: VectorSpace end
const IndexSpace = ElementarySpace

abstract type CompositeSpace{S&lt;:ElementarySpace} &lt;: VectorSpace end</code></pre><p>Here, <code>ElementarySpace</code> is a super type for all vector spaces (objects) that can be associated with the individual indices of a tensor, as hinted to by its alias <code>IndexSpace</code>. It is parametrically dependent on <code>ùïú</code>, the field of scalars (see the next section on <a href="#ss_fields">Fields</a>).</p><p>On the other hand, subtypes of <code>CompositeSpace{S}</code> where <code>S&lt;:ElementarySpace</code> are composed of a number of elementary spaces of type <code>S</code>. So far, there is a single concrete type <code>ProductSpace{S,N}</code> that represents the homogeneous tensor product of <code>N</code> vector spaces of type <code>S</code>. Its properties are discussed in the section on <a href="#ss_compositespaces">Composite spaces</a>, together with possible extensions for the future.</p><p>Throughout TensorKit.jl, the function <code>spacetype</code> returns the type of <code>ElementarySpace</code> associated with e.g. a composite space or a tensor. It works both on instances and in the type domain. Its use will be illustrated below.</p><h2 id="ss_fields"><a class="docs-heading-anchor" href="#ss_fields">Fields</a><a id="ss_fields-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fields" title="Permalink"></a></h2><p>Vector spaces (linear categories) are defined over a field of scalars <span>$ùïú$</span>. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via</p><pre><code class="language-julia hljs">abstract type Field end

struct RealNumbers &lt;: Field end
struct ComplexNumbers &lt;: Field end

const ‚Ñù = RealNumbers()
const ‚ÑÇ = ComplexNumbers()</code></pre><p>Note that <code>‚Ñù</code> and <code>‚ÑÇ</code> can be typed as <code>\bbR</code>+TAB and <code>\bbC</code>+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia&#39;s <code>Number</code> hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 3 ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0 ‚àà ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0+1.0*im ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Float64 ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ComplexF64 ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>and furthermore ‚Äîprobably more usefully‚Äî <code>‚Ñù^n</code> and <code>‚ÑÇ^n</code> create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor <code>a</code> can be obtained with <code>field(a)</code>.</p><h2 id="ss_elementaryspaces"><a class="docs-heading-anchor" href="#ss_elementaryspaces">Elementary spaces</a><a id="ss_elementaryspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_elementaryspaces" title="Permalink"></a></h2><p>As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of <code>ElementarySpace</code>. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every <code>ElementarySpace</code> should implement the following methods</p><ul><li><p><code>dim(::ElementarySpace) -&gt; ::Int</code> returns the dimension of the space as an <code>Int</code></p></li><li><p><code>dual(::S) where {S&lt;:ElementarySpace} -&gt; ::S</code> returns the   <a href="http://en.wikipedia.org/wiki/Dual_space">dual space</a> <code>dual(V)</code>, using an instance of   the same concrete type (i.e. not via type parameters); this should satisfy   <code>dual(dual(V))==V</code></p></li><li><p><code>conj(::S) where {S&lt;:ElementarySpace} -&gt; ::S</code> returns the   <a href="http://en.wikipedia.org/wiki/Complex_conjugate_vector_space">complex conjugate space</a>   <code>conj(V)</code>, using an instance of the same concrete type (i.e. not via type parameters);   this should satisfy <code>conj(conj(V))==V</code> and we automatically have   <code>conj(V::ElementarySpace{‚Ñù}) = V</code>.</p></li></ul><p>For convenience, the dual of a space <code>V</code> can also be obtained as <code>V&#39;</code>.</p><p>There is concrete type <code>GeneralSpace</code> which is completely characterized by its field <code>ùïú</code>, its dimension and whether its the dual and/or complex conjugate of <span>$ùïú^d$</span>.</p><pre><code class="language-julia hljs">struct GeneralSpace{ùïú} &lt;: ElementarySpace{ùïú}
    d::Int
    dual::Bool
    conj::Bool
end</code></pre><p>We furthermore define the trait types</p><pre><code class="language-julia hljs">abstract type InnerProductStyle end
struct NoInnerProduct &lt;: InnerProductStyle end
abstract type HasInnerProduct &lt;: InnerProductStyle end
struct EuclideanProduct &lt;: HasInnerProduct end</code></pre><p>to denote for a vector space <code>V</code> whether it has an inner product and thus a canonical mapping from <code>dual(V)</code> to <code>V</code> (for <code>ùïú ‚äÜ ‚Ñù</code>) or from <code>dual(V)</code> to <code>conj(V)</code> (otherwise). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.</p><p>The <code>EuclideanProduct</code> has the natural isomorphisms <code>dual(V) == V</code> (for <code>ùïú == ‚Ñù</code>) or <code>dual(V) == conj(V)</code> (for <code>ùïú == ‚ÑÇ</code>). In the language of the previous section on <a href="../categories/#s_categories">categories</a>, this trait represents <a href="../categories/#ss_adjoints">dagger or unitary categories</a>, and these vector spaces support an <code>adjoint</code> operation.</p><p>In particular, the two concrete types</p><pre><code class="language-julia hljs">struct CartesianSpace &lt;: ElementarySpace{‚Ñù}
    d::Int
end
struct ComplexSpace &lt;: ElementarySpace{‚ÑÇ}
  d::Int
  dual::Bool
end</code></pre><p>represent the Euclidean spaces <span>$‚Ñù^d$</span> or <span>$‚ÑÇ^d$</span> without further inner structure. They can be created using the syntax <code>CartesianSpace(d) == ‚Ñù^d == ‚Ñù[d]</code> and <code>ComplexSpace(d) == ‚ÑÇ^d == ‚ÑÇ[d]</code>, or <code>ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (‚ÑÇ^d)&#39; == ‚ÑÇ[d]&#39;</code> for the dual space of the latter. Note that the brackets are required because of the precedence rules, since <code>d&#39; == d</code> for <code>d::Integer</code>.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(‚Ñù^10)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚Ñù^10)&#39; == ‚Ñù^10 == ‚Ñù[10] == ‚Ñù[](10)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching getindex(::TensorKit.RealNumbers, ::Int64)

Closest candidates are:
  getindex(::TensorKit.RealNumbers)
   @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/spaces/cartesianspace.jl:39</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚Ñù^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(‚ÑÇ^5) == (‚ÑÇ^5)&#39; == conj(‚ÑÇ^5) == ComplexSpace(5; dual = true)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(‚Ñù[])</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; InnerProductStyle(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanProduct()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; InnerProductStyle(‚ÑÇ^5)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanProduct()</code></pre><p>Note that <code>‚Ñù[]</code> and <code>‚ÑÇ[]</code> are synonyms for <code>CartesianSpace</code> and <code>ComplexSpace</code> respectively, such that yet another syntax is e.g. <code>‚ÑÇ[](d)</code>. This is not very useful in itself, and is motivated by its generalization to <code>GradedSpace</code>. We refer to the subsection on <a href="man/@ref s_rep">graded spaces</a> on the <a href="../sectors/#s_sectorsrepfusion">next page</a> for further information about <code>GradedSpace</code>, which is another subtype of <code>ElementarySpace{‚ÑÇ}</code> with an inner structure corresponding to the irreducible representations of a group, or more generally, the simple objects of a fusion category.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For <code>‚ÑÇ^n</code> the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for <code>‚ÑÇ^n</code>, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more purist approach can be useful to detect errors (e.g. unintended contractions). Only with <code>‚Ñù^n</code> will their be no distinction between a space and its dual. When creating tensors with indices in <code>‚Ñù^n</code> that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.</p></div></div><h2 id="ss_compositespaces"><a class="docs-heading-anchor" href="#ss_compositespaces">Composite spaces</a><a id="ss_compositespaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_compositespaces" title="Permalink"></a></h2><p>Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent (and currently only) example is a tensor product of <code>N</code> elementary spaces of the same type <code>S</code>, which is implemented as</p><pre><code class="language-julia hljs">struct ProductSpace{S&lt;:ElementarySpace, N} &lt;: CompositeSpace{S}
    spaces::NTuple{N, S}
end</code></pre><p>Given some <code>V1::S</code>, <code>V2::S</code>, <code>V3::S</code> of the same type <code>S&lt;:ElementarySpace</code>, we can easily construct <code>ProductSpace{S,3}((V1,V2,V3))</code> as <code>ProductSpace(V1,V2,V3)</code> or using <code>V1 ‚äó V2 ‚äó V3</code>, where <code>‚äó</code> is simply obtained by typing <code>\otimes</code>+TAB. In fact, for convenience, also the regular multiplication operator <code>*</code> acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 ‚äó V2 ‚äó V1&#39; == V1 * V2 * V1&#39; == ProductSpace(V1,V2,V1&#39;) == ProductSpace(V1,V2) ‚äó V1&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1^3</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(ProductSpace{ComplexSpace,3})</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code></pre><p>Here, the new function <code>dims</code> maps <code>dim</code> to the individual spaces in a <code>ProductSpace</code> and returns the result as a tuple. Note that the rationale for the last result was explained in the subsection on <a href="../categories/#ss_dual">duality</a> in the introduction to <a href="../categories/#s_categories">category theory</a>.</p><p>Following Julia&#39;s Base library, the function <code>one</code> applied to a <code>ProductSpace{S,N}</code> returns the multiplicative identity, which is <code>ProductSpace{S,0}(())</code>. The same result is obtained when acting on an instance <code>V</code> of <code>S::ElementarySpace</code> directly, however note that <code>V ‚äó one(V)</code> will yield a <code>ProductSpace{S,1}(V)</code> and not <code>V</code> itself. The same result can be obtained with <code>‚äó(V)</code>. Similar to Julia Base, <code>one</code> also works in the type domain.</p><p>In the future, other <code>CompositeSpace</code> types could be added. For example, the wave function of an <code>N</code>-particle quantum system in first quantization would require the introduction of a <code>SymmetricSpace{S,N}</code> or a <code>AntiSymmetricSpace{S,N}</code> for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of <code>V^N</code>, where <code>V::S</code> represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.</p><h2 id="ss_homspaces"><a class="docs-heading-anchor" href="#ss_homspaces">Space of morphisms</a><a id="ss_homspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_homspaces" title="Permalink"></a></h2><p>Given that we define tensor maps as morphisms in a <span>$ùïú$</span>-linear monoidal category, i.e. linear maps, we also define a type to denote the corresponding space. Indeed, in a <span>$ùïú$</span>-linear category <span>$C$</span>, the set of morphisms <span>$\mathrm{Hom}(W,V)$</span> for <span>$V,W ‚àà C$</span> is always an actual vector space, irrespective of whether or not <span>$C$</span> is a subcategory of <span>$\mathbf{(S)Vect}$</span>.</p><p>We introduce the type</p><pre><code class="language-julia hljs">struct HomSpace{S&lt;:ElementarySpace, P1&lt;:CompositeSpace{S}, P2&lt;:CompositeSpace{S}}
    codomain::P1
    domain::P2
end</code></pre><p>and can create it as either <code>domain ‚Üí codomain</code> or <code>codomain ‚Üê domain</code> (where the arrows are obtained as <code>\to+TAB</code> or <code>\leftarrow+TAB</code>, and as <code>\rightarrow+TAB</code> respectively). The reason for first listing the codomain and than the domain will become clear in the <a href="../tensors/#s_tensors">section on tensor maps</a>.</p><p>Note that <code>HomSpace</code> is not a subtype of <code>VectorSpace</code>, i.e. we restrict the latter to denote certain categories and their objects, and keep <code>HomSpace</code> distinct. However, <code>HomSpace</code> has a number of properties defined, which we illustrate via examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üí ‚ÑÇ^3 ‚äó dual(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(W)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(W)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê (‚ÑÇ^4 ‚äó (‚ÑÇ^3)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; adjoint(W)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê (‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(W)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(typeof(W))</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[1]</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[2]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[3]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[4]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W)</code><code class="nohighlight hljs ansi" style="display:block;">72</code></pre><p>Note that indexing <code>W</code> yields first the spaces in the codomain, followed by the dual of the spaces in the domain. This particular convention is useful in combination with the instances of type <a href="../../lib/tensors/#TensorKit.TensorMap"><code>TensorMap</code></a>, which represent morphisms living in such a <code>HomSpace</code>. Also note that <code>dim(W)</code> here seems to be the product of the dimensions of the individual spaces, but that this is no longer true once symmetries are involved. At any time will <code>dim(::HomSpace)</code> represent the number of linearly independent morphisms in this space.</p><h2 id="Partial-order-among-vector-spaces"><a class="docs-heading-anchor" href="#Partial-order-among-vector-spaces">Partial order among vector spaces</a><a id="Partial-order-among-vector-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-order-among-vector-spaces" title="Permalink"></a></h2><p>Vector spaces of the same <code>spacetype</code> can be given a partial order, based on whether there exist injective morphisms (a.k.a <em>monomorphisms</em>) or surjective morphisms (a.k.a. <em>epimorphisms</em>) between them. In particular, we define <code>ismonomorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âæ V2</code> (obtained as <code>\precsim+TAB</code>), to express whether there exist monomorphisms in <code>V1‚ÜíV2</code>. Similarly, we define <code>isepimorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âø V2</code> (obtained as <code>\succsim+TAB</code>), to express whether there exist epimorphisms in <code>V1‚ÜíV2</code>. Finally, we define <code>isisomorphic(V1, V2)</code>, with Unicode alternative <code>V1 ‚âÖ V2</code> (obtained as <code>\cong+TAB</code>), to express whether there exist isomorphism in <code>V1‚ÜíV2</code>. In particular <code>V1 ‚âÖ V2</code> if and only if <code>V1 ‚âæ V2 &amp;&amp; V1 ‚âø V2</code>.</p><p>For completeness, we also export the strict comparison operators <code>‚â∫</code> and <code>‚âª</code> (<code>\prec+TAB</code> and <code>\succ+TAB</code>), with definitions</p><pre><code class="language-julia hljs">‚â∫(V1::VectorSpace, V2::VectorSpace) = V1 ‚âæ V2 &amp;&amp; !(V1 ‚âø V2)
‚âª(V1::VectorSpace, V2::VectorSpace) = V1 ‚âø V2 &amp;&amp; !(V1 ‚âæ V2)</code></pre><p>However, as we expect these to be less commonly used, no ASCII alternative is provided.</p><p>In the context of <code>InnerProductStyle(V) &lt;: EuclideanProduct</code>, <code>V1 ‚âæ V2</code> implies that there exists isometries <span>$W:V1 ‚Üí V2$</span> such that <span>$W^‚Ä† ‚àò W = \mathrm{id}_{V1}$</span>, while <code>V1 ‚âÖ V2</code> implies that there exist unitaries <span>$U:V1‚ÜíV2$</span> such that <span>$U^‚Ä† ‚àò U = \mathrm{id}_{V1}$</span> and <span>$U ‚àò U^‚Ä† = \mathrm{id}_{V2}$</span>.</p><p>Note that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of <code>ProductSpace</code>, while the other is an <code>ElementarySpace</code>. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.</p><p>There are also a number of convenience functions to create isomorphic spaces. The function <code>fuse(V1, V2, ...)</code> or <code>fuse(V1 ‚äó V2 ‚äó ...)</code> returns an elementary space that is isomorphic to <code>V1 ‚äó V2 ‚äó ...</code>. The function <code>flip(V::ElementarySpace)</code> returns a space that is isomorphic to <code>V</code> but has <code>isdual(flip(V)) == isdual(V&#39;)</code>, i.e. if <code>V</code> is a normal space than <code>flip(V)</code> is a dual space. <code>flip(V)</code> is different from <code>dual(V)</code> in the case of <a href="../../lib/spaces/#TensorKit.GradedSpace"><code>GradedSpace</code></a>. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from <code>V1</code> to <code>flip(V1)</code>. We refer to <a href="man/@ref">Index operations</a> for further information. Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù^3 ‚âæ ‚Ñù^5</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^3 ‚âæ (‚ÑÇ^5)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚âÖ (‚ÑÇ^5)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚Ñù^5, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39; ‚äó ‚ÑÇ^2)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^30</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39;) ‚äó ‚ÑÇ^2 ‚âÖ fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39;, ‚ÑÇ^2) ‚âÖ ‚ÑÇ^3 ‚äó (‚ÑÇ^5)&#39; ‚äó ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) ‚âÖ ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) == ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>We also define the direct sum <code>V1</code> and <code>V2</code> as <code>V1 ‚äï V2</code>, where <code>‚äï</code> is obtained by typing <code>\oplus</code>+TAB. This is possible only if <code>isdual(V1) == isdual(V2)</code>. With a little pun on Julia Base, <code>oneunit</code> applied to an elementary space (in the value or type domain) returns the one-dimensional space, which is isomorphic to the scalar field of the space itself. Some examples illustrate this better</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù^5 ‚äï ‚Ñù^3</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï (‚ÑÇ^3)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Direct sum of a vector space and its dual does not exist&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; oneunit(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï oneunit(ComplexSpace)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; oneunit((‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚äï oneunit((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5)&#39; ‚äï oneunit((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Direct sum of a vector space and its dual does not exist&quot;)</code></pre><p>Finally, while spaces have a partial order, there is no unique infimum or supremum of a two or more spaces. However, if <code>V1</code> and <code>V2</code> are two <code>ElementarySpace</code> instances with <code>isdual(V1) == isdual(V2)</code>, then we can define a unique infimum <code>V::ElementarySpace</code> with the same value of <code>isdual</code> that satisfies <code>V ‚âæ V1</code> and <code>V ‚âæ V2</code>, as well as a unique supremum <code>W::ElementarySpace</code> with the same value of <code>isdual</code> that satisfies <code>W ‚âø V1</code> and <code>W ‚âø V2</code>. For <code>CartesianSpace</code> and <code>ComplexSpace</code>, this simply amounts to the space with minimal or maximal dimension, i.e.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(‚Ñù^5, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, ‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, (‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;Supremum of space and dual space does not exist&quot;)</code></pre><p>The names <code>infimum</code> and <code>supremum</code> are especially suited in the case of <a href="../../lib/spaces/#TensorKit.GradedSpace"><code>GradedSpace</code></a>, as the infimum of two spaces might be different from either of those two spaces, and similar for the supremum.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../categories/">¬´ Optional introduction to category theory</a><a class="docs-footer-nextpage" href="../sectors/">Sectors, representation spaces and fusion trees ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 June 2024 14:17">Monday 24 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
