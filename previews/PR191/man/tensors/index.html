<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensors and the TensorMap type ¬∑ TensorKit.jl</title><meta name="title" content="Tensors and the TensorMap type ¬∑ TensorKit.jl"/><meta property="og:title" content="Tensors and the TensorMap type ¬∑ TensorKit.jl"/><meta property="twitter:title" content="Tensors and the TensorMap type ¬∑ TensorKit.jl"/><meta name="description" content="Documentation for TensorKit.jl."/><meta property="og:description" content="Documentation for TensorKit.jl."/><meta property="twitter:description" content="Documentation for TensorKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="TensorKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="TensorKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, graded spaces and fusion trees</a></li><li class="is-active"><a class="tocitem" href>Tensors and the <code>TensorMap</code> type</a><ul class="internal"><li><a class="tocitem" href="#ss_tensor_storage"><span>Storage of tensor data</span></a></li><li><a class="tocitem" href="#ss_tensor_construction"><span>Constructing tensor maps and accessing tensor data</span></a></li><li><a class="tocitem" href="#ss_tensor_properties"><span>Tensor properties</span></a></li><li><a class="tocitem" href="#ss_tensor_readwrite"><span>Reading and writing tensors: <code>Dict</code> conversion</span></a></li><li><a class="tocitem" href="#ss_tensor_linalg"><span>Vector space and linear algebra operations</span></a></li><li><a class="tocitem" href="#Index-manipulations"><span>Index manipulations</span></a></li><li><a class="tocitem" href="#ss_tensor_factorization"><span>Tensor factorizations</span></a></li><li><a class="tocitem" href="#ss_tensor_contraction"><span>Bosonic tensor contractions and tensor networks</span></a></li><li><a class="tocitem" href="#Fermionic-tensor-contractions"><span>Fermionic tensor contractions</span></a></li><li><a class="tocitem" href="#Anyonic-tensor-contractions"><span>Anyonic tensor contractions</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors and fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tensors and the <code>TensorMap</code> type</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensors and the <code>TensorMap</code> type</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jutho/TensorKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/tensors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="s_tensors"><a class="docs-heading-anchor" href="#s_tensors">Tensors and the <code>TensorMap</code> type</a><a id="s_tensors-1"></a><a class="docs-heading-anchor-permalink" href="#s_tensors" title="Permalink"></a></h1><p>This last page explains how to create and manipulate tensors in TensorKit.jl. As this is probably the most important part of the manual, we will also focus more strongly on the usage and interface, and less so on the underlying implementation. The only aspect of the implementation that we will address is the storage of the tensor data, as this is important to know how to create and initialize a tensor, but will in fact also shed light on how some of the methods work.</p><p>As mentioned, all tensors in TensorKit.jl are interpreted as linear maps (morphisms) from a domain (a <code>ProductSpace{S,N‚ÇÇ}</code>) to a codomain (another <code>ProductSpace{S,N‚ÇÅ}</code>), with the same <code>S&lt;:ElementarySpace</code> that labels the type of spaces associated with the individual tensor indices. The overall type for all such tensor maps is <code>AbstractTensorMap{S, N‚ÇÅ, N‚ÇÇ}</code>. Note that we place information about the codomain before that of the domain. Indeed, we have already encountered the constructor for the concrete parametric type <code>TensorMap</code> in the form <code>TensorMap(..., codomain, domain)</code>. This convention is opposite to the mathematical notation, e.g. <span>$\mathrm{Hom}(W,V)$</span> or <span>$f:W‚ÜíV$</span>, but originates from the fact that a normal matrix is also denoted as having size <code>m √ó n</code> or is constructed in Julia as <code>Array(..., (m, n))</code>, where the first integer <code>m</code> refers to the codomain being <code>m</code>- dimensional, and the seond integer <code>n</code> to the domain being <code>n</code>-dimensional. This also explains why we have consistently used the symbol <span>$W$</span> for spaces in the domain and <span>$V$</span> for spaces in the codomain. A tensor map <span>$t:(W‚ÇÅ ‚äó ‚Ä¶ ‚äó W_{N‚ÇÇ}) ‚Üí (V‚ÇÅ ‚äó ‚Ä¶ ‚äó V_{N‚ÇÅ})$</span> will be created in Julia as <code>TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W1 ‚äó ... ‚äó WN2)</code>.</p><p>Furthermore, the abstract type <code>AbstractTensor{S,N}</code> is just a synonym for <code>AbstractTensorMap{S,N,0}</code>, i.e. for tensor maps with an empty domain, which is equivalent to the unit of the monoidal category, or thus, the field of scalars <span>$ùïú$</span>.</p><p>Currently, <code>AbstractTensorMap</code> has two subtypes. <code>TensorMap</code> provides the actual implementation, where the data of the tensor is stored in a <code>DenseArray</code> (more specifically a <code>DenseMatrix</code> as will be explained below). <code>AdjointTensorMap</code> is a simple wrapper type to denote the adjoint of an existing <code>TensorMap</code> object. In the future, additional types could be defined, to deal with sparse data, static data, diagonal data, etc...</p><h2 id="ss_tensor_storage"><a class="docs-heading-anchor" href="#ss_tensor_storage">Storage of tensor data</a><a id="ss_tensor_storage-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_storage" title="Permalink"></a></h2><p>Before discussion how to construct and initalize a <code>TensorMap{S}</code>, let us discuss what is meant by &#39;tensor data&#39; and how it can efficiently and compactly be stored. Let us first discuss the case <code>sectortype(S) == Trivial</code> sector, i.e. the case of no symmetries. In that case the data of a tensor <code>t = TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W1 ‚äó ... ‚äó WN2)</code> can just be represented as a multidimensional array of size</p><p><code>(dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ))</code></p><p>which can also be reshaped into matrix of size</p><p><code>(dim(V1)*dim(V2)*‚Ä¶*dim(VN‚ÇÅ), dim(W1)*dim(W2)*‚Ä¶*dim(WN‚ÇÇ))</code></p><p>and is really the matrix representation of the linear map that the tensor represents. In particular, given a second tensor <code>t2</code> whose domain matches with the codomain of <code>t</code>, function composition amounts to multiplication of their corresponding data matrices. Similarly, tensor factorizations such as the singular value decomposition, which we discuss below, can act directly on this matrix representation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One might wonder if it would not have been more natural to represent the tensor data as <code>(dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(WN‚ÇÇ), ‚Ä¶, dim(W1))</code> given how employing the duality naturally reverses the tensor product, as encountered with the interface of <a href="../../lib/sectors/#TensorKit.repartition"><code>repartition</code></a> for <a href="../sectors/#ss_fusiontrees">fusion trees</a>. However, such a representation, when plainly <code>reshape</code>d to a matrix, would not have the above properties and would thus not constitute the matrix representation of the tensor in a compatible basis.</p></div></div><p>Now consider the case where <code>sectortype(S) == I</code> for some <code>I</code> which has <code>FusionStyle(I) == UniqueFusion()</code>, i.e. the representations of an Abelian group, e.g. <code>I == Irrep[‚Ñ§‚ÇÇ]</code> or <code>I == Irrep[U‚ÇÅ]</code>. In this case, the tensor data is associated with sectors <code>(a1, a2, ‚Ä¶, aN‚ÇÅ) ‚àà sectors(V1 ‚äó V2 ‚äó ‚Ä¶ ‚äó VN‚ÇÅ)</code> and <code>(b1, ‚Ä¶, bN‚ÇÇ) ‚àà sectors(W1 ‚äó ‚Ä¶ ‚äó WN‚ÇÇ)</code> such that they fuse to a same common charge, i.e. <code>(c = first(‚äó(a1, ‚Ä¶, aN‚ÇÅ))) == first(‚äó(b1, ‚Ä¶, bN‚ÇÇ))</code>. The data associated with this takes the form of a multidimensional array with size <code>(dim(V1, a1), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ))</code>, or equivalently, a matrix of with row size <code>dim(V1, a1)*‚Ä¶*dim(VN‚ÇÅ, aN‚ÇÅ) == dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ))</code> and column size <code>dim(W1, b1)*‚Ä¶*dim(WN‚ÇÇ, aN‚ÇÇ) == dim(domain, (b1, ‚Ä¶, bN‚ÇÇ))</code>.</p><p>However, there are multiple combinations of <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> giving rise to the same <code>c</code>, and so there is data associated with all of these, as well as all possible combinations of <code>(b1, ‚Ä¶, bN‚ÇÇ)</code>. Stacking all matrices for different <code>(a1,‚Ä¶)</code> and a fixed value of <code>(b1,‚Ä¶)</code> underneath each other, and for fixed value of <code>(a1,‚Ä¶)</code> and different values of <code>(b1,‚Ä¶)</code> next to each other, gives rise to a larger block matrix of all data associated with the central sector <code>c</code>. The size of this matrix is exactly <code>(blockdim(codomain, c), blockdim(domain, c))</code> and these matrices are exactly the diagonal blocks whose existence is guaranteed by Schur&#39;s lemma, and which are labeled by the coupled sector <code>c</code>. Indeed, if we would represent the tensor map <code>t</code> as a matrix without explicitly using the symmetries, we could reorder the rows and columns to group data corresponding to sectors that fuse to the same <code>c</code>, and the resulting block diagonal representation would emerge. This basis transform is thus a permutation, which is a unitary operation, that will cancel or go through trivially for linear algebra operations such as composing tensor maps (matrix multiplication) or tensor factorizations such as a singular value decomposition. For such linear algebra operations, we can thus directly act on these large matrices, which correspond to the diagonal blocks that emerge after a basis transform, provided that the partition of the tensor indices in domain and codomain of the tensor are in line with our needs. For example, composing two tensor maps amounts to multiplying the matrices corresponding to the same <code>c</code> (provided that its subblocks labeled by the different combinations of sectors are ordered in the same way, which we guarantee by associating a canonical order with sectors). Henceforth, we refer to the <code>blocks</code> of a tensor map as those diagonal blocks, the existence of which is provided by Schur&#39;s lemma and which are labeled by the coupled sectors <code>c</code>. We directly store these blocks as <code>DenseMatrix</code> and gather them as values in a dictionary, together with the corresponding coupled sector <code>c</code> as key. For a given tensor <code>t</code>, we can access a specific block as <code>block(t, c)</code>, whereas <code>blocks(t)</code> yields an iterator over pairs <code>c=&gt;block(t,c)</code>.</p><p>The subblocks corresponding to a particular combination of sectors then correspond to a particular view for some range of the rows and some range of the colums, i.e. <code>view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ)</code> where the ranges <code>m‚ÇÅ:m‚ÇÇ</code> associated with <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> and <code>n‚ÇÅ:n‚ÇÇ</code> associated with <code>(b‚ÇÅ, ‚Ä¶, bN‚ÇÇ)</code> are stored within the fields of the instance <code>t</code> of type <code>TensorMap</code>. This <code>view</code> can then lazily be reshaped to a multidimensional array, for which we rely on the package <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>. Indeed, the data in this <code>view</code> is not contiguous, because the stride between the different columns is larger than the length of the columns. Nonetheless, this does not pose a problem and even as multidimensional array there is still a definite stride associated with each dimension.</p><p>When <code>FusionStyle(I) isa MultipleFusion</code>, things become slightly more complicated. Not only do <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> give rise to different coupled sectors <code>c</code>, there can be multiply ways in which they fuse to <code>c</code>. These different possibilities are enumerated by the iterator <code>fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> and <code>fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c)</code>, and with each of those, there is tensor data that takes the form of a multidimensional array, or, after reshaping, a matrix of size <code>(dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ)), dim(domain, (b1, ‚Ä¶, bN‚ÇÇ))))</code>. Again, we can stack all such matrices with the same value of <code>f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> horizontally (as they all have the same number of rows), and with the same value of <code>f‚ÇÇ ‚àà fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c)</code> vertically (as they have the same number of columns). What emerges is a large matrix of size <code>(blockdim(codomain, c), blockdim(domain, c))</code> containing all the tensor data associated with the coupled sector <code>c</code>, where <code>blockdim(P, c) = sum(dim(P, s)*length(fusiontrees(s, c)) for s in sectors(P))</code> for some instance <code>P</code> of <code>ProductSpace</code>. The tensor implementation does not distinguish between abelian or non-abelian sectors and still stores these matrices as a <code>DenseMatrix</code>, accessible via <code>block(t, c)</code>.</p><p>At first sight, it might now be less clear what the relevance of this block is in relation to the full matrix representation of the tensor map, where the symmetry is not exploited. The essential interpretation is still the same. Schur&#39;s lemma now tells that there is a unitary basis transform which makes this matrix representation block diagonal, more specifically, of the form <span>$‚®Å_{c} B_c ‚äó ùüô_{c}$</span>, where <span>$B_c$</span> denotes <code>block(t,c)</code> and <span>$ùüô_{c}$</span> is an identity matrix of size <code>(dim(c), dim(c))</code>. The reason for this extra identity is that the group representation is recoupled to act as <span>$‚®Å_{c} ùüô ‚äó u_c(g)$</span> for all <span>$g ‚àà \mathsf{I}$</span>, with <span>$u_c(g)$</span> the matrix representation of group element <span>$g$</span> according to the irrep <span>$c$</span>. In the abelian case, <code>dim(c) == 1</code>, i.e. all irreducible representations are one-dimensional and Schur&#39;s lemma only dictates that all off-diagonal blocks are zero. However, in this case the basis transform to the block diagonal representation is not simply a permutation matrix, but a more general unitary matrix composed of the different fusion trees. Indeed, let us denote the fusion trees <code>f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> as <span>$X^{a_1, ‚Ä¶, a_{N‚ÇÅ}}_{c,Œ±}$</span> where <span>$Œ± = (e_1, ‚Ä¶, e_{N_1-2}; Œº‚ÇÅ, ‚Ä¶, Œº_{N_1-1})$</span> is a collective label for the internal sectors <code>e</code> and the vertex degeneracy labels <code>Œº</code> of a generic fusion tree, as discussed in the <a href="../sectors/#ss_fusiontrees">corresponding section</a>. The tensor is then represented as</p><p><img src="../img/tensor-storage.svg" alt="tensor storage"/></p><p>In this diagram, we have indicated how the tensor map can be rewritten in terms of a block diagonal matrix with a unitary matrix on its left and another unitary matrix (if domain and codomain are different) on its right. So the left and right matrices should actually have been drawn as squares. They represent the unitary basis transform. In this picture, red and white regions are zero. The center matrix is most easy to interpret. It is the block diagonal matrix <span>$‚®Å_{c} B_c ‚äó ùüô_{c}$</span> with diagonal blocks labeled by the coupled charge <code>c</code>, in this case it takes two values. Every single small square in between the dotted or dashed lines has size <span>$d_c √ó d_c$</span> and corresponds to a single element of <span>$B_c$</span>, tensored with the identity <span>$\mathrm{id}_c$</span>. Instead of <span>$B_c$</span>, a more accurate labelling is <span>$t^c_{(a_1 ‚Ä¶ a_{N‚ÇÅ})Œ±, (b_1 ‚Ä¶ b_{N‚ÇÇ})Œ≤}$</span> where <span>$Œ±$</span> labels different fusion trees from <span>$(a_1 ‚Ä¶ a_{N‚ÇÅ})$</span> to <span>$c$</span>. The dashed horizontal lines indicate regions corresponding to different fusion (actually splitting) trees, either because of different sectors <span>$(a_1 ‚Ä¶ a_{N‚ÇÅ})$</span> or different labels <span>$Œ±$</span> within the same sector. Similarly, the dashed vertical lines define the border between regions of different fusion trees from the domain to <code>c</code>, either because of different sectors <span>$(b_1 ‚Ä¶ b_{N‚ÇÇ})$</span> or a different label <span>$Œ≤$</span>.</p><p>To understand this better, we need to understand the basis transform, e.g. on the left (codomain) side. In more detail, it is given by</p><p><img src="../img/tensor-unitary.svg" alt="tensor unitary"/></p><p>Indeed, remembering that <span>$V_i = ‚®Å_{a_i} R_{a_i} ‚äó ‚ÑÇ^{n_{a_i}}$</span> with <span>$R_{a_i}$</span> the representation space on which irrep <span>$a_i$</span> acts (with dimension <span>$\mathrm{dim}(a_i)$</span>), we find <span>$V_1 ‚äó ‚Ä¶ ‚äó V_{N_1} = ‚®Å_{a_1, ‚Ä¶, a_{N‚ÇÅ}} (R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}}) ‚äó ‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>. In the diagram above, the wiggly lines correspond to the direct sum over the different sectors <span>$(a_1, ‚Ä¶, a_{N‚ÇÅ})$</span>, there depicted taking three possible values <span>$(a‚Ä¶)$</span>, <span>$(a‚Ä¶)‚Ä≤$</span> and <span>$(a‚Ä¶)‚Ä≤‚Ä≤$</span>. The tensor product <span>$(R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}}) ‚äó ‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span> is depicted as <span>$(R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}})^{‚äï n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>, i.e. as a direct sum of the spaces <span>$R_{(a‚Ä¶)} = (R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}})$</span> according to the dotted horizontal lines, which repeat <span>$n_{(a‚Ä¶)} = n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}$</span> times. In this particular example, <span>$n_{(a‚Ä¶)}=2$</span>, <span>$n_{(a‚Ä¶)&#39;}=3$</span> and <span>$n_{(a‚Ä¶)&#39;&#39;}=5$</span>. The thick vertical line represents the separation between the two different coupled sectors, denoted as <span>$c$</span> and <span>$c&#39;$</span>. Dashed vertical lines represent different ways of reaching the coupled sector, corresponding to different <code>Œ±</code>. In this example, the first sector <span>$(a‚Ä¶)$</span> has one fusion tree to <span>$c$</span>, labeled by <span>$c,Œ±$</span>, and two fusion trees to <span>$c&#39;$</span>, labeled by <span>$c&#39;,Œ±$</span> and <span>$c&#39;,Œ±&#39;$</span>. The second sector has only a fusion tree to <span>$c$</span>, labeled by <span>$c,Œ±&#39;$</span>. The third sector only has a fusion tree to <span>$c&#39;$</span>, labeld by <span>$c&#39;, Œ±&#39;&#39;$</span>. Finally then, because the fusion trees do not act on the spaces <span>$‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>, the dotted lines which represent the different <span>$n_{(a‚Ä¶)} = n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}$</span> dimensions are also drawn vertically. In particular, for a given sector <span>$(a‚Ä¶)$</span> and a specific fusion tree <span>$X^{(a‚Ä¶)}_{c,Œ±}: R_{(a‚Ä¶)}‚ÜíR_c$</span>, the action is <span>$X^{(a‚Ä¶)}_{c,Œ±} ‚äó ùüô_{n_{(a‚Ä¶)}}$</span>, which corresponds to the diagonal green blocks in this drawing where the same matrix <span>$X^{(a‚Ä¶)}_{c,Œ±}$</span> (the fusion tree) is repeated along the diagonal. Note that the fusion tree is not a vector or single column, but a matrix with number of rows equal to <span>$\mathrm{dim}(R_{(a\ldots)}) = d_{a_1} d_{a_2} ‚Ä¶ d_{a_{N_1}}$</span> and number of columns equal to <span>$d_c$</span>. A similar interpretation can be given to the basis transform on the right, by taking its adjoint. In this particular example, it has two different combinations of sectors <span>$(b‚Ä¶)$</span> and <span>$(b‚Ä¶)&#39;$</span>, where both have a single fusion tree to <span>$c$</span> as well as to <span>$c&#39;$</span>, and <span>$n_{(b‚Ä¶)}=2$</span>, <span>$n_{(b‚Ä¶)&#39;}=3$</span>.</p><p>Note that we never explicitly store or act with the basis transforms on the left and the right. For composing tensor maps (i.e. multiplying them), these basis transforms just cancel, whereas for tensor factorizations they just go through trivially. They transform non-trivially when reshuffling the tensor indices, both within or in between the domain and codomain. For this, however, we can completely rely on the manipulations of fusion trees to implicitly compute the effect of the basis transform and construct the new blocks <span>$B_c$</span> that result with respect to the new basis.</p><p>Hence, as before, we only store the diagonal blocks <span>$B_c$</span> of size <code>(blockdim(codomain(t), c), blockdim(domain(t), c))</code> as a <code>DenseMatrix</code>, accessible via <code>block(t, c)</code>. Within this matrix, there are regions of the form <code>view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ)</code> that correspond to the data <span>$t^c_{(a_1 ‚Ä¶ a_{N‚ÇÅ})Œ±, (b_1 ‚Ä¶ b_{N‚ÇÇ})Œ≤}$</span> associated with a pair of fusion trees <span>$X^{(a_1 ‚Ä¶ a_{N‚ÇÅ})}_{c,Œ±}$</span> and <span>$X^{(b_1 ‚Ä¶ b_{N‚ÇÇ})}_{c,Œ≤}$</span>, henceforth again denoted as <code>f‚ÇÅ</code> and <code>f‚ÇÇ</code>, with <code>f‚ÇÅ.coupled == f‚ÇÇ.coupled == c</code>. The ranges where this subblock is living are managed within the tensor implementation, and these subblocks can be accessed via <code>t[f‚ÇÅ,f‚ÇÇ]</code>, and is returned as a <code>StridedArray</code> of size <span>$n_{a_1} √ó n_{a_2} √ó ‚Ä¶ √ó n_{a_{N_1}} √ó n_{b_1} √ó ‚Ä¶ n_{b_{N‚ÇÇ}}$</span>, or in code, <code>(dim(V1, a1), dim(V2, a2), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ))</code>. While the implementation does not distinguish between <code>FusionStyle isa UniqueFusion</code> or <code>FusionStyle isa MultipleFusion</code>, in the former case the fusion tree is completely characterized by the uncoupled sectors, and so the subblocks can also be accessed as <code>t[(a1, ‚Ä¶, aN‚ÇÅ, b1, ‚Ä¶, bN‚ÇÇ)]</code>. When there is no symmetry at all, i.e. <code>sectortype(t) == Trivial</code>, <code>t[]</code> returns the raw tensor data as a <code>StridedArray</code> of size <code>(dim(V1), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ))</code>, whereas <code>block(t, Trivial())</code> returns the same data as a <code>DenseMatrix</code> of size <code>(dim(V1) * ‚Ä¶ * dim(VN‚ÇÅ), dim(W1) * ‚Ä¶ * dim(WN‚ÇÇ))</code>.</p><h2 id="ss_tensor_construction"><a class="docs-heading-anchor" href="#ss_tensor_construction">Constructing tensor maps and accessing tensor data</a><a id="ss_tensor_construction-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_construction" title="Permalink"></a></h2><p>Having learned how a tensor is represented and stored, we can now discuss how to create tensors and tensor maps. From hereon, we focus purely on the interface rather than the implementation.</p><h3 id="Random-and-uninitialized-tensor-maps"><a class="docs-heading-anchor" href="#Random-and-uninitialized-tensor-maps">Random and uninitialized tensor maps</a><a id="Random-and-uninitialized-tensor-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Random-and-uninitialized-tensor-maps" title="Permalink"></a></h3><p>The most convenient set of constructors are those that construct  tensors or tensor maps with random or uninitialized data. They take the form</p><pre><code class="language-julia hljs">f(codomain, domain = one(codomain))
f(eltype::Type{&lt;:Number}, codomain, domain = one(codomain))
TensorMap(undef, codomain, domain = one(codomain))
TensorMap(undef, eltype::Type{&lt;:Number}, codomain, domain = one(codomain))
Tensor(undef, codomain)
Tensor(undef, eltype::Type{&lt;:Number}, codomain)</code></pre><p>Here, <code>f</code> is any of the typical functions from Base that normally create arrays, namely <code>zeros</code>, <code>ones</code>, <code>rand</code>, <code>randn</code> and <code>Random.randexp</code>. Remember that <code>one(codomain)</code> is the empty <code>ProductSpace{S,0}()</code>. The third and fourth calling syntax use the <code>UndefInitializer</code> from Julia Base and generates a <code>TensorMap</code> with unitialized data, which can thus contain <code>NaN</code>s.</p><p>In all of these constructors, the last two arguments can be replaced by <code>domain‚Üícodomain</code> or <code>codomain‚Üêdomain</code>, where the arrows are obtained as <code>\rightarrow+TAB</code> and <code>\leftarrow+TAB</code> and create a <code>HomSpace</code> as explained in the section on <a href="../spaces/#ss_homspaces">Spaces of morphisms</a>. Some examples are perhaps in order</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = randn(‚ÑÇ^2 ‚äó ‚ÑÇ^3, ‚ÑÇ^2)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ‚ÑÇ^2):
[:, :, 1] =
 -0.23312659320907267  -1.198039012411446    1.4790410106028942
  1.9585376924842102   -1.2309946991068061  -0.4449353098375463

[:, :, 2] =
 -0.46993847371741554  0.5029236893773528  -1.1205589736071757
  0.3474404755694104   1.226505979617927   -0.1051846682446385</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = zeros(Float32, ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üê ‚ÑÇ^2)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ‚ÑÇ^2):
[:, :, 1] =
 0.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  0.0f0

[:, :, 2] =
 0.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  0.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 = TensorMap(undef, ‚ÑÇ^2 ‚Üí ‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching TensorMap(::UndefInitializer, ::TensorMapSpace{ComplexSpace, 2, 1})
The type `TensorMap` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  TensorMap(<span class="sgr91">::typeof(randn)</span>, ::HomSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  TensorMap(<span class="sgr91">::typeof(randnormal)</span>, ::HomSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  TensorMap(<span class="sgr91">::typeof(rand)</span>, ::HomSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t1) == domain(t2) == domain(t3)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `t3` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(t1) == codomain(t2) == codomain(t3)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `t3` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; disp(x) = show(IOContext(Core.stdout, :compact=&gt;false), &quot;text/plain&quot;, trunc.(x; digits = 3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1[] |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">2√ó3√ó2 StridedViews.StridedView{Float64, 3, Array{Float64, 3}, typeof(identity)}:
[:, :, 1] =
 -0.233  -1.198   1.479
  1.958  -1.23   -0.444

[:, :, 2] =
 -0.469  0.502  -1.12
  0.347  1.226  -0.105</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t1, Trivial()) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">6√ó2 Array{Float64, 2}:
 -0.233  -0.469
  1.958   0.347
 -1.198   0.502
 -1.23    1.226
  1.479  -1.12
 -0.444  -0.105</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reshape(t1[], dim(codomain(t1)), dim(domain(t1))) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">6√ó2 Array{Float64, 2}:
 -0.233  -0.469
  1.958   0.347
 -1.198   0.502
 -1.23    1.226
  1.479  -1.12
 -0.444  -0.105</code></pre><p>Finally, all constructors can also be replaced by <code>Tensor(..., codomain)</code>, in which case the domain is assumed to be the empty <code>ProductSpace{S,0}()</code>, which can easily be obtained as <code>one(codomain)</code>. Indeed, the empty product space is the unit object of the monoidal category, equivalent to the field of scalars <code>ùïú</code>, and thus the multiplicative identity (especially since <code>*</code> also acts as tensor product on vector spaces).</p><p>The matrices created by <code>f</code> are the matrices <span>$B_c$</span> discussed above, i.e. those returned by <code>block(t, c)</code>. Only numerical matrices of type <code>DenseMatrix</code> are accepted, which in practice just means Julia&#39;s intrinsic <code>Matrix{T}</code> for some <code>T&lt;:Number</code>. In the future, we will add support for <code>CuMatrix</code> from <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArrays.jl</a> to harness GPU computing power, and maybe <code>SharedArray</code> from the Julia&#39;s <code>SharedArrays</code> standard library.</p><p>Support for static or sparse data is currently unavailable, and if it would be implemented, it would lead to new subtypes of <code>AbstractTensorMap</code> which are distinct from <code>TensorMap</code>. Future implementations of e.g. <code>SparseTensorMap</code> or <code>StaticTensorMap</code> could be useful. Furthermore, there could be specific implementations for tensors whose blocks are <code>Diagonal</code>.</p><h3 id="Tensor-maps-from-existing-data"><a class="docs-heading-anchor" href="#Tensor-maps-from-existing-data">Tensor maps from existing data</a><a id="Tensor-maps-from-existing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-maps-from-existing-data" title="Permalink"></a></h3><p>To create a <code>TensorMap</code> with existing data, one can use the aforementioned form but with the function <code>f</code> replaced with the actual data, i.e. <code>TensorMap(data, codomain, domain)</code> or any of its equivalents.</p><p>Here, <code>data</code> can be of two types. It can be a dictionary (any <code>Associative</code> subtype) which has blocksectors <code>c</code> of type <code>sectortype(codomain)</code> as keys, and the corresponding matrix blocks as value, i.e. <code>data[c]</code> is some <code>DenseMatrix</code> of size <code>(blockdim(codomain, c), blockdim(domain, c))</code>. This is the form of how the data is stored within the <code>TensorMap</code> objects.</p><p>For those space types for which a <code>TensorMap</code> can be converted to a plain multidimensional array, the <code>data</code> can also be a general <code>DenseArray</code>, either of rank <code>N‚ÇÅ+N‚ÇÇ</code> and with matching size <code>(dims(codomain)..., dims(domain)...)</code>, or just as a <code>DenseMatrix</code> with size <code>(dim(codomain), dim(domain))</code>. This is true in particular if the sector type is <code>Trivial</code>, e.g. for <code>CartesianSpace</code> or <code>ComplexSpace</code>. Then the <code>data</code> array is just reshaped into matrix form and referred to as such in the resulting <code>TensorMap</code> instance. When <code>spacetype</code> is <code>GradedSpace</code>, the <code>TensorMap</code> constructor will try to reconstruct the tensor data such that the resulting tensor <code>t</code> satisfies <code>data == convert(Array, t)</code>. This might not be possible, if the data does not respect the symmetry structure. This procedure can be sketched using a simple physical example, namely the SWAP gate on two qubits,</p><p class="math-container">\[\begin{align*}
\mathrm{SWAP}: \mathbb{C}^2 \otimes \mathbb{C}^2 &amp; \to \mathbb{C}^2 \otimes \mathbb{C}^2\\
|i\rangle \otimes |j\rangle &amp;\mapsto |j\rangle \otimes |i\rangle.
\end{align*}\]</p><p>This operator can be rewritten in terms of the familiar Heisenberg exchange interaction <span>$\vec{S}_i \cdot \vec{S}_j$</span> as</p><p class="math-container">\[\mathrm{SWAP} = 2 \vec{S}_i \cdot \vec{S}_j + \frac{1}{2} ùüô,\]</p><p>where <span>$\vec{S} = (S^x, S^y, S^z)$</span> and the spin-1/2 generators of SU‚ÇÇ <span>$S^k$</span> are defined defined in terms of the <span>$2 \times 2$</span> Pauli matrices <span>$\sigma^k$</span> as <span>$S^k = \frac{1}{2}\sigma^k$</span>. The SWAP gate can be realized as a rank-4 <code>TensorMap</code> in the following way:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # encode the matrix elements of the swap gate into a rank-4 array, where the first two
       # indices correspond to the codomain and the last two indices correspond to the domain
       data = zeros(2,2,2,2)
       # the swap gate then maps the last two indices on the first two in reversed order</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2√ó2√ó2 Array{Float64, 4}:
[:, :, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2] =
 0.0  0.0
 0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data[1,1,1,1] = data[2,2,2,2] = data[1,2,2,1] = data[2,1,1,2] = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ^2 # generic qubit hilbert space</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = TensorMap(data, V1 ‚äó V1, V1 ‚äó V1)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^2) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^2)):
[:, :, 1, 1] =
 1.0  0.0
 0.0  0.0

[:, :, 2, 1] =
 0.0  1.0
 0.0  0.0

[:, :, 1, 2] =
 0.0  0.0
 1.0  0.0

[:, :, 2, 2] =
 0.0  0.0
 0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU2Space(1/2=&gt;1) # hilbert space of an actual spin-1/2 particle, respecting symmetry</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](1/2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = TensorMap(data, V2 ‚äó V2, V2 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[SU‚ÇÇ](1/2=&gt;1) ‚äó Rep[SU‚ÇÇ](1/2=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](1/2=&gt;1) ‚äó Rep[SU‚ÇÇ](1/2=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 0, (false, false), ()):
[:, :, 1, 1] =
 -1.0000000000000002
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 1, (false, false), ()):
[:, :, 1, 1] =
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V3 = U1Space(1/2=&gt;1,-1/2=&gt;1) # restricted space that only uses the `œÉ_z` rotation symmetry</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](1/2=&gt;1, -1/2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 = TensorMap(data, V3 ‚äó V3, V3 ‚äó V3)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[U‚ÇÅ](1/2=&gt;1, -1/2=&gt;1) ‚äó Rep[U‚ÇÅ](1/2=&gt;1, -1/2=&gt;1)) ‚Üê (Rep[U‚ÇÅ](1/2=&gt;1, -1/2=&gt;1) ‚äó Rep[U‚ÇÅ](1/2=&gt;1, -1/2=&gt;1))):
* Data for sector (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](1/2)) ‚Üê (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](1/2)):
[:, :, 1, 1] =
 0.0
* Data for sector (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](-1/2)) ‚Üê (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](1/2)):
[:, :, 1, 1] =
 1.0
* Data for sector (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](1/2)) ‚Üê (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](-1/2)):
[:, :, 1, 1] =
 1.0
* Data for sector (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](-1/2)) ‚Üê (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](-1/2)):
[:, :, 1, 1] =
 0.0
* Data for sector (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](1/2)) ‚Üê (Irrep[U‚ÇÅ](1/2), Irrep[U‚ÇÅ](1/2)):
[:, :, 1, 1] =
 1.0
* Data for sector (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](-1/2)) ‚Üê (Irrep[U‚ÇÅ](-1/2), Irrep[U‚ÇÅ](-1/2)):
[:, :, 1, 1] =
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (c,b) in blocks(t3)
           println(&quot;Data for block $c :&quot;)
           disp(b)
           println()
       end</code><code class="nohighlight hljs ansi" style="display:block;">Data for block Irrep[U‚ÇÅ](0) :
2√ó2 Array{Float64, 2}:
 0.0  1.0
 1.0  0.0
Data for block Irrep[U‚ÇÅ](1) :
1√ó1 Array{Float64, 2}:
 1.0
Data for block Irrep[U‚ÇÅ](-1) :
1√ó1 Array{Float64, 2}:
 1.0</code></pre><p>Hence, we recognize that the exchange interaction has eigenvalue <span>$-1$</span> in the coupled spin zero sector (<code>SU2Irrep(0)</code>), and eigenvalue <span>$+1$</span> in the coupled spin 1 sector (<code>SU2Irrep(1)</code>). Using <code>Irrep[U‚ÇÅ]</code> instead, we observe that both coupled charge <code>U1Irrep(+1)</code> and <code>U1Irrep(-1)</code> have eigenvalue <span>$+1$</span>. The coupled charge <code>U1Irrep(0)</code> sector is two-dimensional, and has an eigenvalue <span>$+1$</span> and an eigenvalue <span>$-1$</span>.</p><p>To construct the proper <code>data</code> in more complicated cases, one has to know where to find each sector in the range <code>1:dim(V)</code> of every index <code>i</code> with associated space <code>V</code>, as well as the internal structure of the representation space when the corresponding sector <code>c</code> has <code>dim(c)&gt;1</code>, i.e. in the case of <code>FusionStyle(c) isa MultipleFusion</code>. Currently, the only non- abelian sectors are <code>Irrep[SU‚ÇÇ]</code> and <code>Irrep[CU‚ÇÅ]</code>, for which the internal structure is the natural one.</p><p>There are some tools available to facilitate finding the proper range of sector <code>c</code> in space <code>V</code>, namely <code>axes(V, c)</code>. This also works on a <code>ProductSpace</code>, with a tuple of sectors. An example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = SU2Space(0=&gt;3, 1=&gt;2, 2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;3, 1=&gt;2, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = V ‚äó V ‚äó V</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;3, 1=&gt;2, 2=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;3, 1=&gt;2, 2=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;3, 1=&gt;2, 2=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; axes(P, (SU2Irrep(1), SU2Irrep(0), SU2Irrep(2)))</code><code class="nohighlight hljs ansi" style="display:block;">(4:9, 1:3, 10:14)</code></pre><p>Note that the length of the range is the degeneracy dimension of that sector, times the dimension of the internal representation space, i.e. the quantum dimension of that sector.</p><h3 id="Assigning-block-data-after-initialization"><a class="docs-heading-anchor" href="#Assigning-block-data-after-initialization">Assigning block data after initialization</a><a id="Assigning-block-data-after-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Assigning-block-data-after-initialization" title="Permalink"></a></h3><p>In order to avoid having to know the internal structure of each representation space to properly construct the full <code>data</code> array, it is often simpler to assign the block data directly after initializing an all zero <code>TensorMap</code> with the correct spaces. While this may seem more difficult at first sight since it requires knowing the exact entries associated to each valid combination of domain uncoupled sectors, coupled sector and codomain uncoupled sectors, this is often a far more natural procedure in practice.</p><p>A first option is to directly set the full matrix block for each coupled sector in the <code>TensorMap</code>. For the example with U‚ÇÅ symmetry, this can be done as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 = zeros(V3 ‚äó V3, V3 ‚äó V3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t4, U1Irrep(0)) .= [1 0; 0 1];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t4, U1Irrep(1)) .= [1;;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t4, U1Irrep(-1)) .= [1;;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (c, b) in blocks(t4)
           println(&quot;Data for block $c :&quot;)
           disp(b)
           println()
       end</code><code class="nohighlight hljs ansi" style="display:block;">Data for block Irrep[U‚ÇÅ](0) :
2√ó2 Array{Float64, 2}:
 1.0  0.0
 0.0  1.0
Data for block Irrep[U‚ÇÅ](1) :
1√ó1 Array{Float64, 2}:
 1.0
Data for block Irrep[U‚ÇÅ](-1) :
1√ó1 Array{Float64, 2}:
 1.0</code></pre><p>While this indeed does not require considering the internal structure of the representation spaces, it still requires knowing the precise row and column indices corresponding to each set of uncoupled sectors in the codmain and domain respectively to correctly assign the nonzero entries in each block.</p><p>Perhaps the most natural way of constructing a particular <code>TensorMap</code> is to directly assign the data slices for each splitting - fusion tree pair using the <code>fusiontrees(::TensorMap)</code> method. This returns an iterator over all tuples <code>(f‚ÇÅ, f‚ÇÇ)</code> of splitting - fusion tree pairs corresponding to all ways in which the set of domain uncoupled sectors can fuse to a coupled sector and split back into the set of codomain uncoupled sectors. By directly setting the corresponding data slice <code>t[f‚ÇÅ, f‚ÇÇ]</code> of size <code>(dims(codomain(t), f‚ÇÅ.uncoupled)..., dims(domain(t), f‚ÇÇ.uncoupled)...)</code>, we can construct all the block data without worrying about the internal ordering of row and column indices in each block. In addition, the corresponding value of each fusion tree slice is often directly informed by the object we are trying to construct in the first place. For example, in order to construct the Heisenberg exchange interaction on two spin-1/2 particles <span>$i$</span> and <span>$j$</span> as an SU‚ÇÇ symmetric <code>TensorMap</code>, we can make use of the observation that</p><p class="math-container">\[\vec{S}_i \cdot \vec{S}_j = \frac{1}{2} \left( \left( \vec{S}_i \cdot \vec{S}_j \right)^2 - \vec{S}_i^2 - \vec{S}_j^2 \right).\]</p><p>Recalling some basic group theory, we know that the <a href="https://en.wikipedia.org/wiki/Representation_theory_of_SU(2)#The_Casimir_element">quadratic Casimir of SU‚ÇÇ</a>, <span>$\vec{S}^2$</span>, has a well-defined eigenvalue <span>$j(j+1)$</span> on every irrep of spin <span>$j$</span>. From the above expressions, we can therefore directly read off the eigenvalues of the SWAP gate in terms of this Casimir eigenvalue on the domain uncoupled sectors and the coupled sector. This gives us exactly the prescription we need to assign the data slice corresponding to each splitting - fusion tree pair:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; C(s::SU2Irrep) = s.j * (s.j + 1)</code><code class="nohighlight hljs ansi" style="display:block;">C (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t5 = zeros(V2 ‚äó V2, V2 ‚äó V2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (f‚ÇÅ, f‚ÇÇ) in fusiontrees(t5)
           t5[f‚ÇÅ, f‚ÇÇ] .= C(f‚ÇÇ.coupled) - C(f‚ÇÇ.uncoupled[1]) - C(f‚ÇÇ.uncoupled[2]) + 1/2
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (c, b) in blocks(t5)
           println(&quot;Data for block $c :&quot;)
           disp(b)
           println()
       end</code><code class="nohighlight hljs ansi" style="display:block;">Data for block Irrep[SU‚ÇÇ](0) :
1√ó1 Array{Float64, 2}:
 -1.0
Data for block Irrep[SU‚ÇÇ](1) :
1√ó1 Array{Float64, 2}:
 1.0</code></pre><h3 id="Constructing-similar-tensors"><a class="docs-heading-anchor" href="#Constructing-similar-tensors">Constructing similar tensors</a><a id="Constructing-similar-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-similar-tensors" title="Permalink"></a></h3><p>A third way to construct a <code>TensorMap</code> instance is to use <code>Base.similar</code>, i.e.</p><pre><code class="language-julia hljs">similar(t [, T::Type{&lt;:Number}, codomain, domain])</code></pre><p>where <code>T</code> is a possibly different <code>eltype</code> for the tensor data, and <code>codomain</code> and <code>domain</code> optionally define a new codomain and domain for the resulting tensor. By default, these values just take the value from the input tensor <code>t</code>. The result will be a new <code>TensorMap</code> instance, with <code>undef</code> data, but whose data is stored in the same subtype of <code>DenseMatrix</code> (e.g. <code>Matrix</code> or <code>CuMatrix</code> or ...) as <code>t</code>. In particular, this uses the methods <code>storagetype(t)</code> and <code>TensorKit.similarstoragetype(t, T)</code>.</p><h3 id="Special-purpose-constructors"><a class="docs-heading-anchor" href="#Special-purpose-constructors">Special purpose constructors</a><a id="Special-purpose-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Special-purpose-constructors" title="Permalink"></a></h3><p>Finally, there are methods <code>zero</code>, <code>one</code>, <code>id</code>, <code>isomorphism</code>, <code>unitary</code> and <code>isometry</code> to create specific new tensors. Tensor maps behave as vectors and can be added (if they have the same domain and codomain); <code>zero(t)</code> is the additive identity, i.e. a <code>TensorMap</code> instance where all entries are zero. For a <code>t::TensorMap</code> with <code>domain(t) == codomain(t)</code>, i.e. an endomorphism, <code>one(t)</code> creates the identity tensor, i.e. the identity under composition. As discussed in the section on <a href="#ss_tensor_linalg">linear algebra operations</a>, we denote composition of tensor maps with the mutliplication operator <code>*</code>, such that <code>one(t)</code> is the multiplicative identity. Similarly, it can be created as <code>id(V)</code> with <code>V</code> the relevant vector space, e.g. <code>one(t) == id(domain(t))</code>. The identity tensor is currently represented with dense data, and one can use <code>id(A::Type{&lt;:DenseMatrix}, V)</code> to specify the type of <code>DenseMatrix</code> (and its <code>eltype</code>), e.g. <code>A = Matrix{Float64}</code>. Finally, it often occurs that we want to construct a specific isomorphism between two spaces that are isomorphic but not equal, and for which there is no canonical choice. Hereto, one can use the method <code>u = isomorphism([A::Type{&lt;:DenseMatrix}, ] codomain, domain)</code>, which will explicitly check that the domain and codomain are isomorphic, and return an error otherwise. Again, an optional first argument can be given to specify the specific type of <code>DenseMatrix</code> that is currently used to store the rather trivial data of this tensor. If <code>InnerProductStyle(u) &lt;: EuclideanProduct</code>, the same result can be obtained with the method <code>u = unitary([A::Type{&lt;:DenseMatrix}, ] codomain, domain)</code>. Note that reversing the domain and codomain yields the inverse morphism, which in the case of <code>EuclideanProduct</code> coincides with the adjoint morphism, i.e. <code>isomorphism(A, domain, codomain) == adjoint(u) == inv(u)</code>, where <code>inv</code> and <code>adjoint</code> will be further discussed <a href="#ss_tensor_linalg">below</a>. Finally, if two spaces <code>V1</code> and <code>V2</code> are such that <code>V2</code> can be embedded in <code>V1</code>, i.e. there exists an inclusion with a left inverse, and furthermore they represent tensor products of some <code>ElementarySpace</code> with <code>EuclideanProduct</code>, the function <code>w = isometry([A::Type{&lt;:DenseMatrix}, ], V1, V2)</code> creates one specific isometric embedding, such that <code>adjoint(w) * w == id(V2)</code> and <code>w * adjoint(w)</code> is some hermitian idempotent (a.k.a. orthogonal projector) acting on <code>V1</code>. An error will be thrown if such a map cannot be constructed for the given domain and codomain.</p><p>Let&#39;s conclude this section with some examples with <code>GradedSpace</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚Ñ§‚ÇÇSpace(0=&gt;3,1=&gt;2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = ‚Ñ§‚ÇÇSpace(0=&gt;2,1=&gt;1)
       # First a `TensorMap{‚Ñ§‚ÇÇSpace, 1, 1}`</code><code class="nohighlight hljs ansi" style="display:block;">Rep[‚Ñ§‚ÇÇ](0=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = randn(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚Üê Rep[‚Ñ§‚ÇÇ](0=&gt;2, 1=&gt;1)):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0),) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0),):
 -0.4492534695932364  -0.3566975175740316
  0.5015340306214946  -0.7186334352978022
  0.6943942191249728  -0.5858095470858309
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1),) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1),):
  0.18090637373075916
 -2.2238968775833925</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, m) |&gt; disp
       # compare with:</code><code class="nohighlight hljs ansi" style="display:block;">5√ó3 Array{Float64, 2}:
 -0.449  -0.356   0.0
  0.501  -0.718   0.0
  0.694  -0.585   0.0
  0.0     0.0     0.18
  0.0     0.0    -2.223</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(m, Irrep[‚Ñ§‚ÇÇ](0)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Array{Float64, 2}:
 -0.449  -0.356
  0.501  -0.718
  0.694  -0.585</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(m, Irrep[‚Ñ§‚ÇÇ](1)) |&gt; disp
       # Now a `TensorMap{‚Ñ§‚ÇÇSpace, 2, 2}`</code><code class="nohighlight hljs ansi" style="display:block;">2√ó1 Array{Float64, 2}:
  0.18
 -2.223</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = randn(V1 ‚äó V1, V2 ‚äó V2&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)) ‚Üê (Rep[‚Ñ§‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;2, 1=&gt;1)&#39;)):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
  0.39795865748087655  0.49147782082693986  -0.17604589380015018
 -1.750846740036233    0.375761185518522     3.4937808457354294
 -1.7453974798721699   0.6863547830235054    0.24511803381133454

[:, :, 2, 1] =
 -0.46667193675973123  0.033074828533837544  -0.06879305246367379
  0.20375094242138034  0.6594089653766374    -1.193640625842037
  0.8708793989557616   1.3228795631908241    -0.03442402749336696

[:, :, 1, 2] =
  0.3395609371693471    -0.02429458390599965  -0.257175675495163
  0.004110534945361013   1.2244947242024822   -0.8882769930949109
 -0.2526618433476534    -1.3126212354121993   -0.8128775087333775

[:, :, 2, 2] =
 -1.6154974492241385    0.7132844910744373  -0.08419111603576235
 -0.5320896293116746   -0.6760270083240227   0.9162598607331892
 -0.15311872190429313  -1.2140580326678867  -0.5579052338799733
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
 -0.17615588569936436  -0.7505243777311931
 -0.9585543722751554   -0.45462977453682596

[:, :, 2, 1] =
  1.3975893100799421  -0.621320784203746
 -0.1557430611081074   1.2710164369065127

[:, :, 1, 2] =
 0.46391684635203695  -0.4830532239640747
 0.8545860788545722   -0.4445342308313436

[:, :, 2, 2] =
 -1.0601209579760147   -0.08901304430778624
  0.27931646003590754   0.4207891733094343
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
  0.16740585440011088   1.1905698872410626  -0.2064378010967403
 -0.9351440932110024   -2.2988685442547228  -1.1433250947599203
  0.5384109267845039   -0.4406191164015694  -1.1175714395179155
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
 0.3364553653498064   0.698683742279107
 0.27173897464826197  1.562657390322753
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
 -0.8299091361001026   0.6421282202492329  -0.3622239544624308
  1.219377319748407   -0.9389726362758026   2.2524508121486253

[:, :, 1, 2] =
 -0.9294289678234549  0.47658007390391643  -0.3502747651527508
  1.1170108889855763  0.28318602951534255   0.4483012999875787
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
  1.2657756070079054     0.9821694649738418
  1.6883682171740284     0.6182506154345186
 -0.043978088780431086  -1.1129165279282822

[:, :, 1, 2] =
 -0.05098955151351023   0.21760194614664266
 -0.5535770841762061    1.2434711385516808
  0.2822147635545271   -0.8884475904688922
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
 0.8211396277741745   -1.440816855540865    -0.12152759724731799
 0.46604123247019025   0.38859705832402347  -1.2148144693419576

[:, :, 2, 1] =
 -0.11236071452574214  -0.3094165896506022  -0.8660950341883799
 -1.6036248925097356    0.2185899772627614   0.7846459814970966
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
 -0.2626368825143883   -0.42577231074367416
 -0.7998817220226699   -1.19712530185748
  0.05933669210628672  -0.22516961690653542

[:, :, 2, 1] =
  0.7551138949826495   -0.3725079915987416
  0.09682429883030251  -0.3203730387124291
 -0.3613553071719859    0.05734998362763561</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (array = convert(Array, t)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5√ó3√ó3 Array{Float64, 4}:
[:, :, 1, 1] =
  0.397  0.491  -0.176   0.0     0.0
 -1.75   0.375   3.493   0.0     0.0
 -1.745  0.686   0.245   0.0     0.0
  0.0    0.0     0.0    -0.176  -0.75
  0.0    0.0     0.0    -0.958  -0.454

[:, :, 2, 1] =
 -0.466  0.033  -0.068   0.0     0.0
  0.203  0.659  -1.193   0.0     0.0
  0.87   1.322  -0.034   0.0     0.0
  0.0    0.0     0.0     1.397  -0.621
  0.0    0.0     0.0    -0.155   1.271

[:, :, 3, 1] =
  0.0     0.0     0.0     1.265   0.982
  0.0     0.0     0.0     1.688   0.618
  0.0     0.0     0.0    -0.043  -1.112
 -0.829   0.642  -0.362   0.0     0.0
  1.219  -0.938   2.252   0.0     0.0

[:, :, 1, 2] =
  0.339  -0.024  -0.257  0.0     0.0
  0.004   1.224  -0.888  0.0     0.0
 -0.252  -1.312  -0.812  0.0     0.0
  0.0     0.0     0.0    0.463  -0.483
  0.0     0.0     0.0    0.854  -0.444

[:, :, 2, 2] =
 -1.615   0.713  -0.084   0.0     0.0
 -0.532  -0.676   0.916   0.0     0.0
 -0.153  -1.214  -0.557   0.0     0.0
  0.0     0.0     0.0    -1.06   -0.089
  0.0     0.0     0.0     0.279   0.42

[:, :, 3, 2] =
  0.0    0.0     0.0    -0.05    0.217
  0.0    0.0     0.0    -0.553   1.243
  0.0    0.0     0.0     0.282  -0.888
 -0.929  0.476  -0.35    0.0     0.0
  1.117  0.283   0.448   0.0     0.0

[:, :, 1, 3] =
 0.0     0.0     0.0    -0.262  -0.425
 0.0     0.0     0.0    -0.799  -1.197
 0.0     0.0     0.0     0.059  -0.225
 0.821  -1.44   -0.121   0.0     0.0
 0.466   0.388  -1.214   0.0     0.0

[:, :, 2, 3] =
  0.0     0.0     0.0     0.755  -0.372
  0.0     0.0     0.0     0.096  -0.32
  0.0     0.0     0.0    -0.361   0.057
 -0.112  -0.309  -0.866   0.0     0.0
 -1.603   0.218   0.784   0.0     0.0

[:, :, 3, 3] =
  0.167   1.19   -0.206  0.0    0.0
 -0.935  -2.298  -1.143  0.0    0.0
  0.538  -0.44   -1.117  0.0    0.0
  0.0     0.0     0.0    0.336  0.698
  0.0     0.0     0.0    0.271  1.562</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 = dim(codomain(t))</code><code class="nohighlight hljs ansi" style="display:block;">25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d2 = dim(domain(t))</code><code class="nohighlight hljs ansi" style="display:block;">9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (matrix = reshape(array, d1, d2)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">25√ó9 Array{Float64, 2}:
  0.397  -0.466   0.0     0.339  -1.615   0.0     0.0     0.0     0.167
 -1.75    0.203   0.0     0.004  -0.532   0.0     0.0     0.0    -0.935
 -1.745   0.87    0.0    -0.252  -0.153   0.0     0.0     0.0     0.538
  0.0     0.0    -0.829   0.0     0.0    -0.929   0.821  -0.112   0.0
  0.0     0.0     1.219   0.0     0.0     1.117   0.466  -1.603   0.0
  0.491   0.033   0.0    -0.024   0.713   0.0     0.0     0.0     1.19
  0.375   0.659   0.0     1.224  -0.676   0.0     0.0     0.0    -2.298
  0.686   1.322   0.0    -1.312  -1.214   0.0     0.0     0.0    -0.44
  0.0     0.0     0.642   0.0     0.0     0.476  -1.44   -0.309   0.0
  0.0     0.0    -0.938   0.0     0.0     0.283   0.388   0.218   0.0
 -0.176  -0.068   0.0    -0.257  -0.084   0.0     0.0     0.0    -0.206
  3.493  -1.193   0.0    -0.888   0.916   0.0     0.0     0.0    -1.143
  0.245  -0.034   0.0    -0.812  -0.557   0.0     0.0     0.0    -1.117
  0.0     0.0    -0.362   0.0     0.0    -0.35   -0.121  -0.866   0.0
  0.0     0.0     2.252   0.0     0.0     0.448  -1.214   0.784   0.0
  0.0     0.0     1.265   0.0     0.0    -0.05   -0.262   0.755   0.0
  0.0     0.0     1.688   0.0     0.0    -0.553  -0.799   0.096   0.0
  0.0     0.0    -0.043   0.0     0.0     0.282   0.059  -0.361   0.0
 -0.176   1.397   0.0     0.463  -1.06    0.0     0.0     0.0     0.336
 -0.958  -0.155   0.0     0.854   0.279   0.0     0.0     0.0     0.271
  0.0     0.0     0.982   0.0     0.0     0.217  -0.425  -0.372   0.0
  0.0     0.0     0.618   0.0     0.0     1.243  -1.197  -0.32    0.0
  0.0     0.0    -1.112   0.0     0.0    -0.888  -0.225   0.057   0.0
 -0.75   -0.621   0.0    -0.483  -0.089   0.0     0.0     0.0     0.698
 -0.454   1.271   0.0    -0.444   0.42    0.0     0.0     0.0     1.562</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">25√ó25 Array{Float64, 2}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">9√ó9 Array{Float64, 2}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u&#39;*u ‚âà I ‚âà v&#39;*v</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (u&#39;*matrix*v) |&gt; disp
       # compare with:</code><code class="nohighlight hljs ansi" style="display:block;">25√ó9 Array{Float64, 2}:
  0.397  -0.466   0.339  -1.615   0.167   0.0     0.0     0.0     0.0
 -1.75    0.203   0.004  -0.532  -0.935   0.0     0.0     0.0     0.0
 -1.745   0.87   -0.252  -0.153   0.538   0.0     0.0     0.0     0.0
  0.491   0.033  -0.024   0.713   1.19    0.0     0.0     0.0     0.0
  0.375   0.659   1.224  -0.676  -2.298   0.0     0.0     0.0     0.0
  0.686   1.322  -1.312  -1.214  -0.44    0.0     0.0     0.0     0.0
 -0.176  -0.068  -0.257  -0.084  -0.206   0.0     0.0     0.0     0.0
  3.493  -1.193  -0.888   0.916  -1.143   0.0     0.0     0.0     0.0
  0.245  -0.034  -0.812  -0.557  -1.117   0.0     0.0     0.0     0.0
 -0.176   1.397   0.463  -1.06    0.336   0.0     0.0     0.0     0.0
 -0.958  -0.155   0.854   0.279   0.271   0.0     0.0     0.0     0.0
 -0.75   -0.621  -0.483  -0.089   0.698   0.0     0.0     0.0     0.0
 -0.454   1.271  -0.444   0.42    1.562   0.0     0.0     0.0     0.0
  0.0     0.0     0.0     0.0     0.0    -0.829  -0.929   0.821  -0.112
  0.0     0.0     0.0     0.0     0.0     1.219   1.117   0.466  -1.603
  0.0     0.0     0.0     0.0     0.0     0.642   0.476  -1.44   -0.309
  0.0     0.0     0.0     0.0     0.0    -0.938   0.283   0.388   0.218
  0.0     0.0     0.0     0.0     0.0    -0.362  -0.35   -0.121  -0.866
  0.0     0.0     0.0     0.0     0.0     2.252   0.448  -1.214   0.784
  0.0     0.0     0.0     0.0     0.0     1.265  -0.05   -0.262   0.755
  0.0     0.0     0.0     0.0     0.0     1.688  -0.553  -0.799   0.096
  0.0     0.0     0.0     0.0     0.0    -0.043   0.282   0.059  -0.361
  0.0     0.0     0.0     0.0     0.0     0.982   0.217  -0.425  -0.372
  0.0     0.0     0.0     0.0     0.0     0.618   1.243  -1.197  -0.32
  0.0     0.0     0.0     0.0     0.0    -1.112  -0.888  -0.225   0.057</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, Z2Irrep(0)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">13√ó5 Array{Float64, 2}:
  0.397  -0.466   0.339  -1.615   0.167
 -1.75    0.203   0.004  -0.532  -0.935
 -1.745   0.87   -0.252  -0.153   0.538
  0.491   0.033  -0.024   0.713   1.19
  0.375   0.659   1.224  -0.676  -2.298
  0.686   1.322  -1.312  -1.214  -0.44
 -0.176  -0.068  -0.257  -0.084  -0.206
  3.493  -1.193  -0.888   0.916  -1.143
  0.245  -0.034  -0.812  -0.557  -1.117
 -0.176   1.397   0.463  -1.06    0.336
 -0.958  -0.155   0.854   0.279   0.271
 -0.75   -0.621  -0.483  -0.089   0.698
 -0.454   1.271  -0.444   0.42    1.562</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, Z2Irrep(1)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">12√ó4 Array{Float64, 2}:
 -0.829  -0.929   0.821  -0.112
  1.219   1.117   0.466  -1.603
  0.642   0.476  -1.44   -0.309
 -0.938   0.283   0.388   0.218
 -0.362  -0.35   -0.121  -0.866
  2.252   0.448  -1.214   0.784
  1.265  -0.05   -0.262   0.755
  1.688  -0.553  -0.799   0.096
 -0.043   0.282   0.059  -0.361
  0.982   0.217  -0.425  -0.372
  0.618   1.243  -1.197  -0.32
 -1.112  -0.888  -0.225   0.057</code></pre><p>Here, we illustrated some additional concepts. Firstly, note that we convert a <code>TensorMap</code> to an <code>Array</code>. This only works when <code>sectortype(t)</code> supports <code>fusiontensor</code>, and in particular when <code>BraidingStyle(sectortype(t)) == Bosonic()</code>, e.g. the case of trivial tensors (the category <span>$\mathbf{Vect}$</span>) and group representations (the category <span>$\mathbf{Rep}_{\mathsf{G}}$</span>, which can be interpreted as a subcategory of <span>$\mathbf{Vect}$</span>). Here, we are in this case with <span>$\mathsf{G} = ‚Ñ§‚ÇÇ$</span>. For a <code>TensorMap{S,1,1}</code>, the blocks directly correspond to the diagonal blocks in the block diagonal structure of its representation as an <code>Array</code>, there is no basis transform in between. This is no longer the case for <code>TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code> with different values of <code>N‚ÇÅ</code> and <code>N‚ÇÇ</code>. Here, we use the operation <code>fuse(V)</code>, which creates an <code>ElementarySpace</code> which is isomorphic to a given space <code>V</code> (of type <code>ProductSpace</code> or <code>ElementarySpace</code>). The specific map between those two spaces constructed using the specific method <code>unitary</code> implements precisely the basis change from the product basis to the coupled basis. In this case, for a group <code>G</code> with <code>FusionStyle(Irrep[G]) isa UniqueFusion</code>, it is a permutation matrix. Specifically choosing <code>V</code> equal to the codomain and domain of <code>t</code>, we can construct the explicit basis transforms that bring <code>t</code> into block diagonal form.</p><p>Let&#39;s repeat the same exercise for <code>I = Irrep[SU‚ÇÇ]</code>, which has <code>FusionStyle(I) isa MultipleFusion</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = SU‚ÇÇSpace(0=&gt;2,1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU‚ÇÇSpace(0=&gt;1,1=&gt;1)
       # First a `TensorMap{SU‚ÇÇSpace, 1, 1}`</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = randn(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚Üê Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
 -1.2487784467316776
 -0.8376103170012155
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
 -0.793889625685231</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, m) |&gt; disp
       # compare with:</code><code class="nohighlight hljs ansi" style="display:block;">5√ó4 Array{Float64, 2}:
 -1.248   0.0     0.0     0.0
 -0.837   0.0     0.0     0.0
  0.0    -0.793   0.0     0.0
  0.0     0.0    -0.793   0.0
  0.0     0.0     0.0    -0.793</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(m, Irrep[SU‚ÇÇ](0)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">2√ó1 Array{Float64, 2}:
 -1.248
 -0.837</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(m, Irrep[SU‚ÇÇ](1)) |&gt; disp
       # Now a `TensorMap{SU‚ÇÇSpace, 2, 2}`</code><code class="nohighlight hljs ansi" style="display:block;">1√ó1 Array{Float64, 2}:
 -0.793</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = randn(V1 ‚äó V1, V2 ‚äó V2&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.6564311072637536  0.40188331947798783
  0.1643227613307773  0.030218800182756248
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
 0.45104175289216863
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -1.1291409713973741   -1.410695264346251
  0.05309630701614085   0.43237885896012185
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.007975825977566341
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 0.6120320493757018  0.22416725062348714
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
  1.5664011651164056
 -0.8085349251837304
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 0.936713920239021
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.7343152756897502  0.38608319934119834
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.46553872897583176
 0.5489774548603268
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.6092268075845186
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.12410443089283055  1.730279014284442
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.3237265375170499
  0.10475003231900681
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -1.4454338439298051
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, true), ()):
[:, :, 1, 1] =
 -0.5001847718626219</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (array = convert(Array, t)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5√ó4√ó4 Array{Float64, 4}:
[:, :, 1, 1] =
 -0.656  0.401  0.0    0.0   0.0
  0.164  0.03   0.0    0.0   0.0
  0.0    0.0    0.0    0.0   0.26
  0.0    0.0    0.0   -0.26  0.0
  0.0    0.0    0.26   0.0   0.0

[:, :, 2, 1] =
 0.0    0.0     1.566  0.0    0.0
 0.0    0.0    -0.808  0.0    0.0
 0.612  0.224   0.0    0.662  0.0
 0.0    0.0    -0.662  0.0    0.0
 0.0    0.0     0.0    0.0    0.0

[:, :, 3, 1] =
 0.0    0.0     0.0     1.566  0.0
 0.0    0.0     0.0    -0.808  0.0
 0.0    0.0     0.0     0.0    0.662
 0.612  0.224   0.0     0.0    0.0
 0.0    0.0    -0.662   0.0    0.0

[:, :, 4, 1] =
 0.0    0.0    0.0   0.0     1.566
 0.0    0.0    0.0   0.0    -0.808
 0.0    0.0    0.0   0.0     0.0
 0.0    0.0    0.0   0.0     0.662
 0.612  0.224  0.0  -0.662   0.0

[:, :, 1, 2] =
 0.0    0.0    0.0   0.0   0.465
 0.0    0.0    0.0   0.0   0.548
 0.0    0.0    0.0   0.0   0.0
 0.0    0.0    0.0   0.0   0.43
 0.734  0.386  0.0  -0.43  0.0

[:, :, 2, 2] =
 -0.651  -0.814  0.0    -0.228   0.0
  0.03    0.249  0.0     0.074   0.0
  0.0     0.0    0.0     0.0    -0.808
 -0.087   1.223  0.0    -0.164   0.0
  0.0     0.0    0.636   0.0     0.0

[:, :, 3, 2] =
  0.0    0.0    0.0  0.0    -0.228
  0.0    0.0    0.0  0.0     0.074
  0.0    0.0    0.0  0.0     0.0
  0.0    0.0    0.0  0.0    -0.972
 -0.087  1.223  0.0  0.472   0.0

[:, :, 4, 2] =
 0.0  0.0  0.0  0.0   0.0
 0.0  0.0  0.0  0.0   0.0
 0.0  0.0  0.0  0.0   0.0
 0.0  0.0  0.0  0.0   0.0
 0.0  0.0  0.0  0.0  -0.5

[:, :, 1, 3] =
  0.0     0.0    0.0   -0.465   0.0
  0.0     0.0    0.0   -0.548   0.0
  0.0     0.0    0.0    0.0    -0.43
 -0.734  -0.386  0.0    0.0     0.0
  0.0     0.0    0.43   0.0     0.0

[:, :, 2, 3] =
 0.0     0.0     0.228  0.0    0.0
 0.0     0.0    -0.074  0.0    0.0
 0.087  -1.223   0.0    0.972  0.0
 0.0     0.0    -0.472  0.0    0.0
 0.0     0.0     0.0    0.0    0.0

[:, :, 3, 3] =
 -0.651  -0.814  0.0    0.0    0.0
  0.03    0.249  0.0    0.0    0.0
  0.0     0.0    0.0    0.0    0.164
  0.0     0.0    0.0    0.336  0.0
  0.0     0.0    0.164  0.0    0.0

[:, :, 4, 3] =
  0.0    0.0    0.0  0.0    -0.228
  0.0    0.0    0.0  0.0     0.074
  0.0    0.0    0.0  0.0     0.0
  0.0    0.0    0.0  0.0    -0.472
 -0.087  1.223  0.0  0.972   0.0

[:, :, 1, 4] =
 0.0    0.0     0.465  0.0   0.0
 0.0    0.0     0.548  0.0   0.0
 0.734  0.386   0.0    0.43  0.0
 0.0    0.0    -0.43   0.0   0.0
 0.0    0.0     0.0    0.0   0.0

[:, :, 2, 4] =
 0.0  0.0   0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0
 0.0  0.0  -0.5  0.0  0.0
 0.0  0.0   0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0

[:, :, 3, 4] =
 0.0     0.0     0.228  0.0    0.0
 0.0     0.0    -0.074  0.0    0.0
 0.087  -1.223   0.0    0.472  0.0
 0.0     0.0    -0.972  0.0    0.0
 0.0     0.0     0.0    0.0    0.0

[:, :, 4, 4] =
 -0.651  -0.814   0.0     0.228  0.0
  0.03    0.249   0.0    -0.074  0.0
  0.0     0.0     0.0     0.0    0.636
  0.087  -1.223   0.0    -0.164  0.0
  0.0     0.0    -0.808   0.0    0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 = dim(codomain(t))</code><code class="nohighlight hljs ansi" style="display:block;">25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d2 = dim(domain(t))</code><code class="nohighlight hljs ansi" style="display:block;">16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (matrix = reshape(array, d1, d2)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">25√ó16 Array{Float64, 2}:
 -0.656   0.0     0.0     0.0     0.0    -0.651   0.0     0.0   0.0     0.0    -0.651   0.0     0.0     0.0   0.0    -0.651
  0.164   0.0     0.0     0.0     0.0     0.03    0.0     0.0   0.0     0.0     0.03    0.0     0.0     0.0   0.0     0.03
  0.0     0.612   0.0     0.0     0.0     0.0     0.0     0.0   0.0     0.087   0.0     0.0     0.734   0.0   0.087   0.0
  0.0     0.0     0.612   0.0     0.0    -0.087   0.0     0.0  -0.734   0.0     0.0     0.0     0.0     0.0   0.0     0.087
  0.0     0.0     0.0     0.612   0.734   0.0    -0.087   0.0   0.0     0.0     0.0    -0.087   0.0     0.0   0.0     0.0
  0.401   0.0     0.0     0.0     0.0    -0.814   0.0     0.0   0.0     0.0    -0.814   0.0     0.0     0.0   0.0    -0.814
  0.03    0.0     0.0     0.0     0.0     0.249   0.0     0.0   0.0     0.0     0.249   0.0     0.0     0.0   0.0     0.249
  0.0     0.224   0.0     0.0     0.0     0.0     0.0     0.0   0.0    -1.223   0.0     0.0     0.386   0.0  -1.223   0.0
  0.0     0.0     0.224   0.0     0.0     1.223   0.0     0.0  -0.386   0.0     0.0     0.0     0.0     0.0   0.0    -1.223
  0.0     0.0     0.0     0.224   0.386   0.0     1.223   0.0   0.0     0.0     0.0     1.223   0.0     0.0   0.0     0.0
  0.0     1.566   0.0     0.0     0.0     0.0     0.0     0.0   0.0     0.228   0.0     0.0     0.465   0.0   0.228   0.0
  0.0    -0.808   0.0     0.0     0.0     0.0     0.0     0.0   0.0    -0.074   0.0     0.0     0.548   0.0  -0.074   0.0
  0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0   0.0     0.0     0.0     0.0     0.0    -0.5   0.0     0.0
  0.0    -0.662   0.0     0.0     0.0     0.0     0.0     0.0   0.0    -0.472   0.0     0.0    -0.43    0.0  -0.972   0.0
  0.26    0.0    -0.662   0.0     0.0     0.636   0.0     0.0   0.43    0.0     0.164   0.0     0.0     0.0   0.0    -0.808
  0.0     0.0     1.566   0.0     0.0    -0.228   0.0     0.0  -0.465   0.0     0.0     0.0     0.0     0.0   0.0     0.228
  0.0     0.0    -0.808   0.0     0.0     0.074   0.0     0.0  -0.548   0.0     0.0     0.0     0.0     0.0   0.0    -0.074
  0.0     0.662   0.0     0.0     0.0     0.0     0.0     0.0   0.0     0.972   0.0     0.0     0.43    0.0   0.472   0.0
 -0.26    0.0     0.0     0.0     0.0    -0.164   0.0     0.0   0.0     0.0     0.336   0.0     0.0     0.0   0.0    -0.164
  0.0     0.0     0.0    -0.662  -0.43    0.0     0.472   0.0   0.0     0.0     0.0     0.972   0.0     0.0   0.0     0.0
  0.0     0.0     0.0     1.566   0.465   0.0    -0.228   0.0   0.0     0.0     0.0    -0.228   0.0     0.0   0.0     0.0
  0.0     0.0     0.0    -0.808   0.548   0.0     0.074   0.0   0.0     0.0     0.0     0.074   0.0     0.0   0.0     0.0
  0.26    0.0     0.662   0.0     0.0    -0.808   0.0     0.0  -0.43    0.0     0.164   0.0     0.0     0.0   0.0     0.636
  0.0     0.0     0.0     0.662   0.43    0.0    -0.972   0.0   0.0     0.0     0.0    -0.472   0.0     0.0   0.0     0.0
  0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.5   0.0     0.0     0.0     0.0     0.0     0.0   0.0     0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">25√ó25 Array{Float64, 2}:
 1.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  1.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  1.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  1.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    1.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  -0.707   0.0     0.0    0.0  0.707  0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0    -0.707   0.0    0.0  0.0    0.408  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.707   0.0     0.0    0.0  0.707  0.0    0.0    0.0
 0.0  0.0  0.0  0.0  -0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.816  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0    -0.707  0.0  0.0    0.0    0.707  0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.707   0.0    0.0  0.0    0.408  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.707  0.0  0.0    0.0    0.707  0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">16√ó16 Array{Float64, 2}:
 1.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    1.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    0.0  1.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    0.0  0.0  1.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.999   0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.707  0.0    0.0     0.0     0.408   0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.707  0.0     0.0     0.0     0.707  0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.999
 0.0  0.0    0.0  0.0  0.0  0.0    -0.999  0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0    -0.707   0.0    0.0    0.0    -0.707   0.0     0.0    0.0
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0    -0.816   0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.707  0.0     0.0     0.0    -0.707  0.0
 0.0  0.0    0.0  0.0  0.0  0.999   0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.999   0.0     0.0     0.0    0.0
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0    -0.707   0.0    0.0    0.0     0.707   0.0     0.0    0.0
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0    -0.707  0.0    0.0     0.0     0.408   0.0    0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u&#39;*u ‚âà I ‚âà v&#39;*v</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (u&#39;*matrix*v) |&gt; disp
       # compare with:</code><code class="nohighlight hljs ansi" style="display:block;">25√ó16 Array{Float64, 2}:
 -0.656  -1.129   0.0     0.0     0.0     0.0    0.0     0.0     0.0    -0.0     0.0     0.0   0.0   0.0   0.0   0.0
  0.164   0.053   0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0     0.0   0.0   0.0   0.0   0.0
  0.401  -1.41    0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0     0.0   0.0   0.0   0.0   0.0
  0.03    0.432   0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0     0.0   0.0  -0.0   0.0   0.0
  0.451  -0.007   0.0     0.0     0.0     0.0    0.0     0.0     0.0    -0.0     0.0     0.0   0.0   0.0   0.0   0.0
  0.0     0.0     0.612   0.0     0.0     0.734  0.0     0.0    -0.124   0.0     0.0     0.0  -0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.612   0.0     0.0    0.734   0.0     0.0    -0.124   0.0     0.0   0.0  -0.0   0.0   0.0
  0.0     0.0     0.0     0.0     0.612   0.0    0.0     0.734   0.0     0.0    -0.124   0.0   0.0   0.0  -0.0   0.0
  0.0     0.0     0.224   0.0     0.0     0.386  0.0     0.0     1.73    0.0     0.0     0.0  -0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.224   0.0     0.0    0.386   0.0     0.0     1.73    0.0     0.0   0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.0     0.224   0.0    0.0     0.386   0.0     0.0     1.73    0.0   0.0   0.0  -0.0   0.0
  0.0     0.0     1.566   0.0     0.0     0.465  0.0     0.0    -0.323   0.0     0.0     0.0   0.0   0.0   0.0   0.0
  0.0     0.0     0.0     1.566   0.0     0.0    0.465   0.0     0.0    -0.323   0.0     0.0   0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.0     1.566   0.0    0.0     0.465   0.0     0.0    -0.323   0.0   0.0   0.0   0.0   0.0
  0.0     0.0    -0.808   0.0     0.0     0.548  0.0     0.0     0.104   0.0     0.0     0.0  -0.0   0.0   0.0   0.0
  0.0     0.0     0.0    -0.808   0.0     0.0    0.548   0.0     0.0     0.104   0.0     0.0   0.0  -0.0   0.0   0.0
  0.0     0.0     0.0     0.0    -0.808   0.0    0.0     0.548   0.0     0.0     0.104   0.0   0.0   0.0  -0.0   0.0
  0.0     0.0     0.936   0.0     0.0     0.609  0.0     0.0    -1.445   0.0     0.0     0.0  -0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.936   0.0     0.0    0.609   0.0     0.0    -1.445   0.0     0.0   0.0   0.0   0.0   0.0
  0.0     0.0     0.0     0.0     0.936   0.0    0.0     0.609   0.0     0.0    -1.445   0.0   0.0   0.0  -0.0   0.0
  0.0     0.0     0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0    -0.5   0.0   0.0   0.0   0.0
  0.0     0.0    -0.0     0.0     0.0    -0.0    0.0     0.0    -0.0     0.0     0.0     0.0  -0.5   0.0   0.0   0.0
 -0.0     0.0     0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0     0.0   0.0  -0.5   0.0   0.0
  0.0     0.0     0.0     0.0    -0.0     0.0    0.0    -0.0     0.0     0.0    -0.0     0.0   0.0   0.0  -0.5   0.0
  0.0     0.0     0.0     0.0     0.0     0.0    0.0     0.0     0.0     0.0     0.0     0.0   0.0   0.0   0.0  -0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, SU2Irrep(0)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">5√ó2 Array{Float64, 2}:
 -0.656  -1.129
  0.164   0.053
  0.401  -1.41
  0.03    0.432
  0.451  -0.007</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, SU2Irrep(1)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">5√ó3 Array{Float64, 2}:
  0.612  0.734  -0.124
  0.224  0.386   1.73
  1.566  0.465  -0.323
 -0.808  0.548   0.104
  0.936  0.609  -1.445</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, SU2Irrep(2)) |&gt; disp</code><code class="nohighlight hljs ansi" style="display:block;">1√ó1 Array{Float64, 2}:
 -0.5</code></pre><p>Note that the basis transforms <code>u</code> and <code>v</code> are no longer permutation matrices, but are still unitary. Furthermore, note that they render the tensor block diagonal, but that now every element of the diagonal blocks labeled by <code>c</code> comes itself in a tensor product with an identity matrix of size <code>dim(c)</code>, i.e. <code>dim(SU2Irrep(1)) = 3</code> and <code>dim(SU2Irrep(2)) = 5</code>.</p><h2 id="ss_tensor_properties"><a class="docs-heading-anchor" href="#ss_tensor_properties">Tensor properties</a><a id="ss_tensor_properties-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_properties" title="Permalink"></a></h2><p>Given a <code>t::AbstractTensorMap{S,N‚ÇÅ,N‚ÇÇ}</code>, there are various methods to query its properties. The most important are clearly <code>codomain(t)</code> and <code>domain(t)</code>. For <code>t::AbstractTensor{S,N}</code>, i.e. <code>t::AbstractTensorMap{S,N,0}</code>, we can use <code>space(t)</code> as synonym for <code>codomain(t)</code>. However, for a general <code>AbstractTensorMap</code> this has no meaning. However, we can query <code>space(t, i)</code>, the space associated with the <code>i</code>th index. For <code>i ‚àà 1:N‚ÇÅ</code>, this corresponds to <code>codomain(t, i) = codomain(t)[i]</code>. For <code>j = i-N‚ÇÅ ‚àà (1:N‚ÇÇ)</code>, this corresponds to <code>dual(domain(t, j)) = dual(domain(t)[j])</code>.</p><p>The total number of indices, i.e. <code>N‚ÇÅ+N‚ÇÇ</code>, is given by <code>numind(t)</code>, with <code>N‚ÇÅ == numout(t)</code> and <code>N‚ÇÇ == numin(t)</code>, the number of outgoing and incoming indices. There are also the unexported methods <code>TensorKit.codomainind(t)</code> and <code>TensorKit.domainind(t)</code> which return the tuples <code>(1, 2, ‚Ä¶, N‚ÇÅ)</code> and <code>(N‚ÇÅ+1, ‚Ä¶, N‚ÇÅ+N‚ÇÇ)</code>, and are useful for internal purposes. The type parameter <code>S&lt;:ElementarySpace</code> can be obtained as <code>spacetype(t)</code>; the corresponding sector can directly obtained as <code>sectortype(t)</code> and is <code>Trivial</code> when <code>S != GradedSpace</code>. The underlying field scalars of <code>S</code> can also directly be obtained as <code>field(t)</code>. This is different from <code>eltype(t)</code>, which returns the type of <code>Number</code> in the tensor data, i.e. the type parameter <code>T</code> in the (subtype of) <code>DenseMatrix{T}</code> in which the matrix blocks are stored. Note that during construction, a (one-time) warning is printed if <code>!(T ‚äÇ field(S))</code>. The specific <code>DenseMatrix{T}</code> subtype in which the tensor data is stored is obtained as <code>storagetype(t)</code>. Each of the methods <code>numind</code>, <code>numout</code>, <code>numin</code>, <code>TensorKit.codomainind</code>, <code>TensorKit.domainind</code>, <code>spacetype</code>, <code>sectortype</code>, <code>field</code>, <code>eltype</code> and <code>storagetype</code> work in the type domain as well, i.e. they are encoded in <code>typeof(t)</code>.</p><p>Finally, there are methods to probe the data, which we already encountered. <code>blocksectors(t)</code> returns an iterator over the different coupled sectors that can be obtained from fusing the uncoupled sectors available in the domain, but they must also be obtained from fusing the uncoupled sectors available in the codomain (i.e. it is the intersection of both <code>blocksectors(codomain(t))</code> and <code>blocksectors(domain(t))</code>). For a specific sector <code>c ‚àà blocksectors(t)</code>, <code>block(t, c)</code> returns the corresponding data. Both are obtained together with <code>blocks(t)</code>, which returns an iterator over the pairs <code>c=&gt;block(t, c)</code>. Furthermore, there is <code>fusiontrees(t)</code> which returns an iterator over splitting-fusion tree pairs <code>(f‚ÇÅ,f‚ÇÇ)</code>, for which the corresponding data is given by <code>t[f‚ÇÅ,f‚ÇÇ]</code> (i.e. using Base.getindex).</p><p>Let&#39;s again illustrate these methods with an example, continuing with the tensor <code>t</code> from the previous example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(t)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap{Float64, GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 2, 2, Vector{Float64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(t)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(t,1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(t,2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(t,3)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(t,4)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numind(t)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numout(t)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numin(t)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(t)</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sectortype(t)</code><code class="nohighlight hljs ansi" style="display:block;">SU2Irrep</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(t)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(t)</code><code class="nohighlight hljs ansi" style="display:block;">Float64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; storagetype(t)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Float64}<span class="sgr90"> (alias for Array{Float64, 1})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blocksectors(t)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{SU2Irrep}:
 0
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blocks(t)</code><code class="nohighlight hljs ansi" style="display:block;">Base.Generator{TensorKit.SortedVectorDict{SU2Irrep, Tuple{Tuple{Int64, Int64}, UnitRange{Int64}}}, TensorKit.var&quot;#169#170&quot;{TensorMap{Float64, GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 2, 2, Vector{Float64}}}}(TensorKit.var&quot;#169#170&quot;{TensorMap{Float64, GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 2, 2, Vector{Float64}}}(TensorMap((Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.6564311072637536  0.40188331947798783
  0.1643227613307773  0.030218800182756248
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
 0.45104175289216863
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -1.1291409713973741   -1.410695264346251
  0.05309630701614085   0.43237885896012185
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.007975825977566341
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 0.6120320493757018  0.22416725062348714
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
  1.5664011651164056
 -0.8085349251837304
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 0.936713920239021
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.7343152756897502  0.38608319934119834
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.46553872897583176
 0.5489774548603268
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.6092268075845186
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.12410443089283055  1.730279014284442
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.3237265375170499
  0.10475003231900681
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -1.4454338439298051
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, true), ()):
[:, :, 1, 1] =
 -0.5001847718626219
), TensorKit.SortedVectorDict{SU2Irrep, Tuple{Tuple{Int64, Int64}, UnitRange{Int64}}}(0 =&gt; ((5, 2), 1:10), 1 =&gt; ((5, 3), 11:25), 2 =&gt; ((1, 1), 26:26)))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; block(t, first(blocksectors(t)))</code><code class="nohighlight hljs ansi" style="display:block;">5√ó2 reshape(view(::Vector{Float64}, 1:10), 5, 2) with eltype Float64:
 -0.656431   -1.12914
  0.164323    0.0530963
  0.401883   -1.4107
  0.0302188   0.432379
  0.451042   -0.00797583</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fusiontrees(t)</code><code class="nohighlight hljs ansi" style="display:block;">14-element Vector{Tuple{FusionTree{SU2Irrep, 2, 0, 1}, FusionTree{SU2Irrep, 2, 0, 1}}}:
 (FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, true), ()))
 (FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 2, (false, true), ()))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f1, f2 = first(fusiontrees(t))</code><code class="nohighlight hljs ansi" style="display:block;">(FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()), FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, true), ()))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t[f1,f2]</code><code class="nohighlight hljs ansi" style="display:block;">2√ó2√ó1√ó1 StridedViews.StridedView{Float64, 4, Vector{Float64}, typeof(identity)}:
[:, :, 1, 1] =
 -0.656431  0.401883
  0.164323  0.0302188</code></pre><h2 id="ss_tensor_readwrite"><a class="docs-heading-anchor" href="#ss_tensor_readwrite">Reading and writing tensors: <code>Dict</code> conversion</a><a id="ss_tensor_readwrite-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_readwrite" title="Permalink"></a></h2><p>There are no custom or dedicated methods for reading, writing or storing <code>TensorMaps</code>, however, there is the possibility to convert a <code>t::AbstractTensorMap</code> into a <code>Dict</code>, simply as <code>convert(Dict, t)</code>. The backward conversion <code>convert(TensorMap, dict)</code> will return a tensor that is equal to <code>t</code>, i.e. <code>t == convert(TensorMap, convert(Dict, t))</code>.</p><p>This conversion relies on that the string represenation of objects such as <code>VectorSpace</code>, <code>FusionTree</code> or <code>Sector</code> should be such that it represents valid code to recreate the object. Hence, we store information about the domain and codomain of the tensor, and the sector associated with each data block, as a <code>String</code> obtained with <code>repr</code>. This provides the flexibility to still change the internal structure of such objects, without this breaking the ability to load older data files. The resulting dictionary can then be stored using any of the provided Julia packages such as <a href="https://github.com/JuliaIO/JLD.jl">JLD.jl</a>, <a href="https://github.com/JuliaIO/JLD2.jl">JLD2.jl</a>, <a href="https://github.com/JuliaIO/BSON.jl">BSON.jl</a>, <a href="https://github.com/JuliaIO/JSON.jl">JSON.jl</a>, ...</p><h2 id="ss_tensor_linalg"><a class="docs-heading-anchor" href="#ss_tensor_linalg">Vector space and linear algebra operations</a><a id="ss_tensor_linalg-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_linalg" title="Permalink"></a></h2><p><code>AbstractTensorMap</code> instances <code>t</code> represent linear maps, i.e. homomorphisms in a <code>ùïú</code>-linear category, just like matrices. To a large extent, they follow the interface of <code>Matrix</code> in Julia&#39;s <code>LinearAlgebra</code> standard library. Many methods from <code>LinearAlgebra</code> are (re)exported by TensorKit.jl, and can then us be used without <code>using LinearAlgebra</code> explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks (typically using the same method) and never needs to perform any basis transforms.</p><p>In particular, <code>AbstractTensorMap</code> instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in <code>t = t1*t2</code>, which is also used for matrix multiplication. TensorKit.jl also supports (and exports) the mutating method <code>mul!(t, t1, t2)</code>. We can then also try to invert a tensor map using <code>inv(t)</code>, though this can only exist if the domain and codomain are isomorphic, which can e.g. be checked as <code>fuse(codomain(t)) == fuse(domain(t))</code>. If the inverse is composed with another tensor <code>t2</code>, we can use the syntax <code>t1\t2</code> or <code>t2/t1</code>. However, this syntax also accepts instances <code>t1</code> whose domain and codomain are not isomorphic, and then amounts to <code>pinv(t1)</code>, the Moore-Penrose pseudoinverse. This, however, is only really justified as minimizing the least squares problem if <code>InnerProductStyle(t) &lt;: EuclideanProduct</code>.</p><p><code>AbstractTensorMap</code> instances behave themselves as vectors (i.e. they are <code>ùïú</code>-linear) and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other. There is also a <code>zero(t)</code>, the additive identity, which produces a zero tensor with the same domain and codomain as <code>t</code>. In addition, <code>TensorMap</code> supports basic Julia methods such as <code>fill!</code> and <code>copy!</code>, as well as <code>copy(t)</code> to create a copy with independent data. Aside from basic <code>+</code> and <code>*</code> operations, TensorKit.jl reexports a number of efficient in-place methods from <code>LinearAlgebra</code>, such as <code>axpy!</code> (for <code>y ‚Üê Œ± * x + y</code>), <code>axpby!</code> (for <code>y ‚Üê Œ± * x + Œ≤ * y</code>), <code>lmul!</code> and <code>rmul!</code> (for <code>y ‚Üê Œ±*y</code> and <code>y ‚Üê y*Œ±</code>, which is typically the same) and <code>mul!</code>, which can also be used for out-of-place scalar multiplication <code>y ‚Üê Œ±*x</code>.</p><p>For <code>t::AbstractTensorMap{S}</code> where <code>InnerProductStyle(S) &lt;: EuclideanProduct</code>, we can compute <code>norm(t)</code>, and for two such instances, the inner product <code>dot(t1, t2)</code>, provided <code>t1</code> and <code>t2</code> have the same domain and codomain. Furthermore, there is <code>normalize(t)</code> and <code>normalize!(t)</code> to return a scaled version of <code>t</code> with unit norm. These operations should also exist for  <code>InnerProductStyle(S) &lt;: HasInnerProduct</code>, but require an interface for defining a custom inner product in these spaces. Currently, there is no concrete subtype of <code>HasInnerProduct</code> that is not an <code>EuclideanProduct</code>. In particular, <code>CartesianSpace</code>, <code>ComplexSpace</code> and <code>GradedSpace</code> all have <code>InnerProductStyle(V) &lt;: EuclideanProduct</code>.</p><p>With tensors that have <code>InnerProductStyle(t) &lt;: EuclideanProduct</code> there is associated an adjoint operation, given by <code>adjoint(t)</code> or simply <code>t&#39;</code>, such that <code>domain(t&#39;) == codomain(t)</code> and <code>codomain(t&#39;) == domain(t)</code>. Note that for an instance <code>t::TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code>, <code>t&#39;</code> is simply stored in a wrapper called <code>AdjointTensorMap{S,N‚ÇÇ,N‚ÇÅ}</code>, which is another subtype of <code>AbstractTensorMap</code>. This should be mostly unvisible to the user, as all methods should work for this type as well. It can be hard to reason about the index order of <code>t&#39;</code>, i.e. index <code>i</code> of <code>t</code> appears in <code>t&#39;</code> at index position <code>j = TensorKit.adjointtensorindex(t, i)</code>, where the latter method is typically not necessary and hence unexported. There is also a plural <code>TensorKit.adjointtensorindices</code> to convert multiple indices at once. Note that, because the adjoint interchanges domain and codomain, we have <code>space(t&#39;, j) == space(t, i)&#39;</code>.</p><p><code>AbstractTensorMap</code> instances can furthermore be tested for exact (<code>t1 == t2</code>) or approximate (<code>t1 ‚âà t2</code>) equality, though the latter requires that <code>norm</code> can be computed.</p><p>When tensor map instances are endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as <code>one(t)</code> or <code>one!(t)</code>, where the latter overwrites the contents of <code>t</code>. The multiplicative identity on a space <code>V</code> can also be obtained using <code>id(A, V)</code> as discussed <a href="#ss_tensor_construction">above</a>, such that for a general homomorphism <code>t‚Ä≤</code>, we have <code>t‚Ä≤ == id(codomain(t‚Ä≤))*t‚Ä≤ == t‚Ä≤*id(domain(t‚Ä≤))</code>. Returning to the case of endomorphisms <code>t</code>, we can compute the trace via <code>tr(t)</code> and exponentiate them using <code>exp(t)</code>, or if the contents of <code>t</code> can be destroyed in the process, <code>exp!(t)</code>. Furthermore, there are a number of tensor factorizations for both endomorphisms and general homomorphism that we discuss below.</p><p>Finally, there are a number of operations that also belong in this paragraph because of their analogy to common matrix operations. The tensor product of two <code>TensorMap</code> instances <code>t1</code> and <code>t2</code> is obtained as <code>t1 ‚äó t2</code> and results in a new <code>TensorMap</code> with <code>codomain(t1‚äót2) = codomain(t1) ‚äó codomain(t2)</code> and <code>domain(t1‚äót2) = domain(t1) ‚äó domain(t2)</code>. If we have two <code>TensorMap{S,N,1}</code> instances <code>t1</code> and <code>t2</code> with the same codomain, we can combine them in a way that is analoguous to <code>hcat</code>, i.e. we stack them such that the new tensor <code>catdomain(t1, t2)</code> has also the same codomain, but has a domain which is <code>domain(t1) ‚äï domain(t2)</code>. Similarly, if <code>t1</code> and <code>t2</code> are of type <code>TensorMap{S,1,N}</code> and have the same domain, the operation <code>catcodomain(t1, t2)</code> results in a new tensor with the same domain and a codomain given by <code>codomain(t1) ‚äï codomain(t2)</code>, which is the analogy of <code>vcat</code>. Note that direct sum only makes sense between <code>ElementarySpace</code> objects, i.e. there is no way to give a tensor product meaning to a direct sum of tensor product spaces.</p><p>Time for some more examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t == t + zero(t) == t*id(domain(t)) == id(codomain(t))*t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = randn(ComplexF64, codomain(t), domain(t));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t)</code><code class="nohighlight hljs ansi" style="display:block;">7.280301853285787 + 8.35319982104185im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tr(t2&#39;*t)</code><code class="nohighlight hljs ansi" style="display:block;">7.280301853285787 + 8.35319982104185im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t) ‚âà dot(t&#39;, t2&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t2)</code><code class="nohighlight hljs ansi" style="display:block;">60.027399543683444 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t2)^2</code><code class="nohighlight hljs ansi" style="display:block;">60.02739954368344</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 = copy!(similar(t, ComplexF64), t);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 == t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rmul!(t3, 0.8);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 ‚âà 0.8*t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; axpby!(0.5, t2, 1.3im, t3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 ‚âà 0.5 * t2  +  0.8 * 1.3im * t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 = randn(fuse(codomain(t)), codomain(t));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t5 = TensorMap(undef, fuse(codomain(t)), domain(t));</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching TensorMap(::UndefInitializer, ::GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, ::ProductSpace{GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 2})
The type `TensorMap` exists, but no method is defined for this combination of argument types when trying to construct it.

Closest candidates are:
  TensorMap(<span class="sgr91">::typeof(randn)</span>, ::TensorSpace, ::TensorSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  TensorMap(<span class="sgr91">::typeof(randnormal)</span>, ::TensorSpace, ::TensorSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  TensorMap(<span class="sgr91">::typeof(rand)</span>, ::TensorSpace, ::TensorSpace)
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90"><span class="sgr4">deprecated.jl:103</span></span>
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mul!(t5, t4, t) == t4*t</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(&quot;(Rep[SU‚ÇÇ](1/2=&gt;1) ‚äó Rep[SU‚ÇÇ](1/2=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](1/2=&gt;1) ‚äó Rep[SU‚ÇÇ](1/2=&gt;1)) ‚â† Rep[SU‚ÇÇ](0=&gt;5, 1=&gt;5, 2=&gt;1) ‚Üê (Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)) * (Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; inv(t4) * t4 ‚âà id(codomain(t))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 * inv(t4) ‚âà id(fuse(codomain(t)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t4 \ (t4 * t) ‚âà t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t6 = randn(ComplexF64, V1, codomain(t));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; numout(t4) == numout(t6) == 1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t7 = catcodomain(t4, t6);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching catcodomain(::TensorMap{Float64, GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 1, 2, Vector{Float64}}, ::TensorMap{ComplexF64, GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 1, 2, Vector{ComplexF64}})
The function `catcodomain` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  catcodomain(::TT, <span class="sgr91">::TT</span>) where {S, N‚ÇÇ, TT&lt;:(AbstractTensorMap{&lt;:Any, S, 1, N‚ÇÇ})}
<span class="sgr90">   @</span> <span class="sgr35">TensorKit</span> <span class="sgr90">~/work/TensorKit.jl/TensorKit.jl/src/tensors/<span class="sgr4">linalg.jl:455</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (codomain(t4), codomain(t6), codomain(t7)))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `t7` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t7) ‚âà sqrt(norm(t4)^2 + norm(t6)^2)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `t7` not defined in `Main`
Suggestion: check for spelling errors or missing imports.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t8 = t4 ‚äó t6;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (codomain(t4), codomain(t6), codomain(t8)))</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace(Rep[SU‚ÇÇ](0=&gt;5, 1=&gt;5, 2=&gt;1))
ProductSpace(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))
(Rep[SU‚ÇÇ](0=&gt;5, 1=&gt;5, 2=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foreach(println, (domain(t4), domain(t6), domain(t8)))</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))
(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))
(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(t8) ‚âà norm(t4)*norm(t6)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Index-manipulations"><a class="docs-heading-anchor" href="#Index-manipulations">Index manipulations</a><a id="Index-manipulations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-manipulations" title="Permalink"></a></h2><p>In many cases, the bipartition of tensor indices (i.e. <code>ElementarySpace</code> instances) between the codomain and domain is not fixed throughout the different operations that need to be performed on that tensor map, i.e. we want to use the duality to move spaces from domain to codomain and vice versa. Furthermore, we want to use the braiding to reshuffle the order of the indices.</p><p>For this, we use an interface that is closely related to that for manipulating splitting- fusion tree pairs, namely <a href="../../lib/sectors/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid</code></a> and <a href="../../lib/sectors/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a>, with the interface</p><pre><code class="language-julia hljs">braid(t::AbstractTensorMap{S,N‚ÇÅ,N‚ÇÇ}, levels::NTuple{N‚ÇÅ+N‚ÇÇ,Int},
        p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int})</code></pre><p>and</p><pre><code class="language-julia hljs">permute(t::AbstractTensorMap{S,N‚ÇÅ,N‚ÇÇ},
        p1::NTuple{N‚ÇÅ‚Ä≤,Int}, p2::NTuple{N‚ÇÇ‚Ä≤,Int}; copy = false)</code></pre><p>both of which return an instance of <code>AbstractTensorMap{S,N‚ÇÅ‚Ä≤,N‚ÇÇ‚Ä≤}</code>.</p><p>In these methods, <code>p1</code> and <code>p2</code> specify which of the original tensor indices ranging from <code>1</code> to <code>N‚ÇÅ+N‚ÇÇ</code> make up the new codomain (with <code>N‚ÇÅ‚Ä≤</code> spaces) and new domain (with <code>N‚ÇÇ‚Ä≤</code> spaces). Hence, <code>(p1..., p2...)</code> should be a valid permutation of <code>1:(N‚ÇÅ+N‚ÇÇ)</code>. Note that, throughout TensorKit.jl, permutations are always specified using tuples of <code>Int</code>s, for reasons of type stability. For <code>braid</code>, we also need to specify <code>levels</code> or depths for each of the indices of the original tensor, which determine whether indices will braid over or underneath each other (use the braiding or its inverse). We refer to the section on <a href="../sectors/#ss_fusiontrees">manipulating fusion trees</a> for more details.</p><p>When <code>BraidingStyle(sectortype(t)) isa SymmetricBraiding</code>, we can use the simpler interface of <code>permute</code>, which does not require the argument <code>levels</code>. <code>permute</code> accepts a keyword argument <code>copy</code>. When <code>copy == true</code>, the result will be a tensor with newly allocated data that can independently be modified from that of the input tensor <code>t</code>. When <code>copy</code> takes the default value <code>false</code>, <code>permute</code> can try to return the result in a way that it shares its data with the input tensor <code>t</code>, though this is only possible in specific cases (e.g. when <code>sectortype(S) == Trivial</code> and <code>(p1..., p2...) = (1:(N‚ÇÅ+N‚ÇÇ)...)</code>).</p><p>Both <code>braid</code> and <code>permute</code> come in a version where the result is stored in an already existing tensor, i.e. <a href="../../lib/tensors/#TensorKit.braid!"><code>braid!(tdst, tsrc, levels, p1, p2)</code></a> and <a href="../../lib/tensors/#Base.permute!-Tuple{AbstractTensorMap, AbstractTensorMap, Tuple{NTuple{N‚ÇÅ, Int64}, NTuple{N‚ÇÇ, Int64}} where {N‚ÇÅ, N‚ÇÇ}}"><code>permute!(tdst, tsrc, p1, p2)</code></a>.</p><p>Another operation that belongs und index manipulations is taking the <code>transpose</code> of a tensor, i.e. <code>LinearAlgebra.transpose(t)</code> and <code>LinearAlgebra.transpose!(tdst, tsrc)</code>, both of which are reexported by TensorKit.jl. Note that <code>transpose(t)</code> is not simply equal to reshuffling domain and codomain with <code>braid(t, (1:(N‚ÇÅ+N‚ÇÇ)...), reverse(domainind(tsrc)), reverse(codomainind(tsrc))))</code>. Indeed, the graphical representation (where we draw the codomain and domain as a single object), makes clear that this introduces an additional (inverse) twist, which is then compensated in the <code>transpose</code> implementation.</p><p><img src="../img/tensor-transpose.svg" alt="transpose"/></p><p>In categorical language, the reason for this extra twist is that we use the left coevaluation <span>$Œ∑$</span>, but the right evaluation <span>$\tilde{œµ}$</span>, when repartitioning the indices between domain and codomain.</p><p>There are a number of other index related manipulations. We can apply a twist (or inverse twist) to one of the tensor map indices via <a href="../../lib/sectors/#TensorKitSectors.twist-Tuple{Sector}"><code>twist(t, i; inv = false)</code></a> or <a href="../../lib/tensors/#TensorKit.twist!"><code>twist!(t, i; inv = false)</code></a>. Note that the latter method does not store the result in a new destination tensor, but just modifies the tensor <code>t</code> in place. Twisting several indices simultaneously can be obtained by using the defining property</p><p><span>$Œ∏_{V‚äóW} = œÑ_{W,V} ‚àò (Œ∏_W ‚äó Œ∏_V) ‚àò œÑ_{V,W} = (Œ∏_V ‚äó Œ∏_W) ‚àò œÑ_{W,V} ‚àò œÑ_{V,W}.$</span></p><p>but is currently not implemented explicitly.</p><p>For all sector types <code>I</code> with <code>BraidingStyle(I) == Bosonic()</code>, all twists are <code>1</code> and thus have no effect. Let us start with some examples, in which we illustrate that, albeit <code>permute</code> might act highly non-trivial on the fusion trees and on the corresponding data, after conversion to a regular <code>Array</code> (when possible), it just acts like <code>permutedims</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t) ‚Üí codomain(t)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)) ‚Üê (Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ta = convert(Array, t);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ = permute(t, (1,2,3,4));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t‚Ä≤) ‚Üí codomain(t‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39; ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)) ‚Üê ProductSpace{GradedSpace{SU2Irrep, TensorKit.SortedVectorDict{SU2Irrep, Int64}}, 0}()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, t‚Ä≤) ‚âà ta</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤‚Ä≤ = permute(t, (4,2,3),(1,));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(t‚Ä≤‚Ä≤) ‚Üí codomain(t‚Ä≤‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;) ‚Üê Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, t‚Ä≤‚Ä≤) ‚âà permutedims(ta, (4,2,3,1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1) ‚Üê Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
 -1.2487784467316776
 -0.8376103170012155
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
 -0.793889625685231</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(m)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(Rep[SU‚ÇÇ](0=&gt;1, 1=&gt;1)&#39; ‚Üê Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1)&#39;):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (true,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (true,), ()):
 -1.2487784467316776  -0.8376103170012155
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (true,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (true,), ()):
 -0.7938896256852309</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, transpose(t)) ‚âà permutedims(ta,(4,3,2,1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t2, t) ‚âà dot(transpose(t2), transpose(t))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(transpose(t)) ‚âà t</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(t, 3) ‚âà t
       # as twist acts trivially for</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(sectortype(t))</code><code class="nohighlight hljs ansi" style="display:block;">Bosonic()</code></pre><p>Note that <code>transpose</code> acts like one would expect on a <code>TensorMap{S,1,1}</code>. On a <code>TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code>, because <code>transpose</code> replaces the codomain with the dual of the domain, which has its tensor product operation reversed, this in the end amounts in a complete reversal of all tensor indices when representing it as a plain mutli-dimensional <code>Array</code>. Also, note that we have not defined the conjugation of <code>TensorMap</code> instances. One definition that one could think of is <code>conj(t) = adjoint(transpose(t))</code>. However note that <code>codomain(adjoint(tranpose(t))) == domain(transpose(t)) == dual(codomain(t))</code> and similarly <code>domain(adjoint(tranpose(t))) == dual(domain(t))</code>, where <code>dual</code> of a <code>ProductSpace</code> is composed of the dual of the <code>ElementarySpace</code> instances, in reverse order of tensor product. This might be very confusing, and as such we leave tensor conjugation undefined. However, note that we have a conjugation syntax within the context of <a href="#ss_tensor_contraction">tensor contractions</a>.</p><p>To show the effect of <code>twist</code>, we now consider a type of sector <code>I</code> for which <code>BraidingStyle{I} != Bosonic()</code>. In particular, we use <code>FibonacciAnyon</code>. We cannot convert the resulting <code>TensorMap</code> to an <code>Array</code>, so we have to rely on indirect tests to verify our results.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = GradedSpace{FibonacciAnyon}(:I=&gt;3,:œÑ=&gt;2)</code><code class="nohighlight hljs ansi" style="display:block;">Vect[FibonacciAnyon](:I=&gt;3, :œÑ=&gt;2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = GradedSpace{FibonacciAnyon}(:I=&gt;2,:œÑ=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Vect[FibonacciAnyon](:I=&gt;2, :œÑ=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = TensorMap(randn, Float32, V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:35
TensorMap(Vect[FibonacciAnyon](:I=&gt;3, :œÑ=&gt;2) ‚Üê Vect[FibonacciAnyon](:I=&gt;2, :œÑ=&gt;1)):
* Data for fusiontree FusionTree{FibonacciAnyon}((:I,), :I, (false,), ()) ‚Üê FusionTree{FibonacciAnyon}((:I,), :I, (false,), ()):
 -0.34383184f0  -0.37726963f0
  0.8259274f0   -1.5841492f0
  2.150221f0     1.0650833f0
* Data for fusiontree FusionTree{FibonacciAnyon}((:œÑ,), :œÑ, (false,), ()) ‚Üê FusionTree{FibonacciAnyon}((:œÑ,), :œÑ, (false,), ()):
 0.03906213f0
 1.6887652f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(m)</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:35
TensorMap(Vect[FibonacciAnyon](:I=&gt;2, :œÑ=&gt;1)&#39; ‚Üê Vect[FibonacciAnyon](:I=&gt;3, :œÑ=&gt;2)&#39;):
* Data for fusiontree FusionTree{FibonacciAnyon}((:I,), :I, (true,), ()) ‚Üê FusionTree{FibonacciAnyon}((:I,), :I, (true,), ()):
 -0.34383184f0   0.8259274f0  2.150221f0
 -0.37726963f0  -1.5841492f0  1.0650833f0
* Data for fusiontree FusionTree{FibonacciAnyon}((:œÑ,), :œÑ, (true,), ()) ‚Üê FusionTree{FibonacciAnyon}((:œÑ,), :œÑ, (true,), ()):
 0.03906213f0  1.6887652f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(braid(m, (1,2), (2,), (1,)), 1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: AssertionError: length(levels) == numind(t)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = randn(V1*V2&#39;, V2*V1);</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:35</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = randn(ComplexF64, V1*V2&#39;, V2*V1);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(t1, t2) ‚âà dot(transpose(t1), transpose(t2))</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:35
true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(transpose(t1)) ‚âà t1</code><code class="nohighlight hljs ansi" style="display:block;">‚îå Warning: Tensors with real data might be incompatible with sector type FibonacciAnyon
‚îî @ TensorKit ~/work/TensorKit.jl/TensorKit.jl/src/tensors/tensor.jl:35
true</code></pre><p>A final operation that one might expect in this section is to fuse or join indices, and its inverse, to split a given index into two or more indices. For a plain tensor (i.e. with <code>sectortype(t) == Trivial</code>) amount to the equivalent of <code>reshape</code> on the multidimensional data. However, this represents only one possibility, as there is no canonically unique way to embed the tensor product of two spaces <code>V‚ÇÅ ‚äó V‚ÇÇ</code> in a new space <code>V = fuse(V‚ÇÅ‚äóV‚ÇÇ)</code>. Such a mapping can always be accompagnied by a basis transform. However, one particular choice is created by the function <code>isomorphism</code>, or for <code>EuclideanProduct</code> spaces, <code>unitary</code>. Hence, we can join or fuse two indices of a tensor by first constructing <code>u = unitary(fuse(space(t, i) ‚äó space(t, j)), space(t, i) ‚äó space(t, j))</code> and then contracting this map with indices <code>i</code> and <code>j</code> of <code>t</code>, as explained in the section on <a href="#ss_tensor_contraction">contracting tensors</a>. Note, however, that a typical algorithm is not expected to often need to fuse and split indices, as e.g. tensor factorizations can easily be applied without needing to <code>reshape</code> or fuse indices first, as explained in the next section.</p><h2 id="ss_tensor_factorization"><a class="docs-heading-anchor" href="#ss_tensor_factorization">Tensor factorizations</a><a id="ss_tensor_factorization-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_factorization" title="Permalink"></a></h2><h3 id="Eigenvalue-decomposition"><a class="docs-heading-anchor" href="#Eigenvalue-decomposition">Eigenvalue decomposition</a><a id="Eigenvalue-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-decomposition" title="Permalink"></a></h3><p>As tensors are linear maps, they have various kinds of factorizations. Endomorphism, i.e. tensor maps <code>t</code> with <code>codomain(t) == domain(t)</code>, have an eigenvalue decomposition. For this, we overload both <code>LinearAlgebra.eigen(t; kwargs...)</code> and <code>LinearAlgebra.eigen!(t; kwargs...)</code>, where the latter destroys <code>t</code> in the process. The keyword arguments are the same that are accepted by <code>LinearAlgebra.eigen(!)</code> for matrices. The result is returned as <code>D, V = eigen(t)</code>, such that <code>t*V ‚âà V*D</code>. For given <code>t::TensorMap{S,N,N}</code>, <code>V</code> is a <code>TensorMap{S,N,1}</code>, whose codomain corresponds to that of <code>t</code>, but whose domain is a single space <code>S</code> (or more correctly a <code>ProductSpace{S,1}</code>), that corresponds to <code>fuse(codomain(t))</code>. The eigenvalues are encoded in <code>D</code>, a <code>TensorMap{S,1,1}</code>, whose domain and codomain correspond to the domain of <code>V</code>. Indeed, we cannot reasonably associate a tensor product structure with the different eigenvalues. Note that <code>D</code> stores the eigenvalues on the diagonal of a (collection of) <code>DenseMatrix</code> instance(s), as there is currently no dedicated <code>DiagonalTensorMap</code> or diagonal storage support.</p><p>We also define <code>LinearAlgebra.ishermitian(t)</code>, which can only return true for instances of <code>AbstractEuclideanTensorMap</code>. In all other cases, as the inner product is not defined, there is no notion of hermiticity (i.e. we are not working in a <code>‚Ä†</code>-category). For instances of <code>EuclideanTensorMap</code>, we also define and export the routines <code>eigh</code> and <code>eigh!</code>, which compute the eigenvalue decomposition under the guarantee (not checked) that the map is hermitian. Hence, eigenvalues will be real and <code>V</code> will be unitary with <code>eltype(V) == eltype(t)</code>. We also define and export <code>eig</code> and <code>eig!</code>, which similarly assume that the <code>TensorMap</code> is not hermitian (hence this does not require <code>EuclideanTensorMap</code>), and always returns complex values eigenvalues and eigenvectors. Like for matrices, <code>LinearAlgebra.eigen</code> is type unstable and checks hermiticity at run-time, then falling back to either <code>eig</code> or <code>eigh</code>.</p><h3 id="Orthogonal-factorizations"><a class="docs-heading-anchor" href="#Orthogonal-factorizations">Orthogonal factorizations</a><a id="Orthogonal-factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-factorizations" title="Permalink"></a></h3><p>Other factorizations that are provided by TensorKit.jl are orthogonal or unitary in nature, and thus always require a <code>AbstractEuclideanTensorMap</code>. However, they don&#39;t require equal domain and codomain. Let us first discuss the <em>singular value decomposition</em>, for which we define and export the methods <a href="../../lib/tensors/#TensorKit.tsvd"><code>tsvd</code></a> and <code>tsvd!</code> (where as always, the latter destroys the input).</p><pre><code class="language-julia hljs">U, Œ£, V ∞, œµ = tsvd(t; trunc = notrunc(), p::Real = 2,
                        alg::OrthogonalFactorizationAlgorithm = SDD())</code></pre><p>This computes a (possibly truncated) singular value decomposition of <code>t::TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code> (with <code>InnerProductStyle(t)&lt;:EuclideanProduct</code>), such that <code>norm(t - U*Œ£*V ∞) ‚âà œµ</code>, where <code>U::TensorMap{S,N‚ÇÅ,1}</code>, <code>S::TensorMap{S,1,1}</code>, <code>V ∞::TensorMap{S,1,N‚ÇÇ}</code> and <code>œµ::Real</code>. <code>U</code> is an isometry, i.e. <code>U&#39;*U</code> approximates the identity, whereas <code>U*U&#39;</code> is an idempotent (squares to itself). The same holds for <code>adjoint(V ∞)</code>. The domain of <code>U</code> equals the domain and codomain of <code>Œ£</code> and the codomain of <code>V ∞</code>. In the case of <code>trunc = notrunc()</code> (default value, see below), this space is given by <code>min(fuse(codomain(t)), fuse(domain(t)))</code>. The singular values are contained in <code>Œ£</code> and are stored on the diagonal of a (collection of) <code>DenseMatrix</code> instance(s), similar to the eigenvalues before.</p><p>The keyword argument <code>trunc</code> provides a way to control the truncation, and is connected to  the keyword argument <code>p</code>. The default value <code>notrunc()</code> implies no truncation, and thus <code>œµ = 0</code>. Other valid options are</p><ul><li><p><code>truncerr(Œ∑::Real)</code>: truncates such that the <code>p</code>-norm of the truncated singular values   is smaller than <code>Œ∑</code> times the <code>p</code>-norm of all singular values;</p></li><li><p><code>truncdim(œá::Integer)</code>: finds the optimal truncation such that the equivalent total   dimension of the internal vector space is no larger than <code>œá</code>;</p></li><li><p><code>truncspace(W)</code>: truncates such that the dimension of the internal vector space is   smaller than that of <code>W</code> in any sector, i.e. with   <code>W‚ÇÄ = min(fuse(codomain(t)), fuse(domain(t)))</code> this option will result in   <code>domain(U) == domain(Œ£) == codomain(Œ£) == codomain(V·µà) == min(W, W‚ÇÄ)</code>;</p></li><li><p><code>trunbelow(Œ∑::Real)</code>: truncates such that every singular value is larger then <code>Œ∑</code>; this   is different from <code>truncerr(Œ∑)</code> with <code>p = Inf</code> because it works in absolute rather than   relative values.</p></li></ul><p>Furthermore, the <code>alg</code> keyword can be either <code>SVD()</code> or <code>SDD()</code> (default), which corresponds to two different algorithms in LAPACK to compute singular value decompositions. The default value <code>SDD()</code> uses a divide-and-conquer algorithm and is typically the fastest, but can loose some accuracy. The <code>SVD()</code> method uses a QR-iteration scheme and can be more accurate, but is typically slower. Since Julia 1.3, these two algorithms are also available in the <code>LinearAlgebra</code> standard library, where they are specified as <code>LinearAlgebra.DivideAndConquer()</code> and <code>LinearAlgebra.QRIteration()</code>.</p><p>Note that we defined the new method <code>tsvd</code> (truncated or tensor singular value decomposition), rather than overloading <code>LinearAlgebra.svd</code>. We (will) also support <code>LinearAlgebra.svd(t)</code> as alternative for <code>tsvd(t; trunc = notrunc())</code>, but note that the return values are then given by <code>U, Œ£, V = svd(t)</code> with <code>V = adjoint(V ∞)</code>.</p><p>We also define the following pair of orthogonal factorization algorithms, which are useful when one is not interested in truncating a tensor or knowing the singular values, but only in its image or coimage.</p><ul><li><p><code>Q, R = leftorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos(), kwargs...)</code>:   this produces an isometry <code>Q::TensorMap{S,N‚ÇÅ,1}</code> (i.e. <code>Q&#39;*Q</code> approximates the identity,   <code>Q*Q&#39;</code> is an idempotent, i.e. squares to itself) and a general tensor map   <code>R::TensorMap{1,N‚ÇÇ}</code>, such that <code>t ‚âà Q*R</code>. Here, the domain of <code>Q</code> and thus codomain of   <code>R</code> is a single vector space of type <code>S</code> that is typically given by   <code>min(fuse(codomain(t)), fuse(domain(t)))</code>.</p><p>The underlying algorithm used to compute this decomposition can be chosen among <code>QR()</code>,   <code>QRpos()</code>, <code>QL()</code>, <code>QLpos()</code>, <code>SVD()</code>, <code>SDD()</code>, <code>Polar()</code>. <code>QR()</code> uses the underlying   <code>qr</code> decomposition from <code>LinearAlgebra</code>, while <code>QRpos()</code> (the default) adds a correction   to that to make sure that the diagonal elements of <code>R</code> are positive.   Both result in upper triangular <code>R</code>, which are square when <code>codomain(t) ‚âæ domain(t)</code>   and wide otherwise. <code>QL()</code> and <code>QLpos()</code> similarly result in a lower triangular   matrices in <code>R</code>, but only work in the former case, i.e. <code>codomain(t) ‚âæ domain(t)</code>,   which amounts to <code>blockdim(codomain(t), c) &gt;= blockdim(domain(t), c)</code> for all   <code>c ‚àà blocksectors(t)</code>.</p><p>One can also use <code>alg = SVD()</code> or <code>alg = SDD()</code>, with extra keywords to control the   absolute (<code>atol</code>) or relative (<code>rtol</code>) tolerance. We then set <code>Q=U</code> and <code>R=Œ£*V ∞</code> from   the corresponding singular value decomposition, where only these singular values   <code>œÉ &gt;= max(atol, norm(t)*rtol)</code> (and corresponding singular vectors in <code>U</code>) are kept.   More finegrained control on the chosen singular values can be obtained with <code>tsvd</code> and   its <code>trunc</code> keyword.</p><p>Finally, <code>Polar()</code> sets <code>Q=U*V ∞</code> and <code>R = (V ∞)&#39;*Œ£*V ∞</code>, such that <code>R</code> is positive   definite; in this case <code>SDD()</code> is used to actually compute the singular value   decomposition and no <code>atol</code> or <code>rtol</code> can be provided.</p></li><li><p><code>L, Q = rightorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos())</code>:   this produces a general tensor map <code>L::TensorMap{S,N‚ÇÅ,1}</code> and the adjoint of an isometry   <code>Q::TensorMap{S,1,N‚ÇÇ}</code>, such that <code>t ‚âà L*Q</code>. Here, the domain of <code>L</code> and thus codomain   of <code>Q</code> is a single vector space of type <code>S</code> that is typically given by   <code>min(fuse(codomain(t)), fuse(domain(t)))</code>.</p><p>The underlying algorithm used to compute this decomposition can be chosen among <code>LQ()</code>,   <code>LQpos()</code>, <code>RQ()</code>, <code>RQpos()</code>, <code>SVD()</code>, <code>SDD()</code>, <code>Polar()</code>. <code>LQ()</code> uses the underlying   <code>qr</code> decomposition from <code>LinearAlgebra</code> on the transposed data, and leads to lower   triangular matrices in <code>L</code>; <code>LQpos()</code> makes sure the diagonal elements are   positive. The matrices <code>L</code> are square when <code>codomain(t) ‚âø domain(t)</code> and tall otherwise.   Similarly, <code>RQ()</code> and <code>RQpos()</code> result in upper triangular matrices in <code>L</code>, but only   works if <code>codomain(t) ‚âø domain(t)</code>, i.e. when   <code>blockdim(codomain(t), c) &lt;= blockdim(domain(t), c)</code> for all <code>c ‚àà blocksectors(t)</code>.</p><p>One can also use <code>alg = SVD()</code> or <code>alg = SDD()</code>, with extra keywords to control the   absolute (<code>atol</code>) or relative (<code>rtol</code>) tolerance. We then set <code>L=U*Œ£</code> and <code>Q=V ∞</code> from   the corresponding singular value decomposition, where only these singular values   <code>œÉ &gt;= max(atol, norm(t)*rtol)</code> (and corresponding singular vectors in <code>V ∞</code>) are kept.   More finegrained control on the chosen singular values can be obtained with <code>tsvd</code> and   its <code>trunc</code> keyword.</p><p>Finally, <code>Polar()</code> sets <code>L = U*Œ£*U&#39;</code> and <code>Q=U*V ∞</code>, such that <code>L</code> is positive definite;   in this case <code>SDD()</code> is used to actually compute the singular value decomposition and no   <code>atol</code> or <code>rtol</code> can be provided.</p></li></ul><p>Furthermore, we can compute an orthonormal basis for the orthogonal complement of the image and of the co-image (i.e. the kernel) with the following methods:</p><ul><li><p><code>N = leftnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...)</code>:   returns an isometric <code>TensorMap{S,N‚ÇÅ,1}</code> (i.e. <code>N&#39;*N</code> approximates the identity) such   that <code>N&#39;*t</code> is approximately zero.</p><p>Here, <code>alg</code> can be <code>QR()</code> (<code>QRpos()</code> acts identically in this case), which assumes that   <code>t</code> is full rank in all of its blocks and only returns an orthonormal basis for the   missing columns.</p><p>If this is not the case, one can also use <code>alg = SVD()</code> or <code>alg = SDD()</code>, with extra   keywords to control the absolute (<code>atol</code>) or relative (<code>rtol</code>) tolerance. We then   construct <code>N</code> from the left singular vectors corresponding to singular values   <code>œÉ &lt; max(atol, norm(t)*rtol)</code>.</p></li><li><p><code>N = rightnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...)</code>:   returns a <code>TensorMap{S,1,N‚ÇÇ}</code> with isometric adjoint (i.e. <code>N*N&#39;</code> approximates the   identity) such that <code>t*N&#39;</code> is approximately zero.</p><p>Here, <code>alg</code> can be <code>LQ()</code> (<code>LQpos()</code> acts identically in this case), which assumes that   <code>t</code> is full rank in all of its blocks and only returns an orthonormal basis for the   missing rows.</p><p>If this is not the case, one can also use <code>alg = SVD()</code> or <code>alg = SDD()</code>, with extra   keywords to control the absolute (<code>atol</code>) or relative (<code>rtol</code>) tolerance. We then   construct <code>N</code> from the right singular vectors corresponding to singular values   <code>œÉ &lt; max(atol, norm(t)*rtol)</code>.</p></li></ul><p>Note that the methods <code>leftorth</code>, <code>rightorth</code>, <code>leftnull</code> and <code>rightnull</code> also come in a form with exclamation mark, i.e. <code>leftorth!</code>, <code>rightorth!</code>, <code>leftnull!</code> and <code>rightnull!</code>, which destroy the input tensor <code>t</code>.</p><h3 id="Factorizations-for-custom-index-bipartions"><a class="docs-heading-anchor" href="#Factorizations-for-custom-index-bipartions">Factorizations for custom index bipartions</a><a id="Factorizations-for-custom-index-bipartions-1"></a><a class="docs-heading-anchor-permalink" href="#Factorizations-for-custom-index-bipartions" title="Permalink"></a></h3><p>Finally, note that each of the factorizations take a single argument, the tensor map <code>t</code>, and a number of keyword arguments. They perform the factorization according to the given codomain and domain of the tensor map. In many cases, we want to perform the factorization according to a different bipartition of the indices. When <code>BraidingStyle(sectortype(t)) isa SymmetricBraiding</code>, we can immediately specify an alternative bipartition of the indices of <code>t</code> in all of these methods, in the form</p><pre><code class="language-julia hljs">factorize(t::AbstracTensorMap, pleft::NTuple{N‚ÇÅ‚Ä≤,Int}, pright::NTuple{N‚ÇÇ‚Ä≤,Int}; kwargs...)</code></pre><p>where <code>pleft</code> will be the indices in the codomain of the new tensor map, and <code>pright</code> the indices of the domain. Here, <code>factorize</code> is any of the methods <code>LinearAlgebra.eigen</code>, <code>eig</code>, <code>eigh</code>, <code>tsvd</code>, <code>LinearAlgebra.svd</code>, <code>leftorth</code>, <code>rightorth</code>, <code>leftnull</code> and <code>rightnull</code>. This signature does not allow for the exclamation mark, because it amounts to</p><pre><code class="language-julia hljs">factorize!(permute(t, pleft, pright; copy = true); kwargs...)</code></pre><p>where <a href="../../lib/sectors/#TensorKit.permute-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>permute</code></a> was introduced and discussed in the previous section. When the braiding is not symmetric, the user should manually apply <a href="../../lib/sectors/#TensorKit.braid-Union{Tuple{N}, Tuple{I}, Tuple{FusionTree{I, N}, NTuple{N, Int64}, NTuple{N, Int64}}} where {I&lt;:Sector, N}"><code>braid</code></a> to bring the tensor map in proper form before performing the factorization.</p><p>Some examples to conclude this section</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = SU‚ÇÇSpace(0=&gt;2,1/2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU‚ÇÇSpace(0=&gt;1,1/2=&gt;1,1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = randn(V1 ‚äó V1, V2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U, S, W = tsvd(t);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t ‚âà U * S * W</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D, V = eigh(t&#39;*t);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D ‚âà S*S</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39;*U ‚âà id(domain(U))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; S</code><code class="nohighlight hljs ansi" style="display:block;">DiagonalTensorMap(Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1, 1=&gt;1) ‚Üê Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1, 1=&gt;1)):
* Data for sector Irrep[SU‚ÇÇ](0):
 1.5819400977993785
* Data for sector Irrep[SU‚ÇÇ](1/2):
 2.4369504631553505
* Data for sector Irrep[SU‚ÇÇ](1):
 1.0007180880022715</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q, R = leftorth(t; alg = Polar());</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isposdef(R)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q ‚âà U*W</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R ‚âà W&#39;*S*W</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U2, S2, W2, Œµ = tsvd(t; trunc = truncspace(V1));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W2*W2&#39; ‚âà id(codomain(W2))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; S2</code><code class="nohighlight hljs ansi" style="display:block;">DiagonalTensorMap(Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1) ‚Üê Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1)):
* Data for sector Irrep[SU‚ÇÇ](0):
 1.5819400977993785
* Data for sector Irrep[SU‚ÇÇ](1/2):
 2.4369504631553505</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œµ ‚âà norm(block(S, Irrep[SU‚ÇÇ](1)))*sqrt(dim(Irrep[SU‚ÇÇ](1)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; L, Q = rightorth(t, (1,), (2,3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(L), domain(L), domain(Q)</code><code class="nohighlight hljs ansi" style="display:block;">(ProductSpace(Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1)), ProductSpace(Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1)), (Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1)&#39; ‚äó Rep[SU‚ÇÇ](0=&gt;1, 1/2=&gt;1, 1=&gt;1)))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q*Q&#39;</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1) ‚Üê Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1)):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
 1.0                     1.4055623989039916e-18
 1.4055623989039916e-18  0.9999999999999999
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()):
 1.0000000000000004</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = Q&#39;*Q;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P ‚âà P*P</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ = permute(t, (1,), (2,3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t‚Ä≤ ‚âà t‚Ä≤ * P</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="ss_tensor_contraction"><a class="docs-heading-anchor" href="#ss_tensor_contraction">Bosonic tensor contractions and tensor networks</a><a id="ss_tensor_contraction-1"></a><a class="docs-heading-anchor-permalink" href="#ss_tensor_contraction" title="Permalink"></a></h2><p>One of the most important operation with tensor maps is to compose them, more generally known as contracting them. As mentioned in the section on <a href="../categories/#s_categories">category theory</a>, a typical composition of maps in a ribbon category can graphically be represented as a planar arrangement of the morphisms (i.e. tensor maps, boxes with lines eminating from top and bottom, corresponding to source and target, i.e. domain and codomain), where the lines connecting the source and targets of the different morphisms should be thought of as ribbons, that can braid over or underneath each other, and that can twist. Technically, we can embed this diagram in <span>$‚Ñù √ó [0,1]$</span> and attach all the unconnected line endings corresponding objects in the source at some position <span>$(x,0)$</span> for <span>$x‚àà‚Ñù$</span>, and all line endings corresponding to objects in the target at some position <span>$(x,1)$</span>. The resulting morphism is then invariant under what is known as <em>framed three-dimensional isotopy</em>, i.e. three-dimensional rearrangements of the morphism that respect the rules of boxes connected by ribbons whose open endings are kept fixed. Such a two-dimensional diagram cannot easily be encoded in a single line of code.</p><p>However, things simplify when the braiding is symmetric (such that over- and under- crossings become equivalent, i.e. just crossings), and when twists, i.e. self-crossings in this case, are trivial. This amounts to <code>BraidingStyle(I) == Bosonic()</code> in the language of TensorKit.jl, and is true for any subcategory of <span>$\mathbf{Vect}$</span>, i.e. ordinary tensors, possibly with some symmetry constraint. The case of <span>$\mathbf{SVect}$</span> and its subcategories, and more general categories, are discussed below.</p><p>In the case of triival twists, we can deform the diagram such that we first combine every morphism with a number of coevaluations <span>$Œ∑$</span> so as to represent it as a tensor, i.e. with a trivial domain. We can then rearrange the morphism to be all ligned up horizontally, where the original morphism compositions are now being performed by evaluations <span>$œµ$</span>. This process will generate a number of crossings and twists, where the latter can be omitted because they act trivially. Similarly, double crossings can also be omitted. As a consequence, the diagram, or the morphism it represents, is completely specified by the tensors it is composed of, and which indices between the different tensors are connect, via the evaluation <span>$œµ$</span>, and which indices make up the source and target of the resulting morphism. If we also compose the resulting morphisms with coevaluations so that it has a trivial domain, we just have one type of unconnected lines, henceforth called open indices. We sketch such a rearrangement in the following picture</p><p><img src="../img/tensor-bosoniccontraction.svg" alt="tensor unitary"/></p><p>Hence, we can now specify such a tensor diagram, henceforth called a tensor contraction or also tensor network, using a one-dimensional syntax that mimicks <a href="https://en.wikipedia.org/wiki/Abstract_index_notation">abstract index notation</a> and specifies which indices are connected by the evaluation map using Einstein&#39;s summation conventation. Indeed, for <code>BraidingStyle(I) == Bosonic()</code>, such a tensor contraction can take the same format as if all tensors were just multi-dimensional arrays. For this, we rely on the interface provided by the package <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>.</p><p>The above picture would be encoded as</p><pre><code class="language-julia hljs">@tensor E[a,b,c,d,e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]</code></pre><p>or</p><pre><code class="language-julia hljs">@tensor E[:] := A[1,2,-4,3]*B[4,5,-3,3]*C[1,-5,4,-2]*D[-1,2,5]</code></pre><p>where the latter syntax is known as NCON-style, and labels the unconnected or outgoing indices with negative integers, and the contracted indices with positive integers.</p><p>A number of remarks are in order. TensorOperations.jl accepts both integers and any valid variable name as dummy label for indices, and everything in between <code>[ ]</code> is not resolved in the current context but interpreted as a dummy label. Here, we label the indices of a <code>TensorMap</code>, like <code>A::TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code>, in a linear fashion, where the first position corresponds to the first space in <code>codomain(A)</code>, and so forth, up to position <code>N‚ÇÅ</code>. Index <code>N‚ÇÅ+1</code>then corresponds to the first space in <code>domain(A)</code>. However, because we have applied the coevaluation <span>$Œ∑$</span>, it actually corresponds to the corresponding dual space, in accordance with the interface of <a href="../../lib/spaces/#TensorKit.space"><code>space(A, i)</code></a> that we introduced <a href="#ss_tensor_properties">above</a>, and as indiated by the dotted box around <span>$A$</span> in the above picture. The same holds for the other tensor maps. Note that our convention also requires that we braid indices that we brought from the domain to the codomain, and so this is only unambiguous for a symmetric braiding, where there is a unique way to permute the indices.</p><p>With the current syntax, we create a new object <code>E</code> because we use the definition operator <code>:=</code>. Furthermore, with the current syntax, it will be a <code>Tensor</code>, i.e. it will have a trivial domain, and correspond to the dotted box in the picture above, rather than the actual morphism <code>E</code>. We can also directly define <code>E</code> with the correct codomain and domain by rather using</p><pre><code class="language-julia hljs">@tensor E[a b c;d e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]</code></pre><p>or</p><pre><code class="language-julia hljs">@tensor E[(a,b,c);(d,e)] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]</code></pre><p>where the latter syntax can also be used when the codomain is empty. When using the assignment operator <code>=</code>, the <code>TensorMap</code> <code>E</code> is assumed to exist and the contents will be written to the currently allocated memory. Note that for existing tensors, both on the left hand side and right hand side, trying to specify the indices in the domain and the codomain seperately using the above syntax, has no effect, as the bipartition of indices are already fixed by the existing object. Hence, if <code>E</code> has been created by the previous line of code, all of the following lines are now equivalent</p><pre><code class="language-julia hljs">@tensor E[(a,b,c);(d,e)] = A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]
@tensor E[a,b,c,d,e] = A[v w d;x]*B[(y,z,c);(x,)]*C[v e y; b]*D[a,w,z]
@tensor E[a b; c d e] = A[v; w d x]*B[y,z,c,x]*C[v,e,y,b]*D[a w;z]</code></pre><p>and none of those will or can change the partition of the indices of <code>E</code> into its codomain and its domain.</p><p>Two final remarks are in order. Firstly, the order of the tensors appearing on the right hand side is irrelevant, as we can reorder them by using the allowed moves of the Penrose graphical calculus, which yields some crossings and a twist. As the latter is trivial, it can be omitted, and we just use the same rules to evaluate the newly ordered tensor network. For the particular case of matrix matrix multiplication, which also captures more general settings by appropriotely combining spaces into a single line, we indeed find</p><p><img src="../img/tensor-contractionreorder.svg" alt="tensor contraction reorder"/></p><p>or thus, the following to lines of code yield the same result</p><pre><code class="language-julia hljs">@tensor C[i,j] := B[i,k]*A[k,j]
@tensor C[i,j] := A[k,j]*B[i,k]</code></pre><p>Reordering of tensors can be used internally by the <code>@tensor</code> macro to evaluate the contraction in a more efficient manner. In particular, the NCON-style of specifying the contraction gives the user control over the order, and there are other macros, such as <code>@tensoropt</code>, that try to automate this process. There is also an <code>@ncon</code> macro and <code>ncon</code> function, an we recommend reading the <a href="https://jutho.github.io/TensorOperations.jl/stable/">manual of TensorOperations.jl</a> to learn more about the possibilities and how they work.</p><p>A final remark involves the use of adjoints of tensors. The current framework is such that the user should not be to worried about the actual bipartition into codomain and domain of a given <code>TensorMap</code> instance. Indeed, for factorizations one just specifies the requested bipartition via the <code>factorize(t, pleft, pright)</code> interface, and for tensor contractions the <code>@contract</code> macro figures out the correct manipulations automatically. However, when wanting to use the <code>adjoint</code> of an instance <code>t::TensorMap{S,N‚ÇÅ,N‚ÇÇ}</code>, the resulting <code>adjoint(t)</code> is a <code>AbstractTensorMap{S,N‚ÇÇ,N‚ÇÅ}</code> and one need to know the values of <code>N‚ÇÅ</code> and <code>N‚ÇÇ</code> to know exactly where the <code>i</code>th index of <code>t</code> will end up in <code>adjoint(t)</code>, and hence to know and understand the index order of <code>t&#39;</code>. Within the <code>@tensor</code> macro, one can instead use <code>conj()</code> on the whole index expression so as to be able to use the original index ordering of <code>t</code>. Indeed, for matrices of thus, <code>TensorMap{S,1,1}</code> instances, this yields exactly the equivalence one expects, namely equivalence between the following to expressions.</p><pre><code class="language-julia hljs">@tensor C[i,j] := B&#39;[i,k]*A[k,j]
@tensor C[i,j] := conj(B[k,i])*A[k,j]</code></pre><p>For e.g. an instance <code>A::TensorMap{S,3,2}</code>, the following two syntaxes have the same effect within an <code>@tensor</code> expression: <code>conj(A[a,b,c,d,e])</code> and <code>A&#39;[d,e,a,b,c]</code>.</p><p>Some examples:</p><h2 id="Fermionic-tensor-contractions"><a class="docs-heading-anchor" href="#Fermionic-tensor-contractions">Fermionic tensor contractions</a><a id="Fermionic-tensor-contractions-1"></a><a class="docs-heading-anchor-permalink" href="#Fermionic-tensor-contractions" title="Permalink"></a></h2><p>TODO</p><h2 id="Anyonic-tensor-contractions"><a class="docs-heading-anchor" href="#Anyonic-tensor-contractions">Anyonic tensor contractions</a><a id="Anyonic-tensor-contractions-1"></a><a class="docs-heading-anchor-permalink" href="#Anyonic-tensor-contractions" title="Permalink"></a></h2><p>TODO</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sectors/">¬´ Sectors, graded spaces and fusion trees</a><a class="docs-footer-nextpage" href="../../lib/sectors/">Symmetry sectors and fusion trees ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 19 December 2024 13:05">Thursday 19 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
